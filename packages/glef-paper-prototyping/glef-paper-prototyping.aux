{
  "version": 1,
  "state": {
    "glef-paper-prototyping.quickSheet": {
      "id": "glef-paper-prototyping.quickSheet",
      "space": "shared",
      "tags": {
        "onAnyBotDoubleClicked": "@const clickBot = that.bot;\n\nconst optionKeyState = os.getInputState('keyboard', 'Alt');\n\nif (optionKeyState) {\n    configBot.tags.sheetPortal = clickBot.id;\n}",
        "system": "glef-paper-prototyping.quickSheet"
      }
    },
    "glef-paper-prototyping.doubleClick": {
      "id": "glef-paper-prototyping.doubleClick",
      "space": "shared",
      "tags": {
        "doubleClickMS": "300",
        "onAnyBotClicked": "@const clickBot = that.bot;\nconst clickTime = Date.now();\n\nif (clickBot.tags.ab1ID) {\n    return;\n}\n\nif (links.lastClickBot === clickBot && masks.lastClickTime) {\n    const elapsedTime = clickTime - masks.lastClickTime;\n\n    if (elapsedTime <= tags.doubleClickMS) {\n        whisper(clickBot, 'onDoubleClick', that);\n        shout('onAnyBotDoubleClicked', that);\n    }\n}\n\nmasks.lastClickBot = clickBot.link;\nmasks.lastClickTime = clickTime;",
        "system": "glef-paper-prototyping.doubleClick"
      }
    },
    "glef-paper-prototyping.utils.math": {
      "id": "glef-paper-prototyping.utils.math",
      "space": "shared",
      "tags": {
        "initialize": "@if (!globalThis.GLEF) {\n\tglobalThis.GLEF = {}\n}\n\nGLEF.math = {};\n\n// ==========\n// math utils\n// ==========\nconst utils = {}\nGLEF.math.utils = utils;\n\nutils.degToRad = (degrees) => {\n    return degrees * (Math.PI / 180);\n}\n\nutils.radToDeg = (radians) => {\n    return radians * (180 / Math.PI);\n}\n\nutils.clamp = (value, min, max) => {\n\treturn Math.max(min, Math.min(max, value));\n}\n\nutils.fmod = (a, b) => {\n\treturn Number((a - (Math.floor(a / b) * b)).toPrecision(8));\n}\n\nutils.wrapTo2Pi = (a) => {\n\ta = utils.fmod(a, Math.PI * 2);\n\treturn a;\n}\n\nutils.flipYZ = (v, sign) => {\n\tconst y = v.y;\n\tconst z = v.z;\n\tv.z = y;\n\tv.y = sign ? -z : z;\n}\n\nutils.normalize = (value, min, max) => {\n\treturn (value - min) / (max - min);\n}\n\nutils.unnormalize = (normal, min, max) => {\n\treturn normal * (max - min) + min;\n}\n\nutils.lerp = (a, b, t) => {\n\treturn a + (b - a) * t;\n}\n\nutils.pointOnCircle = (center, radius, angle) => {\n\tconst angleRad = angle * utils.DEG2RAD;\n\n\tconst point = {\n\t\tx: center.x + radius * Math.sin(angleRad),\n\t\ty: center.y + radius * Math.cos(angleRad)\n\t};\n\n\treturn point;\n}\n\n/**\n * prettyFloat will round a number to the specified decimal points and then remove any trailing zeros\n * if they are present after rounding to fixed point number. Integers are returned as-is.\n */\nutils.prettyFloat = (n, decimalPlaces = 2) => {\n\tif (Number.isInteger(n)) {\n\t\treturn n;\n\t} else {\n\t\tconst fixed = n.toFixed(decimalPlaces);\n\t\treturn parseFloat(fixed);\n\t}\n}\n\n// ==========\n// plane\n// ==========\nconst plane = {};\nGLEF.math.plane = plane;\n\nplane.fromNormalAndCoplanarPoint = (normal, point) => {\n\tlet newPlane = {\n\t\tnormal: {...normal},\n\t\tconstant: -vector3.dot(point, normal)\n\t}\n\n\treturn newPlane;\n}\n\nplane.fromCoplanarPoints = (a, b, c) => {\n\tconst cb = math.subtractVectors({...c}, b);\n\tconst ab = math.subtractVectors({...a}, b);\n\n\tconst normal = math.normalizeVector( vector3.crossVectors(cb, ab) );\n\n\treturn plane.fromNormalAndCoplanarPoint(normal, a);\n}\n\nplane.distanceToPoint = (plane, point) => {\n\treturn vector3.dot(plane.normal, point) + plane.constant;\n}\n\nplane.intersectRay = (plane, ray) => {\n\tconst t = GLEF.math.ray.distanceToPlane(ray, plane);\n\n\tif (t === null) {\n\t\treturn null;\n\t}\n\n\treturn GLEF.math.ray.at(ray, t);\n}\n\n// ==========\n// ray\n// ==========\nconst ray = {};\nGLEF.math.ray = ray;\n\nray.distanceToPlane = (ray, plane) => {\n\tconst denominator = vector3.dot(plane.normal, ray.direction);\n\n\tif (denominator === 0) {\n\t\t// line is coplanar, return origin.\n\t\tif (GLEF.math.plane.distanceToPoint(plane, ray.origin) === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tconst t = -( vector3.dot(ray.origin, plane.normal) + plane.constant ) / denominator;\n\n\t// Return if the ray never intersect the plane.\n\treturn t >= 0 ? t : null;\n}\n\nray.at = (ray, distance) => {\n\tlet point = {...ray.origin};\n\tconst dirScaled = vector3.multiplyScalar({...ray.direction}, distance);\n\tpoint = math.addVectors(point, dirScaled);\n\n\treturn point;\n}\n\n// ==========\n// vector3\n// ==========\nconst vector3 = {};\nGLEF.math.vector3 = vector3;\n\nvector3.zero = () => {\n\treturn { x: 0, y: 0, z: 0 }\n}\n\nvector3.up = () => {\n\treturn { x: 0, y: 1, z: 0 }\n}\n\nvector3.one = () => {\n\treturn { x: 1, y: 1, z: 1 }\n}\n\nvector3.applyQuaternion = (v, q) => {\n\tconst x = v.x, y = v.y, z = v.z;\n\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t// calculate quat * vector\n\tconst ix = qw * x + qy * z - qz * y;\n\tconst iy = qw * y + qz * x - qx * z;\n\tconst iz = qw * z + qx * y - qy * x;\n\tconst iw = - qx * x - qy * y - qz * z;\n\n\t// calculate result * inverse quat\n\tv.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\tv.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\tv.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\treturn v;\n}\n\nvector3.lengthSq = (v) => {\n\treturn v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nvector3.dot = (v1, v2) => {\n\treturn v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}\n\nvector3.angle = (v1, v2) => {\n\tconst denominator = Math.sqrt(vector3.lengthSq(v1) * vector3.lengthSq(v2));\n\tif (denominator === 0) return Math.PI / 2;\n\n\tconst theta = vector3.dot(v1, v2) / denominator;\n\t// clamp, to handle numerical problems\n\treturn Math.acos(utils.clamp(theta, - 1, 1));\n}\n\nvector3.lerp = (v1, v2, t) => {\n\treturn {\n\t\tx: v1.x + (v2.x - v1.x) * t,\n\t\ty: v1.y + (v2.y - v1.y) * t,\n\t\tz: v1.z + (v2.z - v1.z) * t\n\t}\n}\n\nvector3.length = (v) => {\n\treturn Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n}\n\nvector3.lengthSq = (v) => {\n\treturn v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nvector3.setLength = (v, l) => {\n\tv = math.normalizeVector(v);\n\tv = vector3.multiplyScalar(v, l);\n\n\treturn v;\n}\n\nvector3.applyMatrix4 = (v, m) => {\n\tconst x = v.x, y = v.y, z = v.z;\n\tconst w = 1 / (m[3] * x + m[7] * y + m[11] * z + m[15]);\n\n\tv.x = (m[0] * x + m[4] * y + m[8] * z + m[12]) * w;\n\tv.y = (m[1] * x + m[5] * y + m[9] * z + m[13]) * w;\n\tv.z = (m[2] * x + m[6] * y + m[10] * z + m[14]) * w;\n\n\treturn v;\n}\n\nvector3.multiply = (v1, v2) => {\n\tv1.x *= v2.x;\n\tv1.y *= v2.y;\n\tv1.z *= v2.z;\n\n\treturn v1;\n}\n\nvector3.multiplyScalar = (v, s) => {\n\tv.x *= s;\n\tv.y *= s;\n\tv.z *= s;\n\n\treturn v;\n}\n\nvector3.divide = (v1, v2) => {\n\tv1.x /= v2.x;\n\tv1.y /= v2.y;\n\tv1.z /= v2.z;\n\n\treturn v1;\n}\n\nvector3.divideScalar = (v, s) => {\n\treturn vector3.multiplyScalar(v, 1 / s);\n}\n\nvector3.crossVectors = (a, b) => {\n\tconst v = vector3.zero();\n\tconst ax = a.x, ay = a.y, az = a.z;\n\tconst bx = b.x, by = b.y, bz = b.z;\n\n\tv.x = ay * bz - az * by;\n\tv.y = az * bx - ax * bz;\n\tv.z = ax * by - ay * bx;\n\treturn v;\n}\n\nvector3.applyEuler = (v, euler, order = 'XYZ') => {\n\treturn vector3.applyQuaternion(v, quaternion.fromEuler(euler, order));\n}\n\nvector3.applyAxisAngle = (v, axis, angle) => {\n\treturn vector3.applyQuaternion(v, quaternion.setFromAxisAngle(axis, angle));\n}\n\nvector3.transformDirection = (v, m) => {\n\tlet x = v.x, y = v.y, z = v.z;\n\n\tlet newX = m[0] * x + m[4] * y + m[8] * z;\n\tlet newY = m[1] * x + m[5] * y + m[9] * z;\n\tlet newZ = m[2] * x + m[6] * y + m[10] * z;\n\n\treturn math.normalizeVector({ x: newX, y: newY, z: newZ });\n}\n\n\nvector3.setFromRotationMatrix = (m, order = 'XYZ') => {\n\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t// console.log(`[vector3.setFromRotationMatrix] 1. matrix`, JSON.stringify(m));\n\tconst m11 = m[0], m12 = m[4], m13 = m[8];\n\tconst m21 = m[1], m22 = m[5], m23 = m[9];\n\tconst m31 = m[2], m32 = m[6], m33 = m[10];\n\tconst v = vector3.zero();\n\n\tswitch (order) {\n\t\tcase 'XYZ':\n\t\t\tv.y = Math.asin(utils.clamp(m13, - 1, 1));\n\n\t\t\tif (Math.abs(m13) < 0.9999999) {\n\t\t\t\tv.x = Math.atan2(- m23, m33);\n\t\t\t\tv.z = Math.atan2(- m12, m11);\n\t\t\t} else {\n\t\t\t\tv.x = Math.atan2(m32, m22);\n\t\t\t\tv.z = 0;\n\t\t\t}\n\t\t\t// console.log(`[vector3.setFromRotationMatrix] 2. XYZ swizzle`, JSON.stringify(v));\n\t\t\tbreak;\n\t\tcase 'YXZ':\n\t\t\tv.x = Math.asin(- utils.clamp(m23, - 1, 1));\n\n\t\t\tif (Math.abs(m23) < 0.9999999) {\n\t\t\t\tv.y = Math.atan2(m13, m33);\n\t\t\t\tv.z = Math.atan2(m21, m22);\n\t\t\t} else {\n\t\t\t\tv.y = Math.atan2(- m31, m11);\n\t\t\t\tv.z = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'ZXY':\n\t\t\tv.x = Math.asin(utils.clamp(m32, - 1, 1));\n\n\t\t\tif (Math.abs(m32) < 0.9999999) {\n\t\t\t\tv.y = Math.atan2(- m31, m33);\n\t\t\t\tv.z = Math.atan2(- m12, m22);\n\t\t\t} else {\n\t\t\t\tv.y = 0;\n\t\t\t\tv.z = Math.atan2(m21, m11);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'ZYX':\n\t\t\tv.y = Math.asin(- utils.clamp(m31, - 1, 1));\n\n\t\t\tif (Math.abs(m31) < 0.9999999) {\n\t\t\t\tv.x = Math.atan2(m32, m33);\n\t\t\t\tv.z = Math.atan2(m21, m11);\n\t\t\t} else {\n\t\t\t\tv.x = 0;\n\t\t\t\tv.z = Math.atan2(- m12, m22);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'YZX':\n\t\t\tv.z = Math.asin(utils.clamp(m21, - 1, 1));\n\n\t\t\tif (Math.abs(m21) < 0.9999999) {\n\t\t\t\tv.x = Math.atan2(- m23, m22);\n\t\t\t\tv.y = Math.atan2(- m31, m11);\n\t\t\t} else {\n\t\t\t\tv.x = 0;\n\t\t\t\tv.y = Math.atan2(m13, m33);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'XZY':\n\t\t\tv.z = Math.asin(- utils.clamp(m12, - 1, 1));\n\n\t\t\tif (Math.abs(m12) < 0.9999999) {\n\t\t\t\tv.x = Math.atan2(m32, m22);\n\t\t\t\tv.y = Math.atan2(m13, m11);\n\t\t\t} else {\n\t\t\t\tv.x = Math.atan2(- m23, m33);\n\t\t\t\tv.y = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconsole.warn('[vector3.setFromRotationMatrix] encountered an unknown order: ' + order);\n\t}\n\n\treturn v;\n}\n\nvector3.setFromQuaternion = (q, order = 'XYZ') => {\n\tconst m = matrix4.compose(vector3.zero(), q, vector3.one());\n\treturn vector3.setFromRotationMatrix(m, order);\n}\n\nvector3.localToWorld = (vector, matrixWorld) => {\n\treturn vector3.applyMatrix4(vector, matrixWorld);\n}\n\nvector3.worldToLocal = (vector, matrixWorld) => {\n\tconst inverseMatrix = matrix4.invert([...matrixWorld]);\n\treturn vector3.applyMatrix4(vector, inverseMatrix);\n}\n\n// ==========\n// quaternion\n// ==========\nconst quaternion = {};\nGLEF.math.quaternion = quaternion;\n\nquaternion.identity = () => {\n\treturn { x: 0, y: 0, z: 0, w: 1 };\n}\n\nquaternion.setFromRotationMatrix = (q, m) => {\n\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\tconst m11 = m[0], m12 = m[4], m13 = m[8];\n\tconst m21 = m[1], m22 = m[5], m23 = m[9];\n\tconst m31 = m[2], m32 = m[6], m33 = m[10];\n\n\tconst trace = m11 + m22 + m33;\n\n\tif (trace > 0) {\n\t\tconst s = 0.5 / Math.sqrt(trace + 1.0);\n\n\t\tq.w = 0.25 / s;\n\t\tq.x = (m32 - m23) * s;\n\t\tq.y = (m13 - m31) * s;\n\t\tq.z = (m21 - m12) * s;\n\t} else if (m11 > m22 && m11 > m33) {\n\t\tconst s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n\t\tq.w = (m32 - m23) / s;\n\t\tq.x = 0.25 * s;\n\t\tq.y = (m12 + m21) / s;\n\t\tq.z = (m13 + m31) / s;\n\t} else if (m22 > m33) {\n\t\tconst s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n\t\tq.w = (m13 - m31) / s;\n\t\tq.x = (m12 + m21) / s;\n\t\tq.y = 0.25 * s;\n\t\tq.z = (m23 + m32) / s;\n\t} else {\n\t\tconst s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n\t\tq.w = (m21 - m12) / s;\n\t\tq.x = (m13 + m31) / s;\n\t\tq.y = (m23 + m32) / s;\n\t\tq.z = 0.25 * s;\n\t}\n\n\treturn q;\n}\n\nquaternion.setFromAxisAngle = (axis, angle) => {\n\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t// assumes axis is normalized\n\tconst q = quaternion.identity();\n\tconst halfAngle = angle / 2, s = Math.sin(halfAngle);\n\n\tq.x = axis.x * s;\n\tq.y = axis.y * s;\n\tq.z = axis.z * s;\n\tq.w = Math.cos(halfAngle);\n\n\treturn q;\n}\n\nquaternion.setFromUnitVectors = (vFrom, vTo) => {\n\t// assumes direction vectors vFrom and vTo are normalized\n\tconst q = quaternion.identity();\n\tlet r = vector3.dot(vFrom, vTo) + 1;\n\n\tif (r < Number.EPSILON) {\n\n\t\t// vFrom and vTo point in opposite directions\n\n\t\tr = 0;\n\n\t\tif (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n\n\t\t\tq.x = - vFrom.y;\n\t\t\tq.y = vFrom.x;\n\t\t\tq.z = 0;\n\t\t\tq.w = r;\n\n\t\t} else {\n\n\t\t\tq.x = 0;\n\t\t\tq.y = - vFrom.z;\n\t\t\tq.z = vFrom.y;\n\t\t\tq.w = r;\n\n\t\t}\n\n\t} else {\n\n\t\tq.x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n\t\tq.y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n\t\tq.z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n\t\tq.w = r;\n\n\t}\n\n\treturn quaternion.normalize(q);\n}\n\nquaternion.fromEuler = (euler, order = 'XYZ') => {\n\tconst q = quaternion.identity();\n\tconst x = euler.x, y = euler.y, z = euler.z;\n\n\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m\n\tconst c1 = Math.cos(x / 2);\n\tconst c2 = Math.cos(y / 2);\n\tconst c3 = Math.cos(z / 2);\n\n\tconst s1 = Math.sin(x / 2);\n\tconst s2 = Math.sin(y / 2);\n\tconst s3 = Math.sin(z / 2);\n\n\tswitch (order) {\n\t\tcase 'XYZ':\n\t\t\tq.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tq.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tq.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tq.w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\tbreak;\n\t\tcase 'YXZ':\n\t\t\tq.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tq.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tq.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tq.w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\tbreak;\n\t\tcase 'ZXY':\n\t\t\tq.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tq.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tq.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tq.w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\tbreak;\n\t\tcase 'ZYX':\n\t\t\tq.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tq.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tq.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tq.w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\tbreak;\n\t\tcase 'YZX':\n\t\t\tq.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tq.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tq.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tq.w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\tbreak;\n\t\tcase 'XZY':\n\t\t\tq.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tq.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tq.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tq.w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconsole.warn('[quaternion.fromEuler] encountered an unknown order: ' + order);\n\t}\n\n\treturn q;\n}\n\nquaternion.multiplyQuaternions = (a, b) => {\n\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\tconst q = quaternion.identity();\n\tconst qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;\n\tconst qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;\n\n\tq.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\tq.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\tq.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\tq.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\treturn q;\n}\n\nquaternion.length = (q) => {\n\treturn Math.sqrt(q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w);\n}\n\nquaternion.normalize = (q) => {\n\tlet l = quaternion.length(q);\n\n\tif (l === 0) {\n\t\tq.x = 0;\n\t\tq.y = 0;\n\t\tq.z = 0;\n\t\tq.w = 1;\n\t} else {\n\t\tl = 1 / l;\n\n\t\tq.x = q.x * l;\n\t\tq.y = q.y * l;\n\t\tq.z = q.z * l;\n\t\tq.w = q.w * l;\n\t}\n\n\treturn q;\n}\n\nquaternion.invert = (q) => {\n\t// quaternion is assumed to have unit length\n\treturn quaternion.conjugate(q);\n}\n\nquaternion.conjugate = (q) => {\n\tq.x *= - 1;\n\tq.y *= - 1;\n\tq.z *= - 1;\n\n\treturn q;\n}\n\n// ==========\n// matrix4\n// ==========\nconst matrix4 = {};\nGLEF.math.matrix4 = matrix4;\n\nmatrix4.identity = () => {\n\treturn [\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\t];\n}\n\nmatrix4.multiplyMatrices = (m, a, b) => {\n\tconst a11 = a[0], a12 = a[4], a13 = a[8], a14 = a[12];\n\tconst a21 = a[1], a22 = a[5], a23 = a[9], a24 = a[13];\n\tconst a31 = a[2], a32 = a[6], a33 = a[10], a34 = a[14];\n\tconst a41 = a[3], a42 = a[7], a43 = a[11], a44 = a[15];\n\n\tconst b11 = b[0], b12 = b[4], b13 = b[8], b14 = b[12];\n\tconst b21 = b[1], b22 = b[5], b23 = b[9], b24 = b[13];\n\tconst b31 = b[2], b32 = b[6], b33 = b[10], b34 = b[14];\n\tconst b41 = b[3], b42 = b[7], b43 = b[11], b44 = b[15];\n\n\tm[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\tm[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\tm[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\tm[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\tm[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\tm[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\tm[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\tm[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\tm[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\tm[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\tm[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\tm[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\tm[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\tm[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\tm[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\tm[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n\n\treturn m;\n}\n\nmatrix4.invert = (m) => {\n\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\tconst n11 = m[0], n21 = m[1], n31 = m[2], n41 = m[3];\n\tconst n12 = m[4], n22 = m[5], n32 = m[6], n42 = m[7];\n\tconst n13 = m[8], n23 = m[9], n33 = m[10], n43 = m[11];\n\tconst n14 = m[12], n24 = m[13], n34 = m[14], n44 = m[15];\n\n\tconst t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\n\tconst t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\n\tconst t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\n\tconst t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\tif (det === 0) return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n\tconst detInv = 1 / det;\n\n\tm[0] = t11 * detInv;\n\tm[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n\tm[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n\tm[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n\n\tm[4] = t12 * detInv;\n\tm[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n\tm[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n\tm[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n\n\tm[8] = t13 * detInv;\n\tm[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n\tm[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n\tm[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n\n\tm[12] = t14 * detInv;\n\tm[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n\tm[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n\tm[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n\n\treturn m;\n}\n\nmatrix4.compose = (position, quaternion, scale) => {\n\tconst m = matrix4.identity();\n\n\tconst x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;\n\tconst x2 = x + x, y2 = y + y, z2 = z + z;\n\tconst xx = x * x2, xy = x * y2, xz = x * z2;\n\tconst yy = y * y2, yz = y * z2, zz = z * z2;\n\tconst wx = w * x2, wy = w * y2, wz = w * z2;\n\n\tconst sx = scale.x, sy = scale.y, sz = scale.z;\n\n\tm[0] = (1 - (yy + zz)) * sx;\n\tm[1] = (xy + wz) * sx;\n\tm[2] = (xz - wy) * sx;\n\tm[3] = 0;\n\n\tm[4] = (xy - wz) * sy;\n\tm[5] = (1 - (xx + zz)) * sy;\n\tm[6] = (yz + wx) * sy;\n\tm[7] = 0;\n\n\tm[8] = (xz + wy) * sz;\n\tm[9] = (yz - wx) * sz;\n\tm[10] = (1 - (xx + yy)) * sz;\n\tm[11] = 0;\n\n\tm[12] = position.x;\n\tm[13] = position.y;\n\tm[14] = position.z;\n\tm[15] = 1;\n\n\treturn m;\n}\n\nmatrix4.decompose = (m) => {\n\tconst p = vector3.zero();\n\tconst q = quaternion.identity();\n\tconst s = vector3.zero();\n\n\tlet sx = vector3.length({ x: m[0], y: m[1], z: m[2] });\n\tconst sy = vector3.length({ x: m[4], y: m[5], z: m[6] });\n\tconst sz = vector3.length({ x: m[8], y: m[9], z: m[10] });\n\n\t// if determine is negative, we need to invert one scale\n\tconst det = matrix4.determinant(m);\n\tif (det < 0) sx = - sx;\n\n\tp.x = m[12];\n\tp.y = m[13];\n\tp.z = m[14];\n\n\t// scale the rotation part\n\tlet m1 = [...m];\n\n\tconst invSX = 1 / sx;\n\tconst invSY = 1 / sy;\n\tconst invSZ = 1 / sz;\n\n\tm1[0] *= invSX;\n\tm1[1] *= invSX;\n\tm1[2] *= invSX;\n\n\tm1[4] *= invSY;\n\tm1[5] *= invSY;\n\tm1[6] *= invSY;\n\n\tm1[8] *= invSZ;\n\tm1[9] *= invSZ;\n\tm1[10] *= invSZ;\n\n\tquaternion.setFromRotationMatrix(q, m1);\n\n\ts.x = sx;\n\ts.y = sy;\n\ts.z = sz;\n\n\treturn {\n\t\tposition: p,\n\t\tquaternion: q,\n\t\tscale: s,\n\t}\n}\n\nmatrix4.determinant = (m) => {\n\tconst n11 = m[0], n12 = m[4], n13 = m[8], n14 = m[12];\n\tconst n21 = m[1], n22 = m[5], n23 = m[9], n24 = m[13];\n\tconst n31 = m[2], n32 = m[6], n33 = m[10], n34 = m[14];\n\tconst n41 = m[3], n42 = m[7], n43 = m[11], n44 = m[15];\n\n\t//TODO: make this more efficient\n\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\treturn (\n\t\tn41 * (\n\t\t\t+ n14 * n23 * n32\n\t\t\t- n13 * n24 * n32\n\t\t\t- n14 * n22 * n33\n\t\t\t+ n12 * n24 * n33\n\t\t\t+ n13 * n22 * n34\n\t\t\t- n12 * n23 * n34\n\t\t) +\n\t\tn42 * (\n\t\t\t+ n11 * n23 * n34\n\t\t\t- n11 * n24 * n33\n\t\t\t+ n14 * n21 * n33\n\t\t\t- n13 * n21 * n34\n\t\t\t+ n13 * n24 * n31\n\t\t\t- n14 * n23 * n31\n\t\t) +\n\t\tn43 * (\n\t\t\t+ n11 * n24 * n32\n\t\t\t- n11 * n22 * n34\n\t\t\t- n14 * n21 * n32\n\t\t\t+ n12 * n21 * n34\n\t\t\t+ n14 * n22 * n31\n\t\t\t- n12 * n24 * n31\n\t\t) +\n\t\tn44 * (\n\t\t\t- n13 * n22 * n31\n\t\t\t- n11 * n23 * n32\n\t\t\t+ n11 * n22 * n33\n\t\t\t+ n13 * n21 * n32\n\t\t\t- n12 * n21 * n33\n\t\t\t+ n12 * n23 * n31\n\t\t)\n\t);\n}\n\nmatrix4.lookAt = (m, eye, target, up) => {\n\tlet x, y, z;\n\n\tz = math.subtractVectors(target, eye);\n\n\tif (vector3.lengthSq(z) === 0) {\n\t\t// eye and target are in the same position\n\t\tz.z = 1;\n\t}\n\n\tz = math.normalizeVector(z);\n\tx = vector3.crossVectors(up, z);\n\n\tif (vector3.lengthSq(x) === 0) {\n\t\t// up and z are parallel\n\t\tif (Math.abs(up.z) === 1) {\n\t\t\tz.x += 0.0001;\n\t\t} else {\n\t\t\tz.z += 0.0001;\n\t\t}\n\n\t\tz = math.normalizeVector(z);\n\t\tx = vector3.crossVectors(up, z);\n\t}\n\n\tx = math.normalizeVector(x);\n\ty = vector3.crossVectors(z, x);\n\n\tm[0] = x.x; m[4] = y.x; m[8] = z.x;\n\tm[1] = x.y; m[5] = y.y; m[9] = z.y;\n\tm[2] = x.z; m[6] = y.z; m[10] = z.z;\n\n\treturn m;\n}\n\nmatrix4.localMatrixFromBot = (bot, dimension) => {\n\tconst p = {\n\t\tx: bot.tags[dimension + \"X\"] ?? 0,\n\t\ty: bot.tags[dimension + \"Y\"] ?? 0,\n\t\tz: bot.tags[dimension + \"Z\"] ?? 0,\n\t};\n\n\tconst r = {\n\t\tx: bot.tags[dimension + \"RotationX\"] ?? 0,\n\t\ty: bot.tags[dimension + \"RotationY\"] ?? 0,\n\t\tz: bot.tags[dimension + \"RotationZ\"] ?? 0,\n\t};\n\tconst q = quaternion.fromEuler(r);\n\tconst s = {\n\t\tx: bot.tags[\"scaleX\"] ?? 1,\n\t\ty: bot.tags[\"scaleY\"] ?? 1,\n\t\tz: bot.tags[\"scaleZ\"] ?? 1,\n\t};\n\tconst scalar = bot.tags[\"scale\"] ?? 1;\n\tvector3.multiplyScalar(s, scalar);\n\n\t// Local matrix is actually affected by parent in CasualOS.\n\t// Primarily due to the anchorPoint concept.\n\tconst parentId = bot.tags.transformer;\n\tlet parent = parentId ? getBot('id', parentId) : null;\n\n\tif (parent) {\n\t\tlet parentAnchorOffset = math.getAnchorPointOffset(parent.tags['anchorPoint'] ?? 'bottom');\n\t\tparentAnchorOffset.y *= -1; // Seems to be a bug in CasualOS, anchor point y is flipped?\n\t\t// console.log(`parent ${parent.id.substring(0, 5)} anchorPointOffset`, parentAnchorOffset);\n\n\t\t// let parentScale = {\n\t\t// \tx: parent.tags['scaleX'] ?? 1,\n\t\t// \ty: parent.tags['scaleY'] ?? 1,\n\t\t// \tz: parent.tags['scaleZ'] ?? 1,\n\t\t// }\n\t\t// let parentScalar = parent.tags['scale'] ?? 1;\n\t\t// vector3.multiplyScalar(parentScale, parentScalar);\n\n\t\t// console.log(`parent ${parent.id.substring(0, 5)} scale`, parentScale);\n\n\t\tp.x += (parentAnchorOffset.x * 2);\n\t\tp.y += (parentAnchorOffset.y * 2);\n\t\tp.z += (parentAnchorOffset.z * 2);\n\t}\n\n\treturn matrix4.compose(p, q, s);\n}\n\nmatrix4.worldMatrixFromBot = (bot, dimension) => {\n\t// console.log(`[matrix4] worldMatrixFromBot bot: ${bot.id.substring(0,5)}, dimension: ${dimension}`);\n\n\tlet matrixWorld = matrix4.identity();\n\tconst matrixLocal = matrix4.localMatrixFromBot(bot, dimension);\n\n\tconst parentId = bot.tags.transformer;\n\tlet parent = parentId ? getBot('id', parentId) : null;\n\n\tif (!parent) {\n\t\tmatrixWorld = matrixLocal;\n\t\t// console.log(`[matrix4] worldMatrixFromBot bot ${bot.id.substring(0,5)} has no parent.`);\n\t\t// console.log(`[matrix4] worldMatrixFromBot bot ${bot.id.substring(0,5)} matrixWorld:`, matrixWorld);\n\t} else {\n\t\t// console.log(`[matrix4] worldMatrixFromBot bot ${bot.id.substring(0,5)} has parent ${parent.id.substring(0, 5)}.`);\n\t\t// console.log(`[matrix4] worldMatrixFromBot bot ${bot.id.substring(0,5)} matrixLocal:`, matrixLocal);\n\t\tconst parentMatrixWorld = matrix4.worldMatrixFromBot(parent, dimension);\n\t\tmatrixWorld = matrix4.multiplyMatrices(matrixWorld, parentMatrixWorld, matrixLocal);\n\t}\n\n\treturn matrixWorld;\n}",
        "onBotAdded": "@thisBot.initialize();",
        "onBotChanged": "@thisBot.initialize();",
        "system": "glef-paper-prototyping.utils.math"
      }
    },
    "glef-paper-prototyping.multiSelectDelete": {
      "id": "glef-paper-prototyping.multiSelectDelete",
      "space": "shared",
      "tags": {
        "onKeyDown": "@if (multiSelect.vars.selectedBots.length > 0) {\n    const deleteKeyPressed = that.keys.some(k => k === 'Delete');\n\n    if (deleteKeyPressed) {\n        // Only allow delete if the user is not in one of these portals.\n        const BLACKLIST_PORTALS = [ 'sheetPortal', 'systemPortal', 'tagPortal' ];\n        \n        const configBotPortalTags = Object.keys(configBot.tags).filter(t => t.endsWith('Portal'));\n\n        for (let portalTag of configBotPortalTags) {\n            if (BLACKLIST_PORTALS.includes(portalTag)) {\n                return;\n            }\n        }\n\n        destroy(multiSelect.vars.selectedBots);\n    }\n}",
        "system": "glef-paper-prototyping.multiSelectDelete"
      }
    },
    "glef-paper-prototyping.multiSelectClone": {
      "id": "glef-paper-prototyping.multiSelectClone",
      "space": "shared",
      "tags": {
        "debug": "false",
        "onAnyBotDrag": "@const optionKeyState = os.getInputState('keyboard', 'Alt');\n\nif (optionKeyState) {\n    const dragBot = that.bot;\n    const selectedBots = multiSelect.vars.selectedBots;\n    const draggingSelectedBot = selectedBots.some(b => b === dragBot);\n\n    if (draggingSelectedBot) {\n        if (tags.debug) {\n            console.log(`[${tags.system}] dragging selected bot will clone all other selected bots`);\n        }\n\n        let clones = [];\n        let dragBotCloneIndex;\n\n        // Clone all selected bots and add them all to the multi selection.\n        for (let i = 0; i < selectedBots.length; i++) {\n            clones.push(create(selectedBots[i]));\n\n            if (selectedBots[i] === dragBot) {\n                dragBotCloneIndex = i;\n            }\n        }\n\n        // await os.sleep(100);\n\n        // Clear selection of original objects, we're about to select all the clones.\n        multiSelect.selectClear('from multiSelectClone onAnyBotDrag');\n\n        for (let i = 0; i < clones.length; i++) {\n            multiSelect.selectAdd({ bot: clones[i] });\n            \n            // If this clone belongs to our drag bot then replace the drag bot with its clone.\n            if (dragBotCloneIndex === i) {\n                // Store some metadata on multiSelectDrag so that it can perform\n                // the custom dragging operation on the newly cloned bots.\n                multiSelectDrag.vars.dragClones = clones;\n            }\n        }\n    } else {\n        if (tags.debug) {\n            console.log(`[${tags.system}] clone drag an deselected bot`);\n        }\n\n        const clone = create(dragBot);\n        os.replaceDragBot(clone);\n    }\n}",
        "system": "glef-paper-prototyping.multiSelectClone"
      }
    },
    "glef-paper-prototyping._packageInfo": {
      "id": "glef-paper-prototyping._packageInfo",
      "space": "shared",
      "tags": {
        "system": "glef-paper-prototyping._packageInfo",
        "version": "0.12",
        "versionDate": "ðŸ“…2023-09-11T13:29:27.655-04:00 local"
      }
    },
    "glef-paper-prototyping.multiSelectDrag": {
      "id": "glef-paper-prototyping.multiSelectDrag",
      "space": "shared",
      "tags": {
        "debug": "false",
        "onAnyBotDrag": "@const dragBot = that.bot;\nconst dragFrom = that.from;\n\nconst draggingSelectedBot = multiSelect.vars.selectedBots.some(b => b.id === dragBot.id) ||\n                            (thisBot.vars.dragClones && thisBot.vars.dragClones.length > 0);\n\nif (tags.debug) {\n    console.log(`[${tags.system}] multiSelectDrag onAnyBotDrag that:`, that);\n    console.log(`[${tags.system}] multiSelectDrag onAnyBotDrag selectedBots:`, multiSelect.vars.selectedBots);\n    console.log(`[${tags.system}] multiSelectDrag onAnyBotDrag draggingSelectedBot:`, draggingSelectedBot);\n}\n\nif (draggingSelectedBot) {\n    if (tags.debug) {\n        console.log(`[${tags.system}] dragging selected bot`);\n    }\n\n    masks.dragFrom = {\n        x: dragFrom.x,\n        y: dragFrom.y,\n        dimension: dragFrom.dimension\n    };\n\n    os.enableCustomDragging();\n\n    if (ab1InstMemory.tags.ab1GridSnapState == true) {\n        os.addDropSnap('grid');\n    }\n    if (ab1InstMemory.tags.ab1BotSnapState == 'face') {\n        os.addDropSnap(\"face\");\n    }\n} else {\n    if (multiSelect.vars.selectedBots.length) {\n        multiSelect.selectClear('from multiSelectDrag onAnyBotDrag');\n    }\n}",
        "onAnyBotDragging": "@const dragBot = that.bot;\nconst dragTo = that.to;\n\nif (tags.debug) {\n    console.log(`[${tags.system}] onAnyBotDragging:`, that);\n}\n\nif (masks.dragFrom) {\n    const delta = {\n        x: dragTo.x - masks.dragFrom.x,\n        y: dragTo.y - masks.dragFrom.y,\n        dimension: dragTo.dimension,\n    }\n\n    if (tags.debug) {\n        console.log(`[${tags.system}] onAnyBotDragging delta:`, delta);\n    }\n\n    if (delta.x !== 0 ||\n        delta.y !== 0\n    ) {\n        // Drag position has moved.\n        if (tags.debug) {\n            console.log(`[${tags.system}] drag position has moved`, delta);\n        }\n\n        for (let selectedBot of multiSelect.vars.selectedBots) {\n            let x = selectedBot.tags[delta.dimension + 'X'] ?? 0;\n            let y = selectedBot.tags[delta.dimension + 'Y'] ?? 0;\n\n            selectedBot.tags[delta.dimension + 'X'] = x + delta.x;\n            selectedBot.tags[delta.dimension + 'Y'] = y + delta.y;\n            selectedBot.tags[delta.dimension] = true;\n        }\n\n        masks.dragFrom = {\n            x: masks.dragFrom.x + delta.x,\n            y: masks.dragFrom.y + delta.y,\n            dimension: delta.dimension,\n        };\n    }\n}",
        "onAnyBotDrop": "@if (tags.debug) {\n    console.log(`[${tags.system}] onAnyBotDrop`, that);\n}\n\nmasks.dragFrom = null;\nthisBot.vars.dragClones = null;\n",
        "onBotAdded": "@globalThis.multiSelectDrag = thisBot;",
        "onDestroy": "@globalThis.multiSelectDrag = undefined;",
        "system": "glef-paper-prototyping.multiSelectDrag"
      }
    },
    "glef-paper-prototyping.transform": {
      "id": "glef-paper-prototyping.transform",
      "space": "shared",
      "tags": {
        "clearTool": "@if (masks.targetBot) {\n    if (tags.debug) {\n        console.log(`[${tags.system}] clearTool`);\n    }\n\n    masks.targetBot = null;\n    masks.targetDimension = null;\n\n    destroy(links.toolBots);\n}\n",
        "debug": "false",
        "onAnyAction": "@if (that.action.type === 'update_bot') {\n    const bot = getBot('id', that.action.id);\n\n    if (bot.tags.isTransformBot) {\n        whisper(bot, 'onUpdateBotAction', that)\n    }\n}",
        "onAnyBotClicked": "@const clickedBot = that.bot;\nconst clickedDimension = that.dimension;\n\nif (clickedBot.tags.ab1ID) {\n    return;\n}\n\nconst ctrlKeyState = os.getInputState('keyboard', 'Control');\n\nif (ctrlKeyState) {\n    thisBot.setTool({ targetBot: clickedBot, dimension: clickedDimension});\n    thisBot.updateTool();\n} else {\n    thisBot.clearTool();\n}",
        "onAnyBotsChanged": "@if (links.targetBot) {\n    for (let change of that) {\n        if (change.bot === links.targetBot) {\n            let transformChanged = change.tags.some((t) => {\n                return t.endsWith('X') ||\n                       t.endsWith('Y') ||\n                       t.endsWith('Z') ||\n                       t.endsWith('Position') ||\n                       t.endsWith('Rotation') ||\n                       t === 'scale' ||\n                       t === 'transformer'\n            });\n\n            if (transformChanged) {\n                thisBot.updateTool();\n                break;\n            }\n        }\n    }\n}",
        "onAnyBotsRemoved": "@const { botIDs } = that;\n\nif (masks.targetBot) {\n    const targetBotId = masks.targetBot.substring(2);\n\n    if (botIDs.includes(targetBotId)) {\n        thisBot.clearTool();\n    }\n}",
        "onGridClick": "@thisBot.clearTool();",
        "setTool": "@const { targetBot, dimension } = that ?? {};\n\nassert(targetBot, `[${tags.system}] targetBot is a required parameter for setTool.`);\nassert(targetBot.link, `[${tags.system}] targetBot must be a bot parameter for setTool.`);\nassert(dimension, `[${tags.system}] dimension is a required parameter for setTool.`);\n\nif (links.targetBot && links.targetBot === targetBot) {\n    // Tool is already set on this bot.\n    return;\n}\n\nif (tags.debug) {\n    console.log(`[${tags.system}] setTool`, that);\n}\n\nif (links.toolBots) {\n    thisBot.clearTool();\n}\n\nmasks.targetBot = targetBot.link;\nmasks.targetDimension = dimension;\n\nconst COLOR_X = '#d64131';\nconst COLOR_X_HOVER = '#ff6959';\n\nconst COLOR_Y = '#97c607';\nconst COLOR_Y_HOVER = '#b4ed0b';\n\nconst COLOR_Z = '#048ec9';\nconst COLOR_Z_HOVER = '#27b9f7';\n\nconst TRANSLATE_NODE_SIZE = 0.25;\nconst TRANSLATE_NODE_SPACING = 1.25;\nconst TRANSLATE_NODE_SENSITIVITY = 1;\nconst TRANSLATE_GRID_SNAP_SIZE = 1;\n\nconst SCALE_NODE_SIZE = 0.25;\nconst SCALE_NODE_SPACING = 0.75;\nconst SCALE_NODE_SENSITIVITY = 2;\nconst SCALE_GRID_SNAP_SIZE = 1;\n\nconst ROTATE_NODE_SIZE = 0.3;\nconst ROTATE_NODE_SPACING = 1.6;\nconst ROTATE_NODE_SENSITIVITY = 1;\nconst ROTATE_SNAP_DEG = 22.5;\nconst ROTATE_DIAL_RADIUS = 1;\n\nconst BASE_SNAP_AXIS_NODE_MOD = {\n    space: 'tempLocal',\n    isTransformBot: true,\n}\n\nfunction createTranslateNode({\n    localDir,\n    color,\n    hoverColor,\n}) {\n    return create({\n        space: 'tempLocal',\n        form: 'mesh',\n        formSubtype: 'gltf',\n        formAddress: 'https://publicos-link-filesbucket-404655125928.s3.amazonaws.com/ab-1/4ef066b0e719b2438065ef857564376203919546e2a34a469a3f1e89ae2ce1e5.xml',\n        isTransformBot: true,\n        anchorPoint: 'center',\n        localDir,\n        normalColor: color,\n        hoverColor: hoverColor,\n        color,\n        targetBot: targetBot.link,\n        dimension,\n        nodeSpacing: TRANSLATE_NODE_SPACING,\n        gridSnapSize: TRANSLATE_GRID_SNAP_SIZE,\n        sensitivity: TRANSLATE_NODE_SENSITIVITY,\n        [dimension]: true,\n        [dimension + 'X']: 0,\n        [dimension + 'Y']: 0,\n        [dimension + 'Z']: 0,\n        [dimension + 'RotationX']: 0,\n        [dimension + 'RotationY']: 0,\n        [dimension + 'RotationZ']: 0,\n        scale: TRANSLATE_NODE_SIZE,\n        onPointerEnter: `@\n            tags.hovering = true;\n            thisBot.updateColor();\n        `,\n        onPointerExit: `@\n            tags.hovering = false;\n            thisBot.updateColor();\n        `,\n        onDrag: `@\n            // Drag on a CasualOS SnapAxis.\n            os.addDropSnap({\n                origin: tags.dragAxisOrigin,\n                direction: tags.dragAxisDirection,\n                distance: 9999999,\n            });\n\n            tags.dragging = true;\n            tags.dragStartPos = {\n                x: tags[tags.dimension + 'X'],\n                y: tags[tags.dimension + 'Y'],\n                z: tags[tags.dimension + 'Z'],\n            };\n            tags.lastDragPos = {...tags.dragStartPos};\n\n            thisBot.updateColor();\n        `,\n        onDrop: `@\n            tags.dragging = null;\n            tags.dragStartPos = null;\n            tags.lastDragPos = null;\n\n            thisBot.updateColor();\n        `,\n        updateColor: `@\n            if (tags.hovering || tags.dragging) {\n                tags.color = tags.hoverColor;\n            } else {\n                tags.color = tags.normalColor;\n            }\n        `,\n        onDraggingTransform: `@\n            const { dragPosition } = that;\n\n            let delta = math.subtractVectors(dragPosition, tags.lastDragPos);\n            delta = GLEF.math.vector3.multiplyScalar(delta, tags.sensitivity);\n            const shiftKeyState = os.getInputState('keyboard', 'Shift');\n\n            if (shiftKeyState) {\n                // Grid snapping mode.\n                const deltaLength = GLEF.math.vector3.length(delta);\n\n                if (deltaLength >= tags.gridSnapSize) {\n                    // Clamp the delta so that it is in increments of the grid snap size.\n                    const snapLength = Math.round(deltaLength / tags.gridSnapSize) * tags.gridSnapSize;\n                    const snapDelta = GLEF.math.vector3.setLength({...delta}, snapLength);\n                    \n                    let position = {\n                        x: links.targetBot.tags[tags.dimension + 'X'] ?? 0,\n                        y: links.targetBot.tags[tags.dimension + 'Y'] ?? 0,\n                        z: links.targetBot.tags[tags.dimension + 'Z'] ?? 0,\n                    };\n\n                    position.x += snapDelta.x;\n                    position.y += snapDelta.y;\n                    position.z += snapDelta.z;\n\n                    // Snap the targetBot position to the grid\n                    // position.x = Math.round(position.x / tags.gridSnapSize) * tags.gridSnapSize;\n                    // position.y = Math.round(position.y / tags.gridSnapSize) * tags.gridSnapSize;\n                    // position.z = Math.round(position.z / tags.gridSnapSize) * tags.gridSnapSize;\n\n                    links.targetBot.tags[tags.dimension + 'X'] = position.x;\n                    links.targetBot.tags[tags.dimension + 'Y'] = position.y;\n                    links.targetBot.tags[tags.dimension + 'Z'] = position.z;\n\n                    tags.lastDragPos = dragPosition;\n                }\n            } else {\n                // Apply the drag delta to the target bot.\n                let position = {\n                    x: links.targetBot.tags[tags.dimension + 'X'] ?? 0,\n                    y: links.targetBot.tags[tags.dimension + 'Y'] ?? 0,\n                    z: links.targetBot.tags[tags.dimension + 'Z'] ?? 0,\n                };\n\n                position.x += delta.x;\n                position.y += delta.y;\n                position.z += delta.z;\n\n                links.targetBot.tags[tags.dimension + 'X'] = position.x;\n                links.targetBot.tags[tags.dimension + 'Y'] = position.y;\n                links.targetBot.tags[tags.dimension + 'Z'] = position.z;\n\n                tags.lastDragPos = dragPosition;\n            }\n        `,\n        onUpdateBotAction: `@\n            if (tags.dragging && that.action.update.tags) {\n                if (that.action.update.tags[tags.dimension + 'X'] != null ||\n                    that.action.update.tags[tags.dimension + 'Y'] != null ||\n                    that.action.update.tags[tags.dimension + 'Z'] != null\n                ) {\n                    // Reject update_bot events for this bot as we dont actually want to update the bot's position\n                    // but instead update the targetBots position.\n                    action.reject(that.action);\n                    \n                    whisper(thisBot, 'onDraggingTransform', { \n                        dragPosition: { \n                            x: that.action.update.tags[tags.dimension + 'X'], \n                            y: that.action.update.tags[tags.dimension + 'Y'], \n                            z: that.action.update.tags[tags.dimension + 'Z']\n                        }\n                    });\n                }\n            }\n        `,\n        onUpdateTool: `@\n            const matrixWorld = GLEF.math.matrix4.worldMatrixFromBot(links.targetBot, tags.dimension);\n            const decomposedMatrix = GLEF.math.matrix4.decompose(matrixWorld);\n            const bounds = Bounds.fromBots([links.targetBot], tags.dimension);\n\n            let position = { x: 0, y: 0, z: 0 };\n\n            position.x = bounds.center.x;\n            position.y = bounds.center.y;\n            position.z = bounds.center.z;\n\n            let worldDir = GLEF.math.vector3.transformDirection( tags.localDir, matrixWorld );\n            let halfWorldScale = GLEF.math.vector3.divideScalar( {...decomposedMatrix.scale}, 2 );\n            let scaleDir = GLEF.math.vector3.multiply( {...halfWorldScale}, tags.localDir );\n            let scaleLength = GLEF.math.vector3.length( scaleDir ) + tags.nodeSpacing;\n            let worldDirScaled = GLEF.math.vector3.multiplyScalar( {...worldDir}, scaleLength );\n\n            position = math.addVectors(position, worldDirScaled);\n\n            tags.dragAxisOrigin = position;\n            tags.dragAxisDirection = worldDir;\n\n            tags[tags.dimension + 'X'] = position.x;\n            tags[tags.dimension + 'Y'] = position.y;\n            tags[tags.dimension + 'Z'] = position.z;\n\n            const up = { x: 0, y: 0, z: 1 };\n            const quaternion = GLEF.math.quaternion.setFromUnitVectors(up, worldDir);\n            const rotation = GLEF.math.vector3.setFromQuaternion(quaternion);\n\n            tags[tags.dimension + 'RotationX'] = rotation.x;\n            tags[tags.dimension + 'RotationY'] = rotation.y;\n            tags[tags.dimension + 'RotationZ'] = rotation.z;\n        `\n    })\n}\n\nfunction createScaleNode({\n    localDir,\n    color,\n    hoverColor,\n}) {\n    return create({\n        space: 'tempLocal',\n        form: 'mesh',\n        formSubtype: 'gltf',\n        formAddress: 'https://publicos-link-filesbucket-404655125928.s3.amazonaws.com/ab-1/8fbf7e4ae7a8ce03474304e711f14e1434dda94c137484bcbef7e7e55b3c8f99.xml',\n        isTransformBot: true,\n        anchorPoint: 'center',\n        localDir,\n        normalColor: color,\n        hoverColor: hoverColor,\n        color,\n        targetBot: targetBot.link,\n        dimension,\n        nodeSpacing: SCALE_NODE_SPACING,\n        gridSnapSize: SCALE_GRID_SNAP_SIZE,\n        sensitivity: SCALE_NODE_SENSITIVITY,\n        [dimension]: true,\n        [dimension + 'X']: 0,\n        [dimension + 'Y']: 0,\n        [dimension + 'Z']: 0,\n        [dimension + 'RotationX']: 0,\n        [dimension + 'RotationY']: 0,\n        [dimension + 'RotationZ']: 0,\n        scale: SCALE_NODE_SIZE,\n        onPointerEnter: `@\n            tags.hovering = true;\n            thisBot.updateColor();\n        `,\n        onPointerExit: `@\n            tags.hovering = false;\n            thisBot.updateColor();\n        `,\n        onDrag: `@\n            // Drag on a CasualOS SnapAxis.\n            os.addDropSnap({\n                origin: tags.dragAxisOrigin,\n                direction: tags.dragAxisDirection,\n                distance: 9999999,\n            });\n\n            tags.dragging = true;\n            tags.dragStartPos = {\n                x: tags[tags.dimension + 'X'],\n                y: tags[tags.dimension + 'Y'],\n                z: tags[tags.dimension + 'Z'],\n            };\n            tags.lastDragPos = {...tags.dragStartPos};\n\n            thisBot.updateColor();\n        `,\n        onDrop: `@\n            tags.dragging = null;\n            tags.dragStartPos = null;\n            tags.lastDragPos = null;\n\n            thisBot.updateColor();\n        `,\n        updateColor: `@\n            if (tags.hovering || tags.dragging) {\n                tags.color = tags.hoverColor;\n            } else {\n                tags.color = tags.normalColor;\n            }\n        `,\n        onDraggingTransform: `@\n            const { dragPosition } = that;\n\n            const matrixWorld = GLEF.math.matrix4.worldMatrixFromBot(links.targetBot, tags.dimension);\n            const decomposedMatrix = GLEF.math.matrix4.decompose(matrixWorld);\n\n            let delta = math.subtractVectors(dragPosition, tags.lastDragPos);\n            delta = GLEF.math.vector3.multiplyScalar(delta, tags.sensitivity);\n\n            const quaternionInverse = GLEF.math.quaternion.invert({...decomposedMatrix.quaternion});\n            let localDelta = GLEF.math.vector3.applyQuaternion({...delta}, quaternionInverse);\n\n            let scale = {\n                x: links.targetBot.tags['scaleX'] ?? 1,\n                y: links.targetBot.tags['scaleY'] ?? 1,\n                z: links.targetBot.tags['scaleZ'] ?? 1,\n            };\n\n            if (scale.y < 0 && scale.z >= 0 ||\n                scale.z < 0 && scale.y >= 0\n            ) {\n                localDelta.x *= -1;\n            }\n            if (scale.y < 0) {\n                localDelta.y *= -1;\n            }\n            if (scale.z < 0) {\n                localDelta.z *= -1;\n            }\n\n            const shiftKeyState = os.getInputState('keyboard', 'Shift');\n\n            if (shiftKeyState) {\n                // Grid snapping mode.\n                const localDeltaLength = GLEF.math.vector3.length(localDelta);\n\n                if (localDeltaLength >= tags.gridSnapSize) {\n                    // Clamp the delta so that it is in increments of the grid snap size.\n                    const snapLength = Math.round(localDeltaLength / tags.gridSnapSize) * tags.gridSnapSize;\n                    const snapDelta = GLEF.math.vector3.setLength({...delta}, snapLength);\n                    const scaleAmt = GLEF.math.vector3.multiply({...tags.localDir}, snapDelta);\n\n                    scale.x += scaleAmt.x;\n                    scale.y += scaleAmt.y;\n                    scale.z += scaleAmt.z;\n\n                    links.targetBot.tags['scaleX'] = scale.x;\n                    links.targetBot.tags['scaleY'] = scale.y;\n                    links.targetBot.tags['scaleZ'] = scale.z;\n\n                    tags.lastDragPos = dragPosition;\n                }\n            } else {\n                // Apply the drag delta to the target bot.\n                \n                const scaleAmt = GLEF.math.vector3.multiply({...tags.localDir}, localDelta);\n\n                scale.x += scaleAmt.x;\n                scale.y += scaleAmt.y;\n                scale.z += scaleAmt.z;\n\n                links.targetBot.tags['scaleX'] = scale.x;\n                links.targetBot.tags['scaleY'] = scale.y;\n                links.targetBot.tags['scaleZ'] = scale.z;\n\n                tags.lastDragPos = dragPosition;\n            }\n        `,\n        onUpdateBotAction: `@\n            if (tags.dragging && that.action.update.tags) {\n                if (that.action.update.tags[tags.dimension + 'X'] != null ||\n                    that.action.update.tags[tags.dimension + 'Y'] != null ||\n                    that.action.update.tags[tags.dimension + 'Z'] != null\n                ) {\n                    // Reject update_bot events for this bot as we dont actually want to update the bot's position\n                    // but instead update the targetBots position.\n                    action.reject(that.action);\n                    \n                    whisper(thisBot, 'onDraggingTransform', { \n                        dragPosition: { \n                            x: that.action.update.tags[tags.dimension + 'X'], \n                            y: that.action.update.tags[tags.dimension + 'Y'], \n                            z: that.action.update.tags[tags.dimension + 'Z']\n                        }\n                    });\n                }\n            }\n        `,\n        onUpdateTool: `@\n            const matrixWorld = GLEF.math.matrix4.worldMatrixFromBot(links.targetBot, tags.dimension);\n            const decomposedMatrix = GLEF.math.matrix4.decompose(matrixWorld);\n            const bounds = Bounds.fromBots([links.targetBot], tags.dimension);\n\n            let position = { x: 0, y: 0, z: 0 };\n\n            position.x = bounds.center.x;\n            position.y = bounds.center.y;\n            position.z = bounds.center.z;\n\n            let worldDir = GLEF.math.vector3.transformDirection(tags.localDir, matrixWorld);\n            let halfWorldScale = GLEF.math.vector3.divideScalar({...decomposedMatrix.scale}, 2);\n            let scaleDir = GLEF.math.vector3.multiply({...halfWorldScale}, tags.localDir);\n            let scaleLength = GLEF.math.vector3.length(scaleDir) + tags.nodeSpacing;\n            let worldDirScaled = GLEF.math.vector3.multiplyScalar({...worldDir}, scaleLength);\n\n            position = math.addVectors(position, worldDirScaled);\n\n            tags.dragAxisOrigin = position;\n            tags.dragAxisDirection = worldDir;\n\n            tags[tags.dimension + 'X'] = position.x;\n            tags[tags.dimension + 'Y'] = position.y;\n            tags[tags.dimension + 'Z'] = position.z;\n\n            // const up = { x: 0, y: 0, z: 1 };\n            // const quaternion = GLEF.math.quaternion.setFromUnitVectors(up, worldDir);\n            // const rotation = GLEF.math.vector3.setFromQuaternion(quaternion);\n            const rotation = GLEF.math.vector3.setFromQuaternion(decomposedMatrix.quaternion);\n\n            tags[tags.dimension + 'RotationX'] = rotation.x;\n            tags[tags.dimension + 'RotationY'] = rotation.y;\n            tags[tags.dimension + 'RotationZ'] = rotation.z;\n        `\n    });\n}\nfunction createRotateNode({\n    localDir,\n    color,\n    hoverColor,\n}) {\n    return create({\n        space: 'tempLocal',\n        form: 'mesh',\n        formSubtype: 'gltf',\n        formAddress: 'https://publicos-link-filesbucket-404655125928.s3.amazonaws.com/ab-1/a6b55d025ee8e6856df0dd64dd3d6aa5228f08e2efc3783c9890b9ec621bbab6.xml',\n        isTransformBot: true,\n        anchorPoint: 'center',\n        localDir,\n        normalColor: color,\n        hoverColor: hoverColor,\n        color,\n        targetBot: targetBot.link,\n        dimension,\n        nodeSpacing: ROTATE_NODE_SPACING,\n        snapDeg: ROTATE_SNAP_DEG,\n        sensitivity: ROTATE_NODE_SENSITIVITY,\n        dialRadius: ROTATE_DIAL_RADIUS,\n        [dimension]: true,\n        [dimension + 'X']: 0,\n        [dimension + 'Y']: 0,\n        [dimension + 'Z']: 0,\n        [dimension + 'RotationX']: 0,\n        [dimension + 'RotationY']: 0,\n        [dimension + 'RotationZ']: 0,\n        scale: ROTATE_NODE_SIZE,\n        createDebugPoint: `@\n            const { point, color = 'white' } = that;\n            \n            let debugPointBot = create({\n                space: 'tempLocal',\n                rotationDebugPoint: true,\n                anchorPoint: 'center',\n                [tags.dimension]: true,\n                [tags.dimension + 'X']: point.x,\n                [tags.dimension + 'Y']: point.y,\n                [tags.dimension + 'Z']: point.z,\n                pointable: false,\n                draggable: false,\n                form: 'sphere',\n                scale: 0.1,\n                color,\n            })\n\n            return debugPointBot;\n        `, \n        clearDebugPoints: `@\n            destroy(getBots('rotationDebugPoint', true));\n        `,\n        createDial: `@\n            const { position, direction } = that;\n\n            let quaternion = GLEF.math.quaternion.identity();\n            let dialNormal = { x: 0, y: 0, z: 1 };\n            quaternion = GLEF.math.quaternion.setFromUnitVectors(dialNormal, direction);\n\n            let dialRotation = GLEF.math.vector3.setFromQuaternion(quaternion);\n\n            const dialBot = create({\n                space: 'tempLocal',\n                anchorPoint: 'center',\n                form: 'circle',\n                formOpacity: 0.25,\n                pointable: false,\n                dragggable: false,\n                color: tags.color,\n                dimension: tags.dimension,\n                [tags.dimension]: true,\n                [tags.dimension + 'X']: position.x,\n                [tags.dimension + 'Y']: position.y,\n                [tags.dimension + 'Z']: position.z,\n                [tags.dimension + 'RotationX']: dialRotation.x,\n                [tags.dimension + 'RotationY']: dialRotation.y,\n                [tags.dimension + 'RotationZ']: dialRotation.z,\n                scaleX: tags.dialRadius / 0.5,\n                scaleY: tags.dialRadius / 0.5,\n                scaelZ: 0.1,\n            });\n\n            return dialBot;\n        `,\n        onPointerEnter: `@\n            tags.hovering = true;\n            thisBot.updateColor();\n        `,\n        onPointerExit: `@\n            tags.hovering = false;\n            thisBot.updateColor();\n        `,\n        onDrag: `@\n            tags.dragging = true;\n            tags.lastAngle = 0;\n\n            thisBot.updateColor();\n        `,\n        onDrop: `@\n            tags.dragging = null;\n            tags.rotationStartPoint = null;\n            tags.rotationPlaneOrigin = null;\n            tags.lastAngle = null;\n\n            destroy([ links.dialBot ]);\n            thisBot.clearDebugPoints();\n\n            thisBot.updateColor();\n        `,\n        updateColor: `@\n            if (tags.hovering || tags.dragging) {\n                tags.color = tags.hoverColor;\n            } else {\n                tags.color = tags.normalColor;\n            }\n        `,\n        rotationPlaneIntersect: `@\n            const targetMatrixWorld = GLEF.math.matrix4.worldMatrixFromBot(links.targetBot, tags.dimension);\n\n            const nodeMatrixWorld = GLEF.math.matrix4.worldMatrixFromBot(thisBot, tags.dimension);\n            const nodeDecomposedMatrix = GLEF.math.matrix4.decompose(nodeMatrixWorld);\n\n            const pointerPosition = os.getPointerPosition('mouse');\n            const pointerRotation = os.getPointerRotation('mouse');\n            const pointerDirection = math.getForwardDirection(pointerRotation);\n\n            const rotationPlaneDirection = GLEF.math.vector3.transformDirection(tags.localDir, targetMatrixWorld);\n\n            const pointerRay = {\n                origin: pointerPosition,\n                direction: pointerDirection,\n            };\n\n            const rotationPlaneOrigin = nodeDecomposedMatrix.position;\n            const rotationPlane = GLEF.math.plane.fromNormalAndCoplanarPoint( rotationPlaneDirection, rotationPlaneOrigin);\n            const rotationPlaneHit = GLEF.math.plane.intersectRay( rotationPlane, pointerRay );\n\n            return {\n                plane: rotationPlane,\n                planeOrigin: rotationPlaneOrigin,\n                ray: pointerRay,\n                hit: rotationPlaneHit\n            };\n        `,\n        onDraggingTransform: `@\n            const { dragPosition } = that;\n\n            const matrixWorld = GLEF.math.matrix4.worldMatrixFromBot(links.targetBot, tags.dimension);\n            const decomposedMatrix = GLEF.math.matrix4.decompose(matrixWorld);\n            const worldDir = GLEF.math.vector3.transformDirection({...tags.localDir}, matrixWorld);\n\n            if (!tags.rotationStartPoint) {\n                let intersection = thisBot.rotationPlaneIntersect();\n\n                if (intersection.hit) {\n                    // Make sure that the start rotation point is a sufficient distance from the plane origin.\n                    let dir = math.subtractVectors(intersection.hit, intersection.planeOrigin);\n                    let length = math.vectorLength(dir);\n\n                    if (length != 0) {\n                        let ray = {\n                            origin: intersection.planeOrigin,\n                            direction: math.normalizeVector(dir),\n                        };\n\n                        tags.rotationStartPoint = GLEF.math.ray.at(ray, tags.dialRadius);\n                        tags.rotationPlaneOrigin = intersection.planeOrigin;\n                    }\n                }\n            }\n\n            // Only continue if we have a rotation start point.\n            if (!tags.rotationStartPoint) { \n                return;\n            }\n\n            // NOTE: It's kind of a no-no that im destroying and creating these constantly, but in the interest\n            // of wrapping up current development on these transform tools im going to leave it in.\n            // Visually it looks fine its just not very efficient.\n            destroy([ links.dialBot ]);\n            links.dialBot = thisBot.createDial({ \n                position: tags.rotationPlaneOrigin,\n                direction: worldDir,\n            });\n\n            thisBot.clearDebugPoints();\n            let centerDebugPoint = thisBot.createDebugPoint({\n                point: tags.rotationPlaneOrigin,\n                color: 'white',\n            });\n            let startDebugPoint = thisBot.createDebugPoint({\n                point: tags.rotationStartPoint,\n                color: tags.color,\n            });\n            centerDebugPoint.tags.lineTo = [startDebugPoint.id];\n            centerDebugPoint.tags.lineWidth = 3;\n            centerDebugPoint.tags.lineColor = tags.color;\n\n            let intersection = thisBot.rotationPlaneIntersect();\n\n            if (intersection.hit) {\n                let hitDebugPoint = thisBot.createDebugPoint({\n                    point: intersection.hit,\n                    color: tags.color,\n                });\n                centerDebugPoint.tags.lineTo = [...centerDebugPoint.tags.lineTo, hitDebugPoint.id];\n                // centerDebugPoint.tags.lineTo = startDebugPoint.link;\n                // centerDebugPoint.tags.lineWidth = 5;\n                // centerDebugPoint.tags.lineColor = tags.color;\n\n                let v1 = math.subtractVectors(tags.rotationPlaneOrigin, tags.rotationStartPoint);\n                let v2 = math.subtractVectors(tags.rotationPlaneOrigin, intersection.hit);\n                let angle = GLEF.math.vector3.angle(v1, v2);\n\n                let cross = GLEF.math.vector3.crossVectors(v1, v2);\n                let dotWithPlaneNormal = GLEF.math.vector3.dot(cross, intersection.plane.normal);\n\n                // Check the direction of the rotation\n                if (dotWithPlaneNormal< 0) {\n                    angle = -angle;\n                }\n\n                function angularDelta(currentAngle, lastAngle) {\n                    let delta = currentAngle - lastAngle;\n                    // Normalize the delta to the range [-Ï€, Ï€]\n                    while (delta > Math.PI) delta -= 2 * Math.PI;\n                    while (delta <= -Math.PI) delta += 2 * Math.PI;\n                    return delta;\n                }\n\n                const shiftKeyState = os.getInputState('keyboard', 'Shift');\n\n                if (shiftKeyState) {\n                    // Snapping mode.\n                    const snapRad = GLEF.math.utils.degToRad(tags.snapDeg);\n                    angle = snapRad * Math.round(angle / snapRad);\n                }\n\n                let delta = angularDelta(angle, tags.lastAngle);\n\n                tags.lastAngle = angle;\n\n                let quaternion = GLEF.math.quaternion.fromEuler({\n                    x: links.targetBot.tags[tags.dimension + 'RotationX'] ?? 0,\n                    y: links.targetBot.tags[tags.dimension + 'RotationY'] ?? 0,\n                    z: links.targetBot.tags[tags.dimension + 'RotationZ'] ?? 0,\n                });\n\n                let deltaQuaternion = GLEF.math.quaternion.setFromAxisAngle(worldDir, delta);\n                quaternion = GLEF.math.quaternion.multiplyQuaternions(deltaQuaternion, quaternion);\n\n                let rotation = GLEF.math.vector3.setFromQuaternion(quaternion);\n\n                links.targetBot.tags[tags.dimension + 'RotationX'] = rotation.x;\n                links.targetBot.tags[tags.dimension + 'RotationY'] = rotation.y;\n                links.targetBot.tags[tags.dimension + 'RotationZ'] = rotation.z;\n            }\n\n        `,\n        onUpdateBotAction: `@\n            if (tags.dragging && that.action.update.tags) {\n                if (that.action.update.tags[tags.dimension + 'X'] != null ||\n                    that.action.update.tags[tags.dimension + 'Y'] != null ||\n                    that.action.update.tags[tags.dimension + 'Z'] != null\n                ) {\n                    // Reject update_bot events for this bot as we dont actually want to update the bot's position\n                    // but instead update the targetBots position.\n                    action.reject(that.action);\n                    \n                    whisper(thisBot, 'onDraggingTransform', { \n                        dragPosition: { \n                            x: that.action.update.tags[tags.dimension + 'X'], \n                            y: that.action.update.tags[tags.dimension + 'Y'], \n                            z: that.action.update.tags[tags.dimension + 'Z']\n                        }\n                    });\n                }\n            }\n        `,\n        onUpdateTool: `@\n            const matrixWorld = GLEF.math.matrix4.worldMatrixFromBot(links.targetBot, tags.dimension);\n            const decomposedMatrix = GLEF.math.matrix4.decompose(matrixWorld);\n            const bounds = Bounds.fromBots([links.targetBot], tags.dimension);\n\n            let position = { x: 0, y: 0, z: 0 };\n\n            position.x = bounds.center.x;\n            position.y = bounds.center.y;\n            position.z = bounds.center.z;\n\n            let worldDir = GLEF.math.vector3.transformDirection(tags.localDir, matrixWorld);\n            let halfWorldScale = GLEF.math.vector3.divideScalar({...decomposedMatrix.scale}, 2);\n            let scaleDir = GLEF.math.vector3.multiply({...halfWorldScale}, tags.localDir);\n            let scaleLength = GLEF.math.vector3.length(scaleDir) + tags.nodeSpacing;\n            let worldDirScaled = GLEF.math.vector3.multiplyScalar({...worldDir}, scaleLength);\n\n            position = math.addVectors(position, worldDirScaled);\n\n            tags.dragAxisOrigin = position;\n            tags.dragAxisDirection = worldDir;\n\n            tags[tags.dimension + 'X'] = position.x;\n            tags[tags.dimension + 'Y'] = position.y;\n            tags[tags.dimension + 'Z'] = position.z;\n\n            let defaultNormal = { x: 0, y: 0, z: 1 };\n            let quaternion = GLEF.math.quaternion.setFromUnitVectors(defaultNormal, worldDir)\n            let rotation = GLEF.math.vector3.setFromQuaternion(quaternion);\n\n            tags[tags.dimension + 'RotationX'] = rotation.x;\n            tags[tags.dimension + 'RotationY'] = rotation.y;\n            tags[tags.dimension + 'RotationZ'] = rotation.z;\n        `,\n        onDestroy: `@\n            destroy([ links.dialBot ]);\n        `,\n    });\n}\n\n// Create the transform tool bots.\nconst toolBots = [];\n\n// Translate nodes\ntoolBots.push(\n    createTranslateNode({\n        localDir: { x: 1, y: 0, z: 0 },\n        color: COLOR_X,\n        hoverColor: COLOR_X_HOVER,\n    })\n);\n\ntoolBots.push(\n    createTranslateNode({\n        localDir: { x: 0, y: 1, z: 0 },\n        color: COLOR_Y,\n        hoverColor: COLOR_Y_HOVER,\n    })\n);\n\ntoolBots.push(\n    createTranslateNode({\n        localDir: { x: 0, y: 0, z: 1 },\n        color: COLOR_Z,\n        hoverColor: COLOR_Z_HOVER,\n    })\n);\n\n// Scale nodes\ntoolBots.push(\n    createScaleNode({\n        localDir: { x: 1, y: 0, z: 0 },\n        color: COLOR_X,\n        hoverColor: COLOR_X_HOVER,\n    })\n);\n\ntoolBots.push(\n    createScaleNode({\n        localDir: { x: 0, y: 1, z: 0 },\n        color: COLOR_Y,\n        hoverColor: COLOR_Y_HOVER,\n    })\n);\n\ntoolBots.push(\n    createScaleNode({\n        localDir: { x: 0, y: 0, z: 1 },\n        color: COLOR_Z,\n        hoverColor: COLOR_Z_HOVER,\n    })\n);\n\n// Rotate nodes\ntoolBots.push(\n    createRotateNode({\n        localDir: { x: 1, y: 0, z: 0 },\n        color: COLOR_X,\n        hoverColor: COLOR_X_HOVER,\n    })\n);\n\ntoolBots.push(\n    createRotateNode({\n        localDir: { x: 0, y: 1, z: 0 },\n        color: COLOR_Y,\n        hoverColor: COLOR_Y_HOVER,\n    })\n);\n\ntoolBots.push(\n    createRotateNode({\n        localDir: { x: 0, y: 0, z: 1 },\n        color: COLOR_Z,\n        hoverColor: COLOR_Z_HOVER,\n    })\n);\n\nmasks.toolBots = getLink(toolBots);",
        "system": "glef-paper-prototyping.transform",
        "updateTool": "@const targetBot = links.targetBot;\n\nif (!targetBot) {\n    return;\n}\n\nif (!links.toolBots || !links.toolBots.length) {\n    return;\n}\n\nif (tags.debug) {\n    console.log(`[${tags.system}] updateTool`);\n}\n\nwhisper(links.toolBots, 'onUpdateTool', { targetBot });"
      }
    },
    "glef-paper-prototyping.utils.botCorners": {
      "id": "glef-paper-prototyping.utils.botCorners",
      "space": "shared",
      "tags": {
        "initialize": "@function getBotCorners(bot, dimension = configBot.tags.gridPortal) {\n    const worldMatrix = GLEF.math.matrix4.worldMatrixFromBot(bot, dimension);\n    const decomposed = GLEF.math.matrix4.decompose(worldMatrix);\n    \n    let botScale = decomposed.scale;\n    let botPosition = decomposed.position;\n    let botRotation = new Rotation({\n        quaternion: decomposed.quaternion\n    });\n\n    let anchorPointOffset = math.getAnchorPointOffset(bot.tags['anchorPoint'] ?? 'bottom');\n    anchorPointOffset.y *= -1; // Seems to be a bug in CasualOS, anchor point y is flipped?\n\n    const corners = [];\n    corners[0] = new Vector3(botPosition.x, botPosition.y, botPosition.z);\n    corners[0].x -= (botScale.x / 2) - (anchorPointOffset.x * botScale.x);\n    corners[0].y -= (botScale.y / 2) - (anchorPointOffset.y * botScale.y);\n    corners[0].z -= (botScale.z / 2) - (anchorPointOffset.z * botScale.z);\n\n    corners[1] = new Vector3(\n        corners[0].x + botScale.x,\n        corners[0].y,\n        corners[0].z\n    );\n\n    corners[2] = new Vector3(\n        corners[0].x + botScale.x,\n        corners[0].y + botScale.y,\n        corners[0].z\n    );\n\n    corners[3] = new Vector3(\n        corners[0].x,\n        corners[0].y + botScale.y,\n        corners[0].z\n    );\n\n    corners[4] = new Vector3(\n        corners[0].x,\n        corners[0].y,\n        corners[0].z + botScale.z\n    );\n\n    corners[5] = new Vector3(\n        corners[0].x + botScale.x,\n        corners[0].y,\n        corners[0].z + botScale.z\n    );\n\n    corners[6] = new Vector3(\n        corners[0].x + botScale.x,\n        corners[0].y + botScale.y,\n        corners[0].z + botScale.z\n    );\n\n    corners[7] = new Vector3(\n        corners[0].x,\n        corners[0].y + botScale.y,\n        corners[0].z + botScale.z\n    );\n\n    function rotatePoint(point) {\n        let rotatedPoint = point.subtract(botPosition);\n        rotatedPoint = botRotation.rotateVector3(rotatedPoint);\n        rotatedPoint = rotatedPoint.add(botPosition);\n\n        return rotatedPoint;\n    }\n\n    // Rotate all the corners to be aligned with the rotation of the bot.\n    for (let i = 0; i < corners.length; i++) {\n        corners[i] = rotatePoint(corners[i]);\n    }\n    \n    return corners;\n}\n\nglobalThis.getBotCorners = getBotCorners;",
        "onBotAdded": "@thisBot.initialize();",
        "onBotChanged": "@thisBot.initialize();",
        "system": "glef-paper-prototyping.utils.botCorners"
      }
    },
    "glef-paper-prototyping.ui": {
      "id": "glef-paper-prototyping.ui",
      "space": "shared",
      "tags": {
        "App": "@const { useState, useCallback, useEffect } = os.appHooks;\n\nconst Help = thisBot.Help();\nconst SlideControls = thisBot.SlideControls();\n\nconst App = () => {\n    const [showHelp, setShowHelp] = useState(false);\n\n    const onHelpClick = useCallback(() => {\n        setShowHelp(!showHelp);\n    }, [showHelp, setShowHelp]);\n\n    return (\n        <>\n            <style>{tags['style.css']}</style>\n            <div className='glef-tools-app'>\n                <button className='help' onClick={onHelpClick}>?</button>\n                { configBot.tags.slideControl !== false &&\n                    <SlideControls/>\n                }\n                {showHelp && <Help onClose={onHelpClick}/>}\n            </div>\n        </>\n    )\n}\n\nreturn App;\n",
        "Help": "@const { useCallback } = os.appHooks;\n\nconst Help = ({\n    onClose\n}) => {\n    const packageInfo = getBot('system', 'glef-paper-prototyping._packageInfo');\n\n    return (\n        <div className='help'>\n            <div onClick={onClose} className='background'></div>\n            <div className='modal'>\n                <h1 className='header'>GLEF Paper Protoyping Help</h1>\n                <div className='content'>\n                    <h2 className='section-header'>Controls</h2>\n                    <table className='controls'>\n                        <tr className='control'>\n                            <td className='keys'>Double Click</td>\n                            <td className='action'>Edit Label</td>\n                        </tr>\n                        <tr className='control'>\n                            <td className='keys'>Shift + Double Click</td>\n                            <td className='action'>Edit Label (Multi-line)</td>\n                        </tr>\n                        <tr className='control'>\n                            <td className='keys'>Alt/Option + Double Click</td>\n                            <td className='action'>Bot Sheet Portal</td>\n                        </tr>\n                        <tr className='control'>\n                            <td className='keys'>Alt/Option + Drag</td>\n                            <td className='action'>Clone</td>\n                        </tr>\n                        <tr className='control'>\n                            <td className='keys'>Shift + Click</td>\n                            <td className='action'>Multiselect</td>\n                        </tr>\n                        <tr className='control'>\n                            <td className='keys'>Ctrl + Click</td>\n                            <td className='action'>Transform Tool</td>\n                        </tr>\n                        <tr className='control'>\n                            <td className='keys'>Delete</td>\n                            <td className='action'>Delete</td>\n                        </tr>\n                    </table>\n\n                    <h2 className='section-header'>Transform Tool Controls</h2>\n                    <table className='controls'>\n                        <tr className='control'>\n                            <td className='keys'>Drag</td>\n                            <td className='action'>Manipulate</td>\n                        </tr>\n                        <tr className='control'>\n                            <td className='keys'>Shift + Drag</td>\n                            <td className='action'>Snap Manipulate</td>\n                        </tr>\n                    </table>\n                    { packageInfo &&\n                        <div className='version'>\n                            v{packageInfo.raw.version} ({packageInfo.tags.versionDate.toLocaleString(DateTime.DATETIME_FULL)}\n                        </div>\n                    }\n                </div>\n            </div>\n        </div>\n    )\n}\n\nreturn Help;",
        "SlideControls": "@const { useState, useCallback, useEffect } = os.appHooks;\n\nconst SlideControls = () => {\n    const slideController = getBot(b => b.tags.isSlideController === true);\n\n    const [slide, setSlide] = useState(slideController.tags.slide);\n\n    useEffect(() => {\n        // Listen for changes on slide controller bot.\n        const onSlideControllerChanged = (listenerThat) => {\n            if (listenerThat.tags.includes('slide')) {\n                setSlide(slideController.tags.slide);\n            }\n        }\n\n        addListenTagListener(slideController, 'onBotChanged', onSlideControllerChanged);\n\n        return () => {\n            removeListenTagListener(slideController, 'onBotChanged', onSlideControllerChanged);\n        }\n    }, [slideController]);\n\n    const onPrevClick = useCallback(() => {\n        if (slideController.tags.slide > 0) {\n            slideController.tags.slide -= 1;\n        }\n    }, [slideController]);\n\n    const onNextClick = useCallback(() => {\n        slideController.tags.slide += 1;\n    }, [slideController]);\n\n    const onSlideInput = useCallback((e) => {\n        let value = e.currentTarget.value;\n\n        if (typeof value === 'string') {\n            value = Number.parseInt(value);\n        }\n\n        if (Number.isNaN(value)) {\n            value = 0;\n        }\n\n        if (value < 0) {\n            value = 0;\n        }\n\n        slideController.tags.slide = value;\n    }, []);\n\n    return (\n        <div className='slide-controls'>\n            <h1>Slide</h1>\n            <div className='number-controls'>\n                <button className='prev' onClick={onPrevClick}>{'â—„'}</button>\n                <input\n                    id='slide'\n                    type='number'\n                    value={slide}\n                    onInput={onSlideInput}\n                ></input>\n                <button className='next' onClick={onNextClick}>{'â–º'}</button>\n            </div>\n        </div>\n    )\n}\n\nreturn SlideControls;",
        "forceUpdate": "@const App = thisBot.vars.appInstance;\n\nif (App) {\n    os.compileApp(tags.system, <App/>)\n}\n",
        "initialize": "@if (masks.initialized) { \n    return;\n}\n\nmasks.initialized = true;\n\n// Wait for slide controller bot to come online\nlet slideController;\n\nwhile(true) {\n    slideController = getBot(b => b.tags.isSlideController === true);\n\n    if (slideController) {\n        break;\n    } else {\n        await os.sleep(100);\n    }\n}\n\nmasks.slideController = slideController.link;\n\nthisBot.mount();",
        "mount": "@if (!thisBot.vars.appInstance) {\n    thisBot.vars.appInstance = thisBot.App();\n    await os.registerApp(tags.system, thisBot);\n\n    thisBot.forceUpdate();\n}\n",
        "onDestroy": "@thisBot.unmount();",
        "onEggHatch": "@thisBot.initialize();",
        "onInstJoined": "@thisBot.initialize();",
        "style.css": ".glef-tools-app {\n    position: fixed;\n    font-family: 'Roboto';\n}\n\n.glef-tools-app button.help {    \n    position: fixed;\n    border-radius: 50%;\n    background-color: black;\n    color: white;\n    border: none;\n    outline: none;\n    width: 36px;\n    height: 36px;\n    font-size: 1.5em;\n    font-weight: bold;\n    font-family: 'Roboto';\n    user-select: none;\n    cursor: pointer;\n    right: 18px;\n    bottom: 18px;\n}\n\n.glef-tools-app .help .modal {\n    position: fixed;\n    display: flex;\n    width: 80vw;\n    height: 80vh;\n    max-width: 700px;\n    max-height: 600px;\n    background-color: white;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n    border-radius: 12px;\n    flex-direction: column;\n}\n\n.glef-tools-app .help .modal .header {\n    width: 100%;\n    background-color: #4083bb;\n    color: white;\n    font-size: 1.9em;\n    font-weight: 500;\n    margin: 0;\n    padding: 18px;\n    border-radius: 12px 12px 0 0;\n}\n\n.glef-tools-app .help .modal .content {\n    padding: 12px;\n    padding-top: 32px;\n    overflow-y: auto;\n    width: 100%;\n}\n\n.glef-tools-app .help .modal .version {\n    position: fixed;\n    color: #8b8b8b;\n    right: 8px;\n    bottom: 4px;\n}\n\n.glef-tools-app .help .modal .section-header {\n    width: 85%;\n    margin: auto;\n    margin-bottom: 12px;\n}\n\n.glef-tools-app .help .background {\n    position: fixed;\n    width: 100vw;\n    height: 100vh;\n    background-color: rgba(0, 0, 0, 0.441);\n}\n\n.glef-tools-app .help .controls {\n    width: 85%;\n    font-size: 1.05em;\n    border-collapse: collapse;\n    margin: auto;\n    margin-bottom: 32px;\n}\n\n.glef-tools-app .help .controls .control {\n    border-bottom-style: solid;\n    border-bottom-color: #cbcbcb;\n    border-bottom-width: 1px;\n}\n\n.glef-tools-app .help .controls .control td {\n    padding-top: 8px;\n    padding-bottom: 8px;\n}\n\n.glef-tools-app .help .controls .control .keys {\n    font-weight: 500;\n}\n\n.glef-tools-app .help .controls .control .action {\n}\n\n.glef-tools-app .slide-controls {\n    background-color: white;\n    border-radius: 8px;\n    padding: 8px;\n    position: fixed;\n    bottom: 18px;\n    left: 18px;\n}\n\n.glef-tools-app .slide-controls h1 {\n    font-size: 1.3em;\n    margin: 0;\n    margin-bottom: 4px;\n    font-weight: 500;\n}\n\n.glef-tools-app .slide-controls .number-controls {\n    display: flex;\n    flex-direction: row;\n}\n\n.glef-tools-app .slide-controls .number-controls .prev,.next {\n    background-color: white;\n    width: 40px;\n    height: 40px;\n    border-radius: 8px;\n    outline: none;\n    border: none;\n    font-weight: bold;\n    font-size: 1.5em;\n    cursor: pointer;\n    border-style: solid;\n    border-width: 2px;\n    border-color: lightgrey;\n}\n\n.glef-tools-app .slide-controls .number-controls #slide {\n    border-radius: 8px;\n    background-color: white;\n    outline: none;\n    height: 40px;\n    cursor: text;\n    font-size: 1.3em;\n    font-weight: 500;\n    width: 40px;\n    text-align: center;\n    border-style: solid;\n    border-width: 2px;\n    border-color: lightgrey;\n    margin-left: 4px;\n    margin-right: 4px;\n}\n\n/* Chrome, Safari, Edge, Opera */\n.glef-tools-app .slide-controls .number-controls input::-webkit-outer-spin-button,\n.glef-tools-app .slide-controls .number-controls input::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n\n/* Firefox */\n.glef-tools-app .slide-controls .number-controls input[type=number] {\n  -moz-appearance: textfield;\n}\n",
        "system": "glef-paper-prototyping.ui",
        "unmount": "@if (thisBot.vars.appInstance) {\n    delete thisBot.vars.appInstance;\n\n    // Compiling the app with an empty root value is a workaround that allows the\n    // previous components to perform their unmounting code properly.\n    await os.compileApp(tags.system, <></>);\n\n    await os.unregisterApp(tags.system);\n}\n"
      }
    },
    "glef-paper-prototyping.cursors": {
      "id": "glef-paper-prototyping.cursors",
      "space": "shared",
      "tags": {
        "onCreate": "@// Load the rc-collaborativeCursors ab.\nawait Promise.all( shout('onLookupABEggs', { \n    abID: 'rc-collaborativeCursors',\n    autoHatch: true,\n}));",
        "system": "glef-paper-prototyping.cursors"
      }
    },
    "glef-paper-prototyping.utils.listenerProxy": {
      "id": "glef-paper-prototyping.utils.listenerProxy",
      "space": "shared",
      "tags": {
        "listening": "true",
        "onAnyListen": "@if (!thisBot.vars.listeners) {\n    return; // This bot has not initialized yet.\n}\n\nconst { \n    name,\n    that: thatParam,\n    targets\n} = that;\n\nconst entries = thisBot.vars.listeners[name];\n\nif (entries && entries.length) {\n    for (let i = 0; i < entries.length; i++) {\n        const entry = entries[i];\n        \n        let invoke = true;\n\n        if (entry.bot) {\n            // Only invoke listener if the bot is one of the targets.\n            let entryBotId = typeof entry.bot === 'string' ? entry.bot : entry.bot.id;\n            invoke = targets && targets.some(t => t.id === entryBotId);\n        }\n\n        if (invoke) {\n            entry.listener(thatParam);\n        }\n    }\n}",
        "onBotAdded": "@function addListenTagListener (bot, name, listener) {\n    assert(name, `${tags.system} name is required.`);\n    assert(listener && typeof listener === 'function', `${tags.system} listener function is required.`);\n    \n    let entries = thisBot.vars.listeners[name];\n    if (!entries) {\n        entries = [];\n        thisBot.vars.listeners[name] = entries;\n    }\n\n    entries.push({ listener, bot });\n}\n\nfunction removeListenTagListener (bot, name, listener) {\n    let entries = thisBot.vars.listeners[name];\n    if (!entries) {\n        return;\n    }\n\n    for (let i = entries.length - 1; i >= 0; i--) {\n        let entry = entries[i];\n\n        if (entry.listener != listener) {\n            continue;\n        }\n\n        if (bot) {\n            const botId = typeof bot === 'string' ? bot : bot.id;\n            const entryBotId = typeof entry.bot === 'string' ? entry.bot : entry.bot.id;\n            \n            if (botId !== entryBotId) {\n                continue;\n            }\n        }\n\n        entries.splice(i, 1);\n    }\n}\n\nglobalThis.addListenTagListener = addListenTagListener;\nglobalThis.removeListenTagListener = removeListenTagListener;\n\nthisBot.vars.listeners = {};",
        "onDestroy": "@globalThis.addListenTagListener = undefined;\nglobalThis.removeListenTagListener = undefined;",
        "system": "glef-paper-prototyping.utils.listenerProxy"
      }
    },
    "glef-paper-prototyping.selectedBox": {
      "id": "glef-paper-prototyping.selectedBox",
      "space": "shared",
      "tags": {
        "debug": "false",
        "enabled": "true",
        "onAnyBotsChanged": "@if (thisBot.vars.selectedBots && thisBot.vars.selectedBots.length > 0) { \n\n    for (let change of that) {\n        let isSelectedBot = thisBot.vars.selectedBots.some(b => b === change.bot);\n\n        if (isSelectedBot) {\n            let transformChanged = change.tags.some((t) => {\n                return t.endsWith('X') ||\n                       t.endsWith('Y') ||\n                       t.endsWith('Z') ||\n                       t.endsWith('Position') ||\n                       t.endsWith('Rotation') ||\n                       t === 'scale' ||\n                       t === 'transformer'\n            });\n\n            if (transformChanged) {\n                thisBot.update({ selectedBots: thisBot.vars.selectedBots });\n            }\n        }\n    }\n}",
        "onMultiSelectAdded": "@const { addedBot, selectedBots } = that;\n\nthisBot.update({ selectedBots });",
        "onMultiSelectClear": "@thisBot.update();",
        "onMultiSelectRemoved": "@const { removedBotId, selectedBots } = that;\n\nthisBot.update({ selectedBots });",
        "system": "glef-paper-prototyping.selectedBox",
        "update": "@if (!tags.enabled) {\n    return;\n}\nconst { selectedBots = [] } = that ?? {};\n\nthisBot.vars.selectedBots = selectedBots;\n\nif (links.selectionBox) {\n    destroy(links.selectionBox);\n}\n\nif (selectedBots.length > 0) {\n    const dim = configBot.tags.gridPortal;\n    const bounds = Bounds.fromBots(selectedBots, dim);\n    \n    if (tags.debug) {\n        console.log(`[${tags.system}] update selection box`, bounds, selectedBots);\n    }\n\n    const selectionBox = create({\n        space: 'tempLocal',\n        form: 'cube',\n        color: 'transparent',\n        strokeColor: 'white',\n        pointable: false,\n        draggable: false,\n        anchorPoint: 'center',\n        strokeWidth: 2,\n        [dim]: true,\n        [dim + 'X']: bounds.center.x,\n        [dim + 'Y']: bounds.center.y,\n        [dim + 'Z']: bounds.center.z,\n        scaleX: bounds.width,\n        scaleY: bounds.depth,\n        scaleZ: bounds.height,\n    })\n\n    masks.selectionBox = selectionBox.link;\n}"
      }
    },
    "glef-paper-prototyping.multiSelect": {
      "id": "glef-paper-prototyping.multiSelect",
      "space": "shared",
      "tags": {
        "debug": "false",
        "form": "nothing",
        "homeX": 6,
        "homeY": -7,
        "homeZ": 0,
        "onAnyBotClicked": "@const clickedBot = that.bot;\n\nif (clickedBot.tags.ab1ID) {\n    return;\n}\n\nconst shiftKeyState = os.getInputState('keyboard', 'Shift');\n\nif (shiftKeyState) {\n    if ( !thisBot.selectAdd({ bot: clickedBot }) ) {\n        thisBot.selectRemove({ bot: clickedBot });\n    }\n} else {\n    thisBot.selectClear('from multiSelect onAnyBotClicked');\n    thisBot.selectAdd({ bot: clickedBot });\n}",
        "onAnyBotsRemoved": "@const { botIDs } = that;\n\nfor (let botID of botIDs) {\n    const index = thisBot.vars.selectedBots.findIndex(b => b.id === botID);\n\n    if (index >= 0) {\n        thisBot.vars.selectedBots.splice(index, 1);\n\n        if (tags.debug) {\n            console.log(`[${tags.system}] onAnyBotsRemoved removed selected bot ${botID.substring(0,5)}`);     \n        }\n\n        shout('onMultiSelectRemoved', { removedBotId: botID, selectedBots: thisBot.vars.selectedBots });\n    }\n}",
        "onBotAdded": "@globalThis.multiSelect = thisBot;\n\nthisBot.vars.selectedBots = [];",
        "onDestroy": "@globalThis.multiSelect = undefined;",
        "onGridClick": "@thisBot.selectClear('from multiSelect onGridClick');",
        "selectAdd": "@const botToSelect = that.bot;\n\nif (!botToSelect) {\n    return;\n}\n\nconst exists = thisBot.vars.selectedBots.some(b => b === botToSelect);\n\nif (!exists) {\n    thisBot.vars.selectedBots.push(botToSelect);\n\n    if (tags.debug) {\n        console.log(`[${tags.system}] select add bot ${botToSelect.id.substring(0, 5)}`, thisBot.vars.selectedBots);\n    }\n\n    shout('onMultiSelectAdded', { addedBot: botToSelect, selectedBots: thisBot.vars.selectedBots });\n\n    return true;\n} else {\n    return false;\n}",
        "selectClear": "@thisBot.vars.selectedBots = [];\n\nif (tags.debug) {\n    console.log(`[${tags.system}] select clear`, that);\n}\n\nshout('onMultiSelectClear');",
        "selectRemove": "@const botToDeselect = that.bot;\n\nif (!botToDeselect) {\n    return;\n}\n\nconst index = thisBot.vars.selectedBots.findIndex(b => b === botToDeselect);\n\nif (index >= 0) {\n    thisBot.vars.selectedBots.splice(index, 1);\n\n    if (tags.debug) {\n        console.log(`[${tags.system}] select remove bot ${botToDeselect.id.substring(0, 5)}`, thisBot.vars.selectedBots);\n    }\n    \n    shout('onMultiSelectRemoved', { removedBotId: botToDeselect.id, selectedBots: thisBot.vars.selectedBots });\n    \n    return true;\n} else {\n    return false;\n}",
        "system": "glef-paper-prototyping.multiSelect"
      }
    },
    "glef-paper-prototyping.utils.bounds": {
      "id": "glef-paper-prototyping.utils.bounds",
      "space": "shared",
      "tags": {
        "initialize": "@class Bounds {\n    /**\n     * @constructor\n     * @param {{x: number, y: number, z: number}} min\n     * @param {{x: number, y: number, z: number}} max\n     */\n    constructor(min, max) {\n        this.min = min;\n        this.max = max;\n        \n        /**@type {number} */\n        this.width = max.x - min.x;\n\n        /**@type {number} */\n        this.depth = max.y - min.y;\n\n        /**@type {number} */\n        this.height = max.z - min.z;\n\n        /**@type {{x: number, y: number, z: number}} */\n        this.center = { \n            x: (min.x + max.x) / 2,\n            y: (min.y + max.y) / 2,\n            z: (min.z + max.z) / 2\n        }\n    }\n\n    /**\n     * Calculate bounds from a given list of bots in the specified dimension\n     * @param {Bot[]} bots\n     * @param {string} [dimension] Defaults to configBot gridPortal if not set.\n     */\n    static fromBots(bots, dimension = configBot.tags.gridPortal) {\n        let min = {\n            x: Infinity,\n            y: Infinity,\n            z: Infinity\n        };\n\n        let max = {\n            x: -Infinity,\n            y: -Infinity,\n            z: -Infinity\n        };\n\n        for (let b of bots) {\n            const corners = getBotCorners(b, dimension);\n\n            for (let corner of corners) {\n                min.x = Math.min(min.x, corner.x);\n                min.y = Math.min(min.y, corner.y);\n                min.z = Math.min(min.z, corner.z);\n\n                max.x = Math.max(max.x, corner.x);\n                max.y = Math.max(max.y, corner.y);\n                max.z = Math.max(max.z, corner.z);\n            }\n        }\n\n        return new Bounds(min, max);\n    }\n}\n\nglobalThis.Bounds = Bounds;\n\n\n",
        "onBotAdded": "@thisBot.initialize();",
        "onBotChanged": "@whisper(thisBot, 'initialize');",
        "onDestroy": "@globalThis.Bounds = undefined;",
        "system": "glef-paper-prototyping.utils.bounds"
      }
    },
    "glef-paper-prototyping.slides": {
      "id": "glef-paper-prototyping.slides",
      "space": "shared",
      "tags": {
        "initialize": "@if (masks.initialized) {\n    return;\n}\n\nmasks.initialized = true;\n\nlet slideController = getBot(b => b.tags.isSlideController === true);\n\nif (!slideController) {\n    // Create the slide contorller bot.\n    slideController = create({\n        space: 'shared',\n        isSlideController: true,\n        slide: 0,\n        onBotChanged: `@\n            if (configBot.tags.slideControl !== false && \n                that.tags.includes('slide') &&\n                typeof tags.slide === 'number'\n            ) {\n                configBot.tags.gridPortal = 'slide_' + tags.slide;\n            }\n        `\n    });\n}\n\nmasks.slideController = slideController.link;\n\nif (configBot.tags.slideControl !== false) {\n    configBot.tags.gridPortal = `slide_${slideController.tags.slide}`;\n}",
        "onEggHatch": "@thisBot.initialize();",
        "onInstJoined": "@thisBot.initialize();",
        "system": "glef-paper-prototyping.slides"
      }
    },
    "glef-paper-prototyping.labeler": {
      "id": "glef-paper-prototyping.labeler",
      "space": "shared",
      "tags": {
        "onAnyBotDoubleClicked": "@const clickBot = that.bot;\n\nconst optionKeyState = os.getInputState('keyboard', 'Alt');\n\nif (!optionKeyState) {\n    const shiftKeyState = os.getInputState('keyboard', 'Shift');\n\n    if (shiftKeyState) {\n        // Open a the tag portal for the lable that provides better multi-line support.\n        configBot.tags.tagPortal = `${clickBot.id}.label`;\n        tagPortalBot.tags.tagPortalShowButton = true;\n        tagPortalBot.tags.tagPortalButtonIcon = 'close'\n        tagPortalBot.tags.tagPortalAnchorPoint = 'right';\n        tagPortalBot.tags.onClick = `@\n            configBot.tags.tagPortal = null;\n            tagPortalBot.tags.tagPortalShowButton = false;\n            tagPortalBot.tags.tagPortalButtonIcon = null;\n            tagPortalBot.tags.tagPortalAnchorPoint = null;\n            tagPortalBot.tags.onClick = null;\n        `\n    } else {\n        os.showInputForTag(clickBot, 'label');\n    }\n}",
        "system": "glef-paper-prototyping.labeler"
      }
    }
  }
}