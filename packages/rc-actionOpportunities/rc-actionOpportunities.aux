{
  "version": 1,
  "state": {
    "rc-actionOpportunities.manager": {
      "id": "rc-actionOpportunities.manager",
      "space": "shared",
      "tags": {
        "botHasActionOpportunities": "@const { bot } = that;\n\nreturn bot.tags.actionOpportunities && \n       Array.isArray(bot.tags.actionOpportunities) && \n       bot.tags.actionOpportunities.length > 0;",
        "buttonColor": "white",
        "buttonHoverColor": "#a5e3ef",
        "buttonLabelColor": "black",
        "buttonStyle": "ðŸ§¬{\n    \"border-radius\": \"4px\",\n    \"margin-top\": \"4px\"\n}",
        "clearActionOpportunitiesMenu": "@if (masks.curActionMenuDim) {\n    if (tags.debug) {\n        console.log(`[actionOpportunities] clear ${masks.curActionMenuDim} menu dimension`);\n    }\n\n    // Destroy bots in the previous action menu dimension.\n    destroy(getBots(b => b.tags[masks.curActionMenuDim] != null));\n\n    if (configBot.tags.menuPortal === masks.curActionMenuDim) {\n        if (masks.prevMenuPortal) {\n            configBot.tags.menuPortal = masks.prevMenuPortal;\n        }\n    }\n\n    masks.prevMenuPortal = null;\n    masks.curActionMenuDim = null;\n    masks.curActionBotId = null;\n}",
        "createActionOpportunitiesMenu": "@const { bot, force = false } = that;\n\nif (masks.curActionBotId === bot.id && !force) {\n    // Already showing action menu for this bot.\n    return;\n}\n\n/**\n * Converts a string into a human-readable format by capitalizing the first letter of each word\n * and adding spaces between words. Handles various string formats including camelCase,\n * hyphen-separated, underscore-separated, and space-separated.\n * \n * Sourced from ChatGPT: https://chat.openai.com/share/8293dcf1-c39d-4e4b-8fd4-c2b4f06337fc\n *\n * @param {string} str - The string to be converted into a human-readable format.\n * @returns {string} The converted human-readable string.\n *\n * @example\n * toHumanReadable('changeMode');   // Outputs: Change Mode\n * toHumanReadable('change-mode');  // Outputs: Change Mode\n */\nfunction toHumanReadable(str) {\n  // Replace hyphens and underscores with spaces\n  str = str.replace(/[-_]/g, ' ');\n\n  // Insert a space before capital letters that are preceded by lowercase letters\n  str = str.replace(/([a-z])([A-Z])/g, '$1 $2');\n\n  // Split the string into words\n  let words = str.split(' ');\n\n  // Capitalize the first letter of each word and join them with a space\n  return words.map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join(' ');\n}\n\nif (thisBot.botHasActionOpportunities({ bot })) {\n    if (masks.curActionMenuDim) {\n        thisBot.clearActionOpportunitiesMenu();\n    }\n\n    if (configBot.tags.menuPortal != null) {\n        // Store reference to previous menu portal so that we can restore it on clear.\n        masks.prevMenuPortal = configBot.tags.menuPortal;\n    }\n\n    const menuDim = bot.id + '_actionOpportunities';\n    configBot.tags.menuPortal = menuDim;\n    masks.curActionMenuDim = menuDim;\n    masks.curActionBotId = bot.id;\n        \n    if (tags.debug) {\n        console.log(`[actionOpportunities] create ${masks.curActionMenuDim} menu dimension`);\n    }\n\n    for (let i = 0; i < bot.tags.actionOpportunities.length; i++) {\n        let action = bot.tags.actionOpportunities[i];\n\n        // Button properties.\n        let label;\n        let clickShout;\n        let visible;\n        let locked;\n        let icon;\n        let color;\n        let hoverColor;\n\n        // Action opportunities can come in a couple of flavors.\n        // They can be either a very simple array of strings, OR they can be an array of objects that provides more flexibility.\n        if (typeof action === 'string') {\n            // Simple string array format.\n            label = toHumanReadable(action);    \n            clickShout = action;\n            visible = true;\n            locked = false;\n            icon = null;\n            color = tags.buttonColor;\n            hoverColor = tags.buttonHoverColor;\n            labelColor = tags.buttonLabelColor;\n        } else {\n            // Advanced object array format.\n            if (action.name) {\n                label = action.name;\n            } else {\n                label = toHumanReadable(action.clickShout);\n            }\n\n            clickShout = action.clickShout;\n\n            if (action.isVisibleShout) {\n                let results = shout(action.isVisibleShout, { actionBot: bot });\n\n                if (!results || results.length === 0) {\n                    // Default to visible if the visible shout returns nothing.\n                    visible = true;\n                } else {\n                    // Visible if every shout result returns nothing (null/undefined) and/or true.\n                    visible = results.every(r => r == true || r == null);\n                }\n            } else {\n                // If no visible shout is provided then default to being visible.\n                visible = true;\n            }\n\n            if (action.isLockedShout) {\n                let results = shout(action.isLockedShout, { actionBot: bot});\n\n                if (!results || results.length === 0) {\n                    // Default to unlocked if the locked shout returns nothing.\n                    locked = false;\n                } else {\n                    // Locked if any shout result returns true.\n                    locked = results.some(r => r == true);\n                }\n            } else {\n                // If no locked shout is provided then default to being unlocked.\n                locked = false;\n            }\n            \n            if (action.icon) {\n                icon = action.icon;\n            } else {\n                icon = null;\n            }\n\n            if (action.color) {\n                color = action.color;\n            } else {\n                color = tags.buttonColor;\n            }\n\n            if (action.hoverColor) {\n                hoverColor = action.hoverColor;\n            } else {\n                hoverColor = tags.buttonHoverColor;\n            }\n\n            if (action.labelColor) {\n                labelColor = action.labelColor;\n            } else {\n                labelColor = tags.buttonLabelColor;\n            }\n        }\n        \n        if (!label ||\n            !clickShout ||\n            !visible\n        ) {\n            // One or more Required parameters for action are missing.\n            // Do not create a button for this action.\n            continue;\n        }\n\n        if (locked) {\n            // Being locked alters some button properties.\n            icon = 'lock';\n            color = 'rgba(128, 128, 128, 0.75)';\n            labelColor = 'black';\n        }\n        \n        create({\n            space: 'tempLocal',\n            isActionOpportunityMenuBot: true,\n            [menuDim]: true,\n            [menuDim + 'SortOrder']: i,\n            buttonColor: color,\n            buttonHoverColor: hoverColor,\n            color,\n            labelColor,\n            labelAlignment: 'left',\n            menuItemStyle: tags.buttonStyle,\n            formAddress: icon,\n            actionBot: bot.link,\n            clickShout,\n            label,\n            locked,\n            onBotAdded: `@\n                if (tags.locked) {\n                    tags.onClick = null;\n                }\n            `,\n            onPointerEnter: `@\n                if (!tags.locked) {\n                    tags.color = tags.buttonHoverColor;\n                }\n            `,\n            onPointerExit: `@\n                tags.color = tags.buttonColor;\n            `,\n            onClick: `@\n                if (!tags.locked) {\n                    shout(tags.clickShout, { actionBot: links.actionBot });\n                }\n            `,\n        });\n    }\n}",
        "debug": "false",
        "hoverCursor": "help",
        "hoverToActivate": "true",
        "onActionOpportunitiesInitialize": "@ActionOpportunities.manager = thisBot;",
        "onAnyBotClicked": "@const { bot } = that;\n\nif (masks.curActionMenuDim) {\n    if (masks.curActionBotId !== bot.id) {\n\n        if (masks.prevRefreshBotId === masks.curActionBotId &&\n            Date.now() < masks.prevRefreshTimeout\n        ) {\n            // Special case: Don't clear the action opportunities menu. This bot just had refresh called on it wait for the timeout to pass before being\n            // able to clear it like so.\n        } else if (bot.tags.isActionOpportunityMenuBot && bot.tags.locked) {\n            // Don't close menu when clicking on a locked menu option.\n        } else {\n            // Automatically close the action menu when clicking on any other bot.\n            thisBot.clearActionOpportunitiesMenu();\n        }\n\n    }\n}\n\n// Support clicking to enable action opportunities as well.\n// This is especially important on touch devices where we dont have hover states.\nif (thisBot.botHasActionOpportunities({ bot })) {\n    thisBot.createActionOpportunitiesMenu({ bot });\n}",
        "onAnyBotPointerEnter": "@const { bot, dimension } = that;\n\nif (bot.tags[masks.curActionMenuDim] != null) {\n    // Ignore pointer enter events for the current menu bots.\n    return;\n}\n\nif (thisBot.botHasActionOpportunities({ bot })) {\n    gridPortalBot.masks.portalCursor = tags.hoverCursor;\n\n    if (tags.hoverToActivate) {\n        thisBot.createActionOpportunitiesMenu({ bot });\n    }\n}",
        "onAnyBotPointerExit": "@const { bot, dimension } = that;\n\nif (thisBot.botHasActionOpportunities({ bot })) {\n    gridPortalBot.masks.portalCursor = null;\n}\n",
        "onDestroy": "@ActionOpportunities.manager = undefined;",
        "onGridClick": "@thisBot.clearActionOpportunitiesMenu();",
        "refreshActionOpportunitiesMenu": "@if (masks.curActionBotId) {\n    let actionBot = getBot('id', masks.curActionBotId);\n\n    if (actionBot) {\n        masks.prevRefreshBotId = actionBot.id;\n        masks.prevRefreshTimeout = Date.now() + 100;\n\n        if (tags.debug) {\n            console.log(`[actionOpportunities] refresh ${masks.curActionMenuDim} menu`);\n        }\n\n        thisBot.createActionOpportunitiesMenu({ bot: actionBot, force: true });\n    }\n}",
        "system": "rc-actionOpportunities.manager"
      }
    },
    "rc-actionOpportunities._packageInfo": {
      "id": "rc-actionOpportunities._packageInfo",
      "space": "shared",
      "tags": {
        "system": "rc-actionOpportunities._packageInfo",
        "version": "0.4",
        "versionDate": "ðŸ“…2023-08-25T14:29:35.433-04:00 local"
      }
    },
    "rc-actionOpportunities.init": {
      "id": "rc-actionOpportunities.init",
      "space": "shared",
      "tags": {
        "initialize": "@if (masks.initialized) { \n    return;\n}\n\nmasks.initialized = true;\n\nglobalThis.ActionOpportunities = {};\n\nshout('onActionOpportunitiesInitialize');\nshout('onActionOpportunitiesReady');\nshout('onActionOpportunitiesStart');",
        "onBotAdded": "@// Handle's the case where the ab is added to an inst with users already \n// in it and the user gets neither onEggHatch or onInstJoined.\nawait os.sleep(2000);\nthisBot.initialize();",
        "onEggHatch": "@thisBot.initialize();",
        "onInstJoined": "@thisBot.initialize();",
        "system": "rc-actionOpportunities.init"
      }
    }
  }
}