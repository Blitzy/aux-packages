{
  "version": 1,
  "state": {
    "rc-collaborativeCursors.receiver": {
      "id": "rc-collaborativeCursors.receiver",
      "space": "shared",
      "tags": {
        "createCursor": "@const cursorBot = create({\n    space: 'tempLocal',\n    form: 'nothing',\n    anchorPoint: 'center',\n    isCollaborativeCursor: true,\n    orientationMode: 'billboard',\n    pointable: false,\n    draggable: false,\n    debug: tags.debug,\n    receiver: thisBot.link,\n    onCollaborativeCursorCreate: `@\n        const { remoteId, data } = that;\n\n        if (links.receiver.tags.debug) {\n            console.log('cursor ' + thisBot.id.substring(0,5) + ' created');\n        }\n        \n        // These properties are how we will identify this cursor in future updates.\n        // Updates must match our remoteId, pointer, and portal.\n        // NOTE: The exception is dimension - because if needed this cursor can change its dimension to wherever it needs to be\n        // as long as the portal is the same.\n        tags.remoteId = remoteId;\n        tags.pointer = data.pointer;\n        tags.portal = data.portal;\n\n        thisBot.updatePosition({\n            dimension: data.dimension,\n            position: data.position\n        });\n        \n        thisBot.updateColor({ color: data.color });\n        thisBot.updateName({ name: data.name });\n\n        thisBot.resetTimeout();\n    `,\n    onAnyCollaborativeCursorUpdate: `@\n        if (tags.remoteId !== that.remoteId ||\n            tags.pointer !== that.data.pointer ||\n            tags.portal !== that.data.portal\n        ) {\n            // This update is not for this cursor.\n            return false;\n        }\n\n        if (links.receiver.tags.debug) {\n            console.log('cursor ' + thisBot.id.substring(0,5) + ' update');\n        }\n        \n        const { data } = that;\n\n        thisBot.updatePosition({\n            dimension: data.dimension,\n            position: data.position,\n        });\n\n        thisBot.updateColor({ color: data.color });\n        thisBot.updateName({ name: data.name });\n\n        thisBot.resetTimeout();\n\n        return true;\n    `,\n    onCollaborativeCursorsCameraChanged: `@\n        thisBot.updateScale();\n    `,\n    onBotChanged: `@\n        if (that.tags.some((t) => {\n            return t.endsWith('X') || t.endsWith('Y') || t.endsWith('Z');\n        })) {\n            // Cursor position changed.\n            thisBot.updateScale();\n        }\n    `,\n    updatePosition: `@\n        const { dimension, position } = that;\n        \n        if (tags.dimension !== dimension) {\n            // Dimension has changed. \n            \n            if (tags.dimension) {\n                // Remove the cursor from the previous dimension.\n                tags[ tags.dimension ] = null;\n                links.shapeBot.tags[ tags.dimension ] = null;\n                links.nameBot.tags[ tags.dimension ] = null;\n\n                // Remove position tags for previous dimension as well.\n                tags[ tags.dimension + 'X' ] = null;\n                tags[ tags.dimension + 'Y' ] = null;\n                tags[ tags.dimension + 'Z' ] = null;\n            }\n                \n            // Set cursor to the current dimension.\n            tags.dimension = dimension;\n\n            tags[ dimension ] = true;\n            links.shapeBot.tags[ dimension ] = true;\n            links.nameBot.tags[ dimension ] = true;\n        }\n\n        const dimXTag = dimension + 'X';\n        const dimYTag = dimension + 'Y';\n        const dimZTag = dimension + 'Z';\n        \n        const prevX = tags[ dimXTag ];\n        const prevY = tags[ dimYTag ];\n        const prevZ = tags[ dimZTag ];\n\n        clearAnimations(thisBot);\n\n        if (prevX == null && prevY == null && prevZ == null) {\n            // This is the first time setting the position of this cursor in this dimension.\n            // Snap cursor to the position.\n            tags[ dimXTag ] = position.x;\n            tags[ dimYTag ] = position.y;\n            tags[ dimZTag ] = position.z;\n        } else {\n            if (links.receiver.tags.cursorSmooth) {\n                // Cursor is already positioned in dimension, smoothly animate to the updated position.\n                animateTag(thisBot, {\n                    fromValue: {\n                        [dimXTag]: prevX,\n                        [dimYTag]: prevY,\n                        [dimZTag]: prevZ,\n                    },\n                    toValue: {\n                        [dimXTag]: position.x,\n                        [dimYTag]: position.y,\n                        [dimZTag]: position.z,\n                    },\n                    duration: (CollaborativeCursors.emitter.tags.intervalMS + 50) / 1000,\n                }).catch(() => {\n                    // Animation canceled, do nothing.\n                });\n            } else {\n                tags[ dimXTag ] = position.x;\n                tags[ dimYTag ] = position.y;\n                tags[ dimZTag ] = position.z;\n            }\n        }\n    `,\n    updateColor: `@\n        const { color } = that;\n\n        if (links.shapeBot.tags.color !== color) {\n            links.shapeBot.tags.color = color;\n        }\n\n        if (links.nameBot.tags.color !== color) {\n            links.nameBot.tags.color = color;\n        }\n    `,\n    updateName: `@\n        const { name } = that;\n\n        if (links.nameBot.tags.label !== name) {\n            links.nameBot.tags.label = name;\n        }\n    `,\n    updateScale: `@\n        const constantScale = links.receiver.tags.cursorConstantScale;\n        const inXR = links.receiver.tags.inXR;\n        \n        if (inXR ||\n            gridPortalBot.tags.portalCameraType === 'perspective'\n        ) {\n            // perspective scale\n            const cameraPosition = {\n                x: gridPortalBot.tags.cameraPositionX ?? 0,\n                y: gridPortalBot.tags.cameraPositionY ?? 0,\n                z: gridPortalBot.tags.cameraPositionZ ?? 0,\n            };\n\n            // TODO: This will break when the cursor is in a dimension being displayed by a portal bot.\n            // The fix is to calculate the world position of the bot, but for now im going to skip.\n            const cursorPosition = { \n                x: tags[ tags.dimension + 'X' ] ?? 0,\n                y: tags[ tags.dimension + 'Y' ] ?? 0,\n                z: tags[ tags.dimension + 'Z' ] ?? 0,\n            };\n\n            const distance = math.vectorLength( math.subtractVectors(cameraPosition, cursorPosition) );\n            const initialDistance = links.receiver.tags.cursorInitialDistance;\n\n            tags.scale = (distance / initialDistance) * constantScale;\n        } else {\n            // orthographic scale\n            tags.scale = constantScale / gridPortalBot.tags.cameraZoom;\n        }\n    `,\n    clearTimeout: `@\n        if (tags.timeoutId) {\n            clearTimeout(tags.timeoutId);\n            tags.timeoutId = null;\n        }\n    `,\n    resetTimeout: `@\n        thisBot.clearTimeout();\n\n        tags.timeoutId = setTimeout(() => {\n            if (tags.debug) {\n                console.log('cursor ' + thisBot.id.substring(0,5) + ' has timed out');\n            }\n\n            destroy(thisBot);\n        }, links.receiver.tags.cursorTimeoutMS);\n    `,\n    onDestroy: `@\n        thisBot.clearTimeout();\n\n        destroy([\n            links.shapeBot,\n            links.nameBot,\n        ]);\n    `,\n})\n\nconst shapeBot = create({\n    space: 'tempLocal',\n    form: 'mesh',\n    formSubtype: 'gltf',\n    formAddress: tags.cursorModel,\n    formDepthTest: false,\n    formDepthWrite: false,\n    formRenderOrder: 99999,\n    anchorPoint: [-0.45, 0.5, 0],\n    isCollaborativeCursor: true,\n    rotationXOffset: 0,\n    rotationYOffset: 0,\n    rotationZOffset: 0,\n    pointable: false,\n    draggable: false,\n    scale: 0.5,\n    transformer: cursorBot.tags.id,\n});\n\nconst nameBot = create({\n    space: 'tempLocal',\n    form: 'cube',\n    formDepthTest: false,\n    formDepthWrite: false,\n    formRenderOrder: 99999,\n    anchorPoint: [-0.625, 1.5, 0],\n    isCollaborativeCursor: true,\n    pointable: false,\n    draggable: false,\n    scaleX: 3,\n    scaleY: 0.5,\n    scaleZ: 0.1,\n    labelPadding: 0.1,\n    transformer: cursorBot.tags.id,\n});\n\n// Give cursor bot links to all of the child bots it needs to communicate with.\ncursorBot.links.shapeBot = shapeBot.link;\ncursorBot.links.nameBot = nameBot.link;\n\nreturn cursorBot;",
        "cursorConstantScale": "8",
        "cursorInitialDistance": "225",
        "cursorModel": "data:text/xml;base64,Z2xURgIAAABwCAAAjAQAAEpTT057ImFzc2V0Ijp7ImdlbmVyYXRvciI6Iktocm9ub3MgZ2xURiBCbGVuZGVyIEkvTyB2My40LjUwIiwidmVyc2lvbiI6IjIuMCJ9LCJleHRlbnNpb25zVXNlZCI6WyJLSFJfbWF0ZXJpYWxzX3VubGl0Il0sInNjZW5lIjowLCJzY2VuZXMiOlt7Im5hbWUiOiJTY2VuZSIsIm5vZGVzIjpbMF19XSwibm9kZXMiOlt7Im1lc2giOjAsIm5hbWUiOiJDdWJlIn1dLCJtYXRlcmlhbHMiOlt7ImV4dGVuc2lvbnMiOnsiS0hSX21hdGVyaWFsc191bmxpdCI6e319LCJuYW1lIjoiTWF0ZXJpYWwiLCJwYnJNZXRhbGxpY1JvdWdobmVzcyI6eyJtZXRhbGxpY0ZhY3RvciI6MCwicm91Z2huZXNzRmFjdG9yIjowLjl9fV0sIm1lc2hlcyI6W3sibmFtZSI6IkN1YmUiLCJwcmltaXRpdmVzIjpbeyJhdHRyaWJ1dGVzIjp7IlBPU0lUSU9OIjowLCJURVhDT09SRF8wIjoxLCJOT1JNQUwiOjJ9LCJpbmRpY2VzIjozLCJtYXRlcmlhbCI6MH1dfV0sImFjY2Vzc29ycyI6W3siYnVmZmVyVmlldyI6MCwiY29tcG9uZW50VHlwZSI6NTEyNiwiY291bnQiOjI4LCJtYXgiOlsxLjQ5MjU2MTM0MDMzMjAzMTIsMC4wNzU1NDI1MzE5MDc1NTg0NCwxLjYwNTcxMDE0ODgxMTM0MDNdLCJtaW4iOlsxLjI5MDQ1MjIwMDkxOTM4OTdlLTA1LC0wLjA4MTM4NzA0Mjk5OTI2NzU4LDcuMTE1MzA0NDcwMDYyMjU2ZS0wNl0sInR5cGUiOiJWRUMzIn0seyJidWZmZXJWaWV3IjoxLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MjgsInR5cGUiOiJWRUMyIn0seyJidWZmZXJWaWV3IjoyLCJjb21wb25lbnRUeXBlIjo1MTI2LCJjb3VudCI6MjgsInR5cGUiOiJWRUMzIn0seyJidWZmZXJWaWV3IjozLCJjb21wb25lbnRUeXBlIjo1MTIzLCJjb3VudCI6MzYsInR5cGUiOiJTQ0FMQVIifV0sImJ1ZmZlclZpZXdzIjpbeyJidWZmZXIiOjAsImJ5dGVMZW5ndGgiOjMzNiwiYnl0ZU9mZnNldCI6MCwidGFyZ2V0IjozNDk2Mn0seyJidWZmZXIiOjAsImJ5dGVMZW5ndGgiOjIyNCwiYnl0ZU9mZnNldCI6MzM2LCJ0YXJnZXQiOjM0OTYyfSx7ImJ1ZmZlciI6MCwiYnl0ZUxlbmd0aCI6MzM2LCJieXRlT2Zmc2V0Ijo1NjAsInRhcmdldCI6MzQ5NjJ9LHsiYnVmZmVyIjowLCJieXRlTGVuZ3RoIjo3MiwiYnl0ZU9mZnNldCI6ODk2LCJ0YXJnZXQiOjM0OTYzfV0sImJ1ZmZlcnMiOlt7ImJ5dGVMZW5ndGgiOjk2OH1dfSDIAwAAQklOAEAMvz8Itpo9fNEiP0AMvz8Itpo9fNEiP0AMvz8Itpo9fNEiP1whHz8Atpo929JOP1whHz8Atpo929JOP1whHz8Atpo929JOP1whHz8Atpo929JOP4CAWDcLtpo9AADvNoCAWDcLtpo9AADvNoCAWDcLtpo9AADvNoCAWDcLtpo9AADvNnfJbT4Atpo96YfNP3fJbT4Atpo96YfNP3fJbT4Atpo96YfNP0AMvz84rqa9fNEiP0AMvz84rqa9fNEiP0AMvz84rqa9fNEiP1whHz84rqa929JOP1whHz84rqa929JOP1whHz84rqa929JOP1whHz84rqa929JOP4CAWDcvrqa9AMDuNoCAWDcvrqa9AMDuNoCAWDcvrqa9AMDuNoCAWDcvrqa9AMDuNnfJbT5Arqa96YfNP3fJbT5Arqa96YfNP3fJbT5Arqa96YfNPwAAID8AAIA+AAAgPwAAgD4AACA/AACAPgAAwD4AAIA+AADAPgAAgD4AAMA+AACAPgAAwD4AAIA+AAAgPwAAAAAAACA/AAAAAAAAID8AAAAAAAAgPwAAAAAAAMA+AAAAAAAAwD4AAAAAAADAPgAAAAAAACA/AACAPgAAID8AAIA+AAAgPwAAgD4AAMA+AACAPgAAwD4AAIA+AADAPgAAgD4AAMA+AACAPgAAID8AAAAAAAAgPwAAAAAAACA/AAAAAAAAID8AAAAAAADAPgAAAAAAAMA+AAAAAAAAwD4AAAAA8y8KswAAgD/3pQ80qEZGPgAAAAC5J3s/wrXIPh1fezSEgmu/8y8KswAAgD/3pQ80EmnFM///fz/eHCkzqEZGPgAAAAC5J3s/ag9mPwAAAADIkuA+Ul19vwAAAABrjhI+8y8KswAAgD/3pQ80EmnFM///fz/eHCkzwrXIPh1fezSEgmu/Ul19vwAAAABrjhI+EmnFM///fz/eHCkzag9mPwAAAADIkuA+EGlFsgAAgL8evpqzqEZGPgAAAAC5J3s/wrXIPh1fezSEgmu/qO0ds///f79iWaezEGlFsgAAgL8evpqzqEZGPgAAAAC5J3s/ag9mPwAAAADIkuA+Ul19vwAAAABrjhI+qO0ds///f79iWaezEGlFsgAAgL8evpqzwrXIPh1fezSEgmu/Ul19vwAAAABrjhI+qO0ds///f79iWaezag9mPwAAAADIkuA+BAAJAAwACAADAAAAEQAaABYAFwAOABIAAgAQABgAAgAYAAoABwAVABkABwAZAAsADQAbABQADQAUAAYABQATAA8ABQAPAAEA",
        "cursorSmooth": "true",
        "cursorTimeoutMS": "5000",
        "debug": "false",
        "enabled": "true",
        "onCollaborativeCursorsInitialize": "@CollaborativeCursors.receiver = thisBot;",
        "onCollaborativeCursorsReady": "@masks.ready = true;",
        "onDestroy": "@CollaborativeCursors.receiver = undefined;",
        "onEnterAR": "@masks.inXR = true;",
        "onEnterVR": "@masks.inXR = true;",
        "onExitAR": "@masks.inXR = false;",
        "onExitVR": "@masks.inXR = false;",
        "onRemoteData": "@if (!tags.enabled) {\n    return;\n}\n\nif (!tags.ready) {\n    return;\n}\n\nif (that.name === 'collaborative-cursor-remotedata') {\n    if (tags.debug) {\n        console.log(`${tags.system} remote data`, that);\n    }\n    \n    const remoteId = that.remoteId;\n    const cursorData = that.that;\n\n    for (let i = 0; i < cursorData.length; i++) {\n        // Shout the data update.\n        const results = shout('onAnyCollaborativeCursorUpdate', { remoteId, data: cursorData[i] });\n        const updated = results.some(r => r === true);\n\n        if (!updated) {\n            if (tags.debug) {\n                console.log(`${tags.system} create new cursor`);\n            }\n            \n            // Create new cursor.\n            const newCursor = thisBot.createCursor();\n            whisper(newCursor, 'onCollaborativeCursorCreate', { remoteId, data: cursorData[i] });\n        } else {\n            // Update was recieved by a cursor, no need to do anything else!\n            if (tags.debug) {\n                console.log(`${tags.system} cursor updated`);\n            }\n        }\n    }\n\n}",
        "system": "rc-collaborativeCursors.receiver"
      }
    },
    "rc-collaborativeCursors.emitter": {
      "id": "rc-collaborativeCursors.emitter",
      "space": "shared",
      "tags": {
        "cursorColors": "🧬[\n  \"#ED0A3F\",\n  \"#C32148\",\n  \"#FD0E35\",\n  \"#C62D42\",\n  \"#CC474B\",\n  \"#CC3336\",\n  \"#E12C2C\",\n  \"#D92121\",\n  \"#B94E48\",\n  \"#FF5349\",\n  \"#FE4C40\",\n  \"#FE6F5E\",\n  \"#B33B24\",\n  \"#CC553D\",\n  \"#E6735C\",\n  \"#FF9980\",\n  \"#E58E73\",\n  \"#FF7F49\",\n  \"#FF681F\",\n  \"#FF8833\",\n  \"#FFB97B\",\n  \"#ECAC76\",\n  \"#E77200\",\n  \"#FFAE42\",\n  \"#F2BA49\",\n  \"#FBE7B2\",\n  \"#F2C649\",\n  \"#F8D568\",\n  \"#FCD667\",\n  \"#FED85D\",\n  \"#FBE870\",\n  \"#F1E788\",\n  \"#FFEB00\",\n  \"#B5B35C\",\n  \"#ECEBBD\",\n  \"#FAFA37\",\n  \"#FFFF99\",\n  \"#FFFF9F\",\n  \"#D9E650\",\n  \"#ACBF60\",\n  \"#AFE313\",\n  \"#BEE64B\",\n  \"#C5E17A\",\n  \"#5E8C31\",\n  \"#7BA05B\",\n  \"#9DE093\",\n  \"#63B76C\",\n  \"#4D8C57\",\n  \"#3AA655\",\n  \"#6CA67C\",\n  \"#5FA777\",\n  \"#93DFB8\",\n  \"#33CC99\",\n  \"#1AB385\",\n  \"#29AB87\",\n  \"#00CC99\",\n  \"#00755E\",\n  \"#8DD9CC\",\n  \"#01786F\",\n  \"#30BFBF\",\n  \"#00CCCC\",\n  \"#008080\",\n  \"#8FD8D8\",\n  \"#95E0E8\",\n  \"#6CDAE7\",\n  \"#2D383A\",\n  \"#76D7EA\",\n  \"#7ED4E6\",\n  \"#0095B7\",\n  \"#009DC4\",\n  \"#02A4D3\",\n  \"#47ABCC\",\n  \"#2EB4E6\",\n  \"#339ACC\",\n  \"#93CCEA\",\n  \"#2887C8\",\n  \"#00468C\",\n  \"#0066CC\",\n  \"#1560BD\",\n  \"#0066FF\",\n  \"#A9B2C3\",\n  \"#C3CDE6\",\n  \"#4570E6\",\n  \"#7A89B8\",\n  \"#4F69C6\",\n  \"#8D90A1\",\n  \"#8C90C8\",\n  \"#7070CC\",\n  \"#9999CC\",\n  \"#ACACE6\",\n  \"#766EC8\",\n  \"#6456B7\",\n  \"#3F26BF\",\n  \"#8B72BE\",\n  \"#652DC1\",\n  \"#6B3FA0\",\n  \"#8359A3\",\n  \"#8F47B3\",\n  \"#C9A0DC\",\n  \"#BF8FCC\",\n  \"#803790\",\n  \"#733380\",\n  \"#D6AEDD\",\n  \"#C154C1\",\n  \"#FC74FD\",\n  \"#732E6C\",\n  \"#E667CE\",\n  \"#E29CD2\",\n  \"#8E3179\",\n  \"#D96CBE\",\n  \"#EBB0D7\",\n  \"#C8509B\",\n  \"#BB3385\",\n  \"#D982B5\",\n  \"#A63A79\",\n  \"#A50B5E\",\n  \"#614051\",\n  \"#F653A6\",\n  \"#DA3287\",\n  \"#FF3399\",\n  \"#FBAED2\",\n  \"#FFB7D5\",\n  \"#FFA6C9\",\n  \"#F7468A\",\n  \"#E30B5C\",\n  \"#FDD7E4\",\n  \"#E62E6B\",\n  \"#DB5079\",\n  \"#FC80A5\",\n  \"#F091A9\",\n  \"#FF91A4\",\n  \"#A55353\",\n  \"#CA3435\",\n  \"#FEBAAD\",\n  \"#F7A38E\",\n  \"#E97451\",\n  \"#AF593E\",\n  \"#9E5B40\",\n  \"#87421F\",\n  \"#926F5B\",\n  \"#DEA681\",\n  \"#D27D46\",\n  \"#664228\",\n  \"#D99A6C\",\n  \"#EDC9AF\",\n  \"#FFCBA4\",\n  \"#805533\",\n  \"#FDD5B1\",\n  \"#EED9C4\",\n  \"#665233\",\n  \"#837050\",\n  \"#E6BC5C\",\n  \"#D9D6CF\",\n  \"#92926E\",\n  \"#E6BE8A\",\n  \"#C9C0BB\",\n  \"#DA8A67\",\n  \"#C88A65\",\n  \"#736A62\",\n  \"#8B8680\",\n  \"#C8C8CD\"\n]",
        "debug": "false",
        "emit": "@if (!tags.enabled) {\n    return;\n}\n\nif (!os.isCollaborative()) {\n    return;\n}\n\n// Gather map of which portals are showing which dimensions.\nconst portalDimensionKeys = [];\nconst portalDimensions = {};\n\nfor (let portal of tags.portals) {\n    let dimension = os.getPortalDimension(portal);\n\n    if (dimension) {\n        portalDimensions[portal] = dimension;\n        portalDimensionKeys.push(portal);\n    }\n}\n\nif (portalDimensionKeys.length === 0) {\n    // Not current in any portals to emit a cursor for.\n    return;\n}\n\n/**\n * @typedef CollaborativeCursorData\n * @prop {string} pointer\n * @prop {string} portal\n * @prop {string} dimension\n * @prop {{x: number, y: number, z: number}} position\n * @prop {string} color\n * @prop {string} name\n */\n\n/** @type {CollaborativeCursorData[]} */\nconst cursorData = [];\n\nconst cursorPromises = [];\n\n// Raycast into each portal using each pointer ray that we are currently using.\nfor (let pointer of tags.pointers) {\n    if (pointer === 'mouse' && tags.inXR) {\n        // Dont send mouse cursor updates while in XR mode.\n        continue;\n    }\n\n    if ((pointer === 'left' && !tags.inXR) ||\n        (pointer === 'right' && !tags.inXR)\n    ) {\n        // Dont send left/right cursor updates while in XR mode.\n        continue;\n    }\n\n    const pointerPosition = os.getPointerPosition(pointer);\n    const pointerDirection = os.getPointerDirection(pointer);\n\n    for (let portal of portalDimensionKeys) {\n\n        cursorPromises.push(\n            os.raycast(portal, pointerPosition, pointerDirection).then((result) => {\n                if (tags.debug) { \n                    console.log(`[${tags.system}] ${portal} ${pointer} raycast result:`, result);\n                }\n\n                let raycastHit;\n\n                if (result.botIntersections && result.botIntersections.length > 0) {\n                    raycastHit = result.botIntersections.find((h) => {\n                        return !h.bot.tags.isCollaborativeCursor &&\n                               h.bot.tags.pointable !== false\n                    });\n                }\n\n                if (raycastHit) {\n                    cursorData.push({\n                        pointer,\n                        portal,\n                        dimension: portalDimensions[portal],\n                        position: raycastHit.point,\n                        color: configBot.tags.cursorColor,\n                        name: configBot.tags.cursorName,\n                    })\n                } else {\n                    // Didn't hit any bots.\n                    // Try testing against the ground plane.\n                    const groundPoint = math.intersectPlane(pointerPosition, pointerDirection);\n\n                    if (groundPoint != null) {\n                        cursorData.push({\n                            pointer,\n                            portal,\n                            dimension: portalDimensions[portal],\n                            position: groundPoint,\n                            color: configBot.tags.cursorColor,\n                            name: configBot.tags.cursorName,\n                        })\n                    } else {\n                        // Not intersecting with anything right so so lets just get a point some distance down the \n                        // pointer's ray and call it good.\n                        const floatingPoint = {\n                            x: pointerPosition.x + pointerDirection.x * tags.floatingCursorDistance,\n                            y: pointerPosition.y + pointerDirection.y * tags.floatingCursorDistance,\n                            z: pointerPosition.z + pointerDirection.z * tags.floatingCursorDistance,\n                        }\n\n                        cursorData.push({\n                            pointer,\n                            portal,\n                            dimension: portalDimensions[portal],\n                            position: floatingPoint,\n                            color: configBot.tags.cursorColor,\n                            name: configBot.tags.cursorName,\n                        })\n                    }\n                }\n            })\n        )\n    }\n}\n\nawait Promise.all(cursorPromises);\n\nif (cursorData.length === 0) {\n    // No need to emit data as there is nothing to emit!\n    return;\n}\n\n// Get list of other remotes to emit to.\nlet otherRemoteIds = await os.remotes();\n\nif (!tags.selfVisible) {\n    otherRemoteIds = otherRemoteIds.filter(id => id !== configBot.id);\n}\n\nif (tags.debug) {\n    console.log(`[${tags.system}] emit:`, cursorData);\n}\n\nsendRemoteData(otherRemoteIds, 'collaborative-cursor-remotedata', cursorData);",
        "enabled": "true",
        "floatingCursorDistance": "0.7",
        "intervalMS": "350",
        "names": "🧬{\n  \"adjectives\": [\n    \"Agile\", \"Brave\", \"Curious\", \"Daring\", \"Elegant\",\n    \"Fierce\", \"Gentle\", \"Happy\", \"Inquisitive\", \"Joyful\",\n    \"Kind\", \"Lively\", \"Majestic\", \"Noble\", \"Optimistic\",\n    \"Playful\", \"Quick\", \"Restless\", \"Smart\", \"Trustworthy\",\n    \"Unique\", \"Vivid\", \"Wise\", \"Xenial\", \"Youthful\", \"Zesty\",\n    \"Amazing\", \"Bold\", \"Calm\", \"Determined\", \"Energetic\",\n    \"Friendly\", \"Gracious\", \"Harmonious\", \"Intelligent\", \"Jovial\",\n    \"Keen\", \"Luminous\", \"Mighty\", \"Nimble\", \"Observant\",\n    \"Persistent\", \"Quirky\", \"Resilient\", \"Sincere\", \"Talented\",\n    \"Understanding\", \"Valiant\", \"Witty\", \"Exciting\", \"Yielding\",\n    \"Zealous\", \"Adventurous\", \"Bright\", \"Clever\", \"Dynamic\",\n    \"Efficient\", \"Faithful\", \"Graceful\", \"Honorable\", \"Imaginative\",\n    \"Just\", \"Knowledgeable\", \"Lucky\", \"Merry\", \"Nifty\",\n    \"Outgoing\", \"Patient\", \"Resourceful\", \"Skillful\", \"Thoughtful\",\n    \"Unstoppable\", \"Vibrant\", \"Warm\", \"Xtraordinary\", \"Yummy\",\n    \"Zippy\", \"Alert\", \"Benevolent\", \"Charming\", \"Devoted\", \"Expressive\",\n    \"Fearless\", \"Generous\", \"Hopeful\", \"Inspiring\", \"Jolly\"\n  ],\n  \"animals\": [\n    \"Antelope\", \"Bear\", \"Cheetah\", \"Dolphin\", \"Elephant\",\n    \"Fox\", \"Giraffe\", \"Horse\", \"Iguana\", \"Jaguar\",\n    \"Kangaroo\", \"Lion\", \"Monkey\", \"Nightingale\", \"Ostrich\",\n    \"Penguin\", \"Quokka\", \"Rabbit\", \"Seal\", \"Tiger\",\n    \"Uakari\", \"Vulture\", \"Whale\", \"X-rayTetra\", \"Yak\",\n    \"Zebra\", \"Alligator\", \"Bee\", \"Cat\", \"Dog\",\n    \"Falcon\", \"Gazelle\", \"Hamster\", \"Insect\", \"Jellyfish\",\n    \"Koala\", \"Lemur\", \"Moose\", \"Narwhal\", \"Octopus\",\n    \"Panda\", \"Quail\", \"Rat\", \"Snake\", \"Toucan\",\n    \"Unicorn\", \"Viper\", \"Walrus\", \"Xenopus\", \"Yellowtail\",\n    \"Zander\", \"Armadillo\", \"Buffalo\", \"Crab\", \"Deer\",\n    \"Eagle\", \"Flamingo\", \"Gorilla\", \"Hippopotamus\", \"Impala\",\n    \"Jackal\", \"Kite\", \"Leopard\", \"Mongoose\", \"Newt\",\n    \"Owl\", \"Parrot\", \"Quetzal\", \"Rhinoceros\", \"Shark\",\n    \"Tortoise\", \"Urchin\", \"Vicuna\", \"Wolf\", \"Xerus\",\n    \"Yabby\", \"Zebu\", \"Aardvark\", \"Bat\", \"Coyote\",\n    \"Duck\", \"Eel\", \"Frog\", \"Goat\", \"Hedgehog\",\n    \"Inchworm\", \"Jay\", \"Kudu\", \"Llama\", \"Minnow\"\n  ]\n}\n",
        "onBotChanged": "@if (that.tags.some(t => t === 'intervalMS' || t === 'enabled')) {\n    thisBot.stopEmitting();\n    thisBot.startEmitting();\n}",
        "onCollaborativeCursorsInitialize": "@CollaborativeCursors.emitter = thisBot;",
        "onCollaborativeCursorsStart": "@thisBot.startEmitting();",
        "onDestroy": "@CollaborativeCursors.emitter = undefined;\n\nthisBot.stopEmitting();",
        "onEnterAR": "@masks.inXR = true;",
        "onEnterVR": "@masks.inXR = true;",
        "onExitAR": "@masks.inXR = false;",
        "onExitVR": "@masks.inXR = false;",
        "pointers": "🧬[ \"mouse\", \"right\", \"left\" ]",
        "portals": "🧬[ \"grid\", \"miniGrid\", \"map\", \"miniMap\" ]",
        "selfVisible": "false",
        "startEmitting": "@thisBot.stopEmitting();\n\nif (!tags.enabled) { \n    return;\n}\n\nif (tags.debug) {\n    console.log(`[${tags.system}] start emitting`);\n}\n\nif (!configBot.tags.cursorColor) {\n    // Generate a color for this user's id if a cursorColor is not specified.\n    math.setRandomSeed(configBot.id);\n    const colorIndex = math.randomInt(0, tags.cursorColors.length);\n    configBot.tags.cursorColor = tags.cursorColors[colorIndex];\n}\n\nif (!configBot.tags.cursorName) {\n    // Generate a name for this user's id if a cursorName is not specified.\n    math.setRandomSeed(configBot.id);\n    const adjective = tags.names.adjectives[ math.randomInt(0, tags.names.adjectives.length) ];\n    const animal = tags.names.animals[ math.randomInt(0, tags.names.animals.length) ];\n    configBot.tags.cursorName = adjective + ' ' + animal;\n}\n\nmasks.intervalId = setInterval(() => {\n    whisper(thisBot, 'emit');\n}, tags.intervalMS);",
        "stopEmitting": "@if (masks.intervalId) {\n    if (tags.debug) {\n        console.log(`[${tags.system}] stop emitting`);\n    }\n\n    clearInterval(masks.intervalId);\n    masks.intervalId = null;\n}",
        "system": "rc-collaborativeCursors.emitter"
      }
    },
    "rc-collaborativeCursors.cameraListener": {
      "id": "rc-collaborativeCursors.cameraListener",
      "space": "shared",
      "tags": {
        "onAnyBotsChanged": "@const gridPortalBotIndex = that.findIndex((el) => {\n    if (el && globalThis.gridPortalBot && el.bot === gridPortalBot) {\n        return true;\n    }\n});\n\nif (gridPortalBotIndex >= 0) {\n    const changedTags = that[gridPortalBotIndex].tags;\n    const cameraChanged = changedTags.some((t) => {\n        return t === 'cameraPositionX' ||\n            t === 'cameraPositionY' ||\n            t === 'cameraPositionZ' ||\n            t === 'cameraPositionOffsetX' ||\n            t === 'cameraPositionOffsetY' ||\n            t === 'cameraPositionOffsetz' ||\n            t === 'cameraRotationX' ||\n            t === 'cameraRotationY' ||\n            t === 'cameraRotationZ' ||\n            t === 'cameraRotationOffsetX' ||\n            t === 'cameraRotationOffsetY' ||\n            t === 'cameraRotationOffsetZ' ||\n            t === 'cameraRotationOffsetW' ||\n            t === 'cameraFocusX' ||\n            t === 'cameraFocusY' ||\n            t === 'cameraFocusZ' ||\n            t === 'cameraZoom' ||\n            t === 'cameraZoomOffset';\n    })\n\n    if (cameraChanged) {\n        shout('onCollaborativeCursorsCameraChanged', { changedTags });\n    }\n}",
        "system": "rc-collaborativeCursors.cameraListener"
      }
    },
    "rc-collaborativeCursors._packageInfo": {
      "id": "rc-collaborativeCursors._packageInfo",
      "space": "shared",
      "tags": {
        "system": "rc-collaborativeCursors._packageInfo",
        "version": "0.13",
        "versionDate": "📅2023-08-23T11:46:24.141-04:00 local"
      }
    },
    "rc-collaborativeCursors.init": {
      "id": "rc-collaborativeCursors.init",
      "space": "shared",
      "tags": {
        "initialize": "@if (masks.initialized) { \n    return;\n}\n\nmasks.initialized = true;\n\nglobalThis.CollaborativeCursors = {};\n\nshout('onCollaborativeCursorsInitialize');\nshout('onCollaborativeCursorsReady');\nshout('onCollaborativeCursorsStart');",
        "onBotAdded": "@// Handle's the case where the ab is added to an inst with users already \n// in it and the user gets neither onEggHatch or onInstJoined.\nawait os.sleep(2000);\nthisBot.initialize();",
        "onDestroy": "@globalThis.CollaborativeCursors = undefined;",
        "onEggHatch": "@thisBot.initialize();",
        "onInstJoined": "@thisBot.initialize();",
        "system": "rc-collaborativeCursors.init"
      }
    }
  }
}