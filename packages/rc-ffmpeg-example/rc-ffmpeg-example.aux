{
  "version": 1,
  "state": {
    "rc-ffmpeg-example._packageInfo": {
      "id": "rc-ffmpeg-example._packageInfo",
      "space": "shared",
      "tags": {
        "system": "rc-ffmpeg-example._packageInfo",
        "version": "1.1",
        "versionDate": "ðŸ“…2024-04-03T11:21:08.246-04:00 local"
      }
    },
    "rc-ffmpeg-example.ffmpeg": {
      "id": "rc-ffmpeg-example.ffmpeg",
      "space": "shared",
      "tags": {
        "color": "#A4DD00",
        "cursor": "pointer",
        "displayBot0": "ðŸ”—496d0b08-9264-43c9-87d0-dba1ad0db4eb",
        "draggable": "false",
        "ffmpegLog": "true",
        "ffmpegMemoryMB": "128",
        "home": true,
        "homeX": 0,
        "homeY": 3,
        "homeZ": 0,
        "label": "ffmpeg frame extracter",
        "labelFontSize": "1",
        "labelPadding": "0.1",
        "onClick": "@if (masks.busy) {\n    // Only run one process at a time.\n    return;\n}\n\nfunction createDisplay({ arrayBuffer, height = 10, width = 10, index = 0, onDestroy }) {\n    const linkName = 'displayBot' + index;\n\n    destroy(links[linkName]);\n\n    const dim = 'home';\n\n    const blob = new Blob([arrayBuffer]);\n\n    globalThis[linkName + '_buffer'] = arrayBuffer;\n\n    links[linkName] = create({\n        space: 'tempLocal',\n        form: 'sprite',\n        name: linkName,\n        draggable: false,\n        cursor: 'pointer',\n        anchorPoint: 'left',\n        blob: blob,\n        scaleX: width,\n        scaleY: height,\n        onDestroy,\n        [dim]: true,\n        [dim + 'X']: tags[dim + 'X'] + (1.5 * (index + 1)),\n        [dim + 'Y']: tags[dim + 'Y'],\n        [dim + 'Z']: tags[dim + 'Z'],\n        onBotAdded: `@\n            let reader = new self.FileReader();\n            reader.readAsDataURL(tags.blob);\n            reader.onloadend = () => {\n                tags.formAddress = reader.result;\n            }\n        `,\n        onClick: `@\n            let confirmed = await os.showConfirm({\n                title: 'Download Frame',\n                content: 'Do you want to download a local copy of this frame image?'\n            });\n\n            if (confirmed) {\n                os.download(globalThis[tags.name + '_buffer'], uuid(), 'image/png');\n            }\n        `,\n        onDestroy: `@\n            globalThis[tags.name + '_buffer'] = undefined;\n        `\n    })\n}\n\nfunction getMimeType(path) {\n    let ext;\n    const indexOfLastDot = path.lastIndexOf('.');\n    if (indexOfLastDot >= 0) {\n        ext = path.substring(indexOfLastDot + 1);\n    }\n\n    if (ext) {\n        if (ext === 'mkv') {\n            mimeType = 'video/x-matroska';\n        } else if (ext === 'webm') {\n            mimeType = 'video/webm';\n        } else if (ext === 'mp4') {\n            mimeType = 'video/mp4';\n        } else if (ext === '3gp') {\n            mimeType = 'video/3gpp';\n        } else if (ext === 'avi') {\n            mimeType = 'video/x-msvide';\n        } else if (ext === 'mov') {\n            mimeType = 'video/quicktime';\n        } else {\n            throw new Error(`[${tags.system}] Video file did not have a mimeType and one could not be inferred.`);\n        }\n    } else {\n        throw new Error(`[${tags.system}] File path has no valid file extension.`);\n    }\n\n    return mimeType;\n}\n\nconst inputFiles = await os.showUploadFiles();\n\nif (!inputFiles || inputFiles.length === 0) {\n    return;\n}\n\nconst inputFile = inputFiles[0];\n\nlet textInput = await os.showInput(masks.prevTextInput !== undefined ? masks.prevTextInput.toString() : '0', {\n    autoSelect: true,\n    title: 'Extract Frame',\n    placeholder: 'frame number (OR) HH:MM:SS timestamp'\n});\n\nlet inputType = null;\n\nconst timestampRegex = /^(?:[01]\\d|2[0-3]):(?:[0-5]\\d):(?:[0-5]\\d)$/;\nconst integerRegex = /^-?\\d+$/;\n\nlet parsedInput = null;\nlet parsedInputType = null;\n\nif (timestampRegex.test(textInput)) {\n    parsedInputType = 'timestamp';\n    parsedInput = textInput;\n    console.log(`[${tags.system}] text input is a HH:MM:SS timestamp:`, parsedInput);\n} else if (integerRegex.test(textInput)) {\n    parsedInputType = 'integer';\n    parsedInput = Number.parseInt(textInput);\n    console.log(`[${tags.system}] text input is a frame integer:`, parsedInput);\n}\n\nif (parsedInput == null || parsedInputType == null) {\n    console.error(`[${tags.system}] invalid input, must either be an frame integer or a timestamp in the form HH:MM:SS`);\n    return;\n}\n\nmasks.prevTextInput = textInput;\n\nmasks.busy = true;\nmasks.label = 'processing...';\nmasks.color = '#FB9E00';\n\ntry {\n    console.log(`[${tags.system}] inputFile:`, inputFile);\n\n    const inputArrayBuffer = inputFile.data;\n\n    let mimeType = inputFile.mimeType;\n    if (!mimeType) {\n        // If the file does not contain a mimeType, lets infer our own.\n        mimeType = getMimeType(inputFile.name);\n    }\n    console.log(`[${tags.system}] mimeType:`, mimeType);\n\n    const inputBlob = new Blob([inputArrayBuffer], { type: mimeType });\n    console.log(`[${tags.system}] inputBlob:`, inputBlob);\n\n    const ffmpegWorkerModule = await import('https://cdn.jsdelivr.net/gh/Blitzy/ffmpeg-webworker@master/dist/ffmpeg-webworker.js');\n    const workerClient = new ffmpegWorkerModule.FFMPEGWebworkerClient();\n    console.log(`[${tags.system}] workerClient`, workerClient);\n\n    workerClient.on('onStdout', (msg) => {\n        if (tags.ffmpegLog) {\n            console.log(msg);\n        }\n    });\n\n    // Wait for worker to become ready.\n    await new Promise((resolve) => {\n        workerClient.once('onReady', () => {\n            resolve();\n        });\n    });\n\n    const totalMemoryBytes = tags.ffmpegMemoryMB * 1024 * 1024;\n\n    console.log(`[${tags.system}] ffmpeg is ready!`);\n\n    // Assign input file to worker.\n    workerClient.inputFile = inputBlob;\n\n    // Fetch file metadata.\n    const metadata = await new Promise((resolve) => {\n        let workerDone = false;\n\n        const metadata = {\n            width: null,\n            height: null,\n            duration: null\n        }\n\n        function extractVideoResolution(stdoutMessage) {\n            const resolutionRegex = /, (\\d+)x(\\d+)(,|\\s)/;\n            const match = stdoutMessage.match(resolutionRegex);\n\n            if (match) {\n                const width = parseInt(match[1], 10);\n                const height = parseInt(match[2], 10);\n                return { width, height };\n            } else {\n                return null;\n            }\n        }\n\n        function extractDuration(stdoutMessage) {\n            const regex = /Duration: (\\d{2}:\\d{2}:\\d{2})/;\n            const match = stdoutMessage.match(regex);\n            return match ? match[1] : null;\n        }\n\n        function tryResolve() {\n            // Resolve the promise once all the metadata fields have been filled.\n            const metadataKeys = Object.keys(metadata);\n            let fulfillCount = 0;\n            for (let key of metadataKeys) {\n                if (metadata[key] != null) {\n                    fulfillCount++;\n                }\n            }\n\n            if (fulfillCount === metadataKeys.length && workerDone) {\n                // All metadata has been found.\n                console.log(`[${tags.system}] finished retrieving metadata.`);\n                workerClient.removeListener('onStdout', onStdout);\n                resolve(metadata);\n            }\n        }\n\n        function onStdout(msg) {\n            if (metadata.width == null || metadata.height == null) {\n                let resolution = extractVideoResolution(msg);\n                if (resolution) {\n                    metadata.width = resolution.width;\n                    metadata.height = resolution.height;\n                    console.log(`[${tags.system}] extracted resolution:`, resolution);\n                }\n            }\n\n            if (metadata.duration == null) {\n                let duration = extractDuration(msg);\n                if (duration) {\n                    metadata.duration = duration;\n                    console.log(`[${tags.system}] extracted duration:`, duration);\n                }\n            }\n\n            tryResolve();\n        }\n\n        workerClient.on('onStdout', onStdout);\n\n        workerClient.once('onDone', () => {\n            workerDone = true;\n            tryResolve();\n        });\n\n        // workerClient.runCommand(`-ss 00:00:00 -vframes 1 ${uuid()}.png`, totalMemoryBytes);\n        workerClient.runCommand(`-hide_banner`);\n    }).catch((e) => {\n        console.error(`[${tags.system}] caught error during metadata retrieval:`, e);\n    });\n\n    console.log(`[${tags.system}] extracted metadata:`, metadata);\n\n    const output = await new Promise((resolve) => {\n        workerClient.once('onDone', (data) => {\n            console.log(`[${tags.system}] ffmpeg worker is done`, data);\n            resolve(data);\n        });\n\n        workerClient.once('onFileReceived', (msg) => {\n            console.log(`[${tags.system}] ffmpeg worker file recieved:`, msg);\n        });\n\n        if (parsedInputType === 'integer') {\n            workerClient.runCommand(`-vf select=eq(n\\\\,${parsedInput}) -vframes 1 ${uuid()}.png`, totalMemoryBytes);\n        } else if (parsedInputType === 'timestamp') {\n            // Perform clamping on the timestamp since we know the duration of the video.\n            function clampTimestamp(timestamp, maxTimestamp) {\n                const [hh, mm, ss] = timestamp.split(':').map(Number);\n                const [maxHh, maxMm, maxSs] = maxTimestamp.split(':').map(Number);\n\n                if (hh > maxHh || (hh === maxHh && mm > maxMm) || (hh === maxHh && mm === maxMm && ss > maxSs)) {\n                    return maxTimestamp;\n                }\n\n                return timestamp;\n            }\n\n            const clampedTimestamp = clampTimestamp(parsedInput, metadata.duration);\n\n            workerClient.runCommand(`-ss ${clampedTimestamp} -vframes 1 ${uuid()}.png`, totalMemoryBytes);\n        } else {\n            throw new Error(`[${tags.system}] Unknown parsedInputType ${parsedInputType}.`);\n        }\n    });\n\n    console.log(`[${tags.system}] output:`, output);\n\n    workerClient.removeAllListeners();\n    workerClient.terminate();\n\n    const outputArrayBuffer = output[0].data;\n\n    let displayHeight = 10;\n    let displayWidth = displayHeight;\n\n    if (metadata.width && metadata.height) {\n        const videoAspect = metadata.width / metadata.height;\n        displayWidth = displayHeight * videoAspect;\n    }\n\n    createDisplay({\n        arrayBuffer: outputArrayBuffer,\n        height: displayHeight,\n        width: displayWidth\n    })\n} catch (e) {\n    console.error(e);\n} finally {\n    masks.busy = null;\n    masks.label = null;\n    masks.color = null;\n}",
        "scaleX": "2",
        "scaleY": "2",
        "scaleZ": "0.3",
        "system": "rc-ffmpeg-example.ffmpeg"
      }
    }
  }
}