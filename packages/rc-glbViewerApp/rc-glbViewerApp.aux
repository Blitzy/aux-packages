{"version":1,"state":{"ebbf7978-e908-4c4a-93cf-61274a171e0f":{"id":"ebbf7978-e908-4c4a-93cf-61274a171e0f","space":"shared","tags":{"system":"rc-glbViewerApp.app","rectangles":"ðŸ”—edb4fb7c-5665-4656-8efc-58a5b28a9838","mountApp":"@await os.compileApp('my-app', <></>)\nawait os.unregisterApp('my-app');\nawait os.registerApp('my-app', thisBot);\n\nconst { useState, useEffect, useRef } = os.appHooks;\n\n/* =========================\n   Config\n   ========================= */\nconst VIEW_WIDTH  = 512;\nconst VIEW_HEIGHT = 512;\nconst ENCODE_FPS  = 30;       // throttle encode-to-PNG rate\n\nconst CAMERA_FOV  = 60;       // deg\nconst ROTATE_SPEED = 0.005;   // drag sensitivity\nconst DAMPING       = 0.9;    // 0..1; inertia for theta/phi/radius\nconst ZOOM_OUT_FACTOR = 1.15; // multiplicative per-click zoom\nconst ZOOM_IN_FACTOR  = 1 / 1.15;\n\nconst GLB_URL = 'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@main/2.0/Fox/glTF-Binary/Fox.glb';\n\n/* =========================\n   Imports\n   ========================= */\nconst THREE = await import('https://cdn.jsdelivr.net/npm/three@0.141.0/+esm');\nconst { GLTFLoader } = await import('https://cdn.jsdelivr.net/npm/three@0.141.0/examples/jsm/loaders/GLTFLoader.js/+esm');\n\n/* =========================\n   Helpers\n   ========================= */\n\n// Create Offscreen canvas, GL context, and Three WebGLRenderer\nfunction createRenderer() {\n  const canvas = new OffscreenCanvas(VIEW_WIDTH, VIEW_HEIGHT);\n  const gl = canvas.getContext('webgl', {\n    antialias: true,\n    alpha: false,\n    preserveDrawingBuffer: true\n  });\n\n  const renderer = new THREE.WebGLRenderer({\n    canvas,\n    context: gl,\n    antialias: true,\n    alpha: false,\n    premultipliedAlpha: false\n  });\n\n  renderer.setPixelRatio(1);\n  renderer.setSize(VIEW_WIDTH, VIEW_HEIGHT, false);\n  renderer.setClearColor(0xffffff, 1);\n  renderer.outputEncoding = THREE.sRGBEncoding;\n\n  return { canvas, gl, renderer };\n}\n\n// Create scene and camera, add minimal PBR lighting\nfunction createScene() {\n  const scene = new THREE.Scene();\n\n  const camera = new THREE.PerspectiveCamera(\n    CAMERA_FOV,\n    VIEW_WIDTH / VIEW_HEIGHT,\n    0.1,\n    1000\n  );\n\n  const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.9);\n  hemi.position.set(0, 1, 0);\n  scene.add(hemi);\n\n  const dir = new THREE.DirectionalLight(0xffffff, 1.2);\n  dir.position.set(5, 10, 7.5);\n  scene.add(dir);\n\n  return { scene, camera };\n}\n\n// Center the model and derive sensible camera/zoom limits from its size\nfunction frameObject(root, camera, controlRef, limitsRef) {\n  const box = new THREE.Box3().setFromObject(root);\n  const size = new THREE.Vector3();\n  const center = new THREE.Vector3();\n  box.getSize(size);\n  box.getCenter(center);\n\n  root.position.sub(center);\n\n  const maxDim = Math.max(size.x, size.y, size.z) || 1;\n\n  const desiredRadius = Math.max(1.5, maxDim * 1.8);\n  const c = controlRef.current;\n  c.radius = desiredRadius;\n  c.theta = Math.PI * 0.25;\n  c.phi = Math.PI * 0.4;\n\n  limitsRef.current.minRadius = Math.max(maxDim * 0.1, 0.1);\n  limitsRef.current.maxRadius = Math.max(maxDim * 20, 50);\n\n  camera.near = Math.max(maxDim / 1000, 0.01);\n  camera.far  = Math.max(maxDim * 100, 1000);\n  camera.updateProjectionMatrix();\n}\n\n// Update camera from control state with damping and clamps\nfunction updateCameraFromControls(camera, controlRef, limitsRef) {\n  const c = controlRef.current;\n  const lim = limitsRef.current;\n\n  c.theta  += c.vTheta;\n  c.phi    += c.vPhi;\n  c.radius += c.vRadius;\n\n  c.vTheta  *= DAMPING;\n  c.vPhi    *= DAMPING;\n  c.vRadius *= DAMPING;\n\n  const EPS = 0.001;\n  if (c.phi < EPS) c.phi = EPS;\n  if (c.phi > Math.PI - EPS) c.phi = Math.PI - EPS;\n\n  c.radius = Math.min(Math.max(c.radius, lim.minRadius), lim.maxRadius);\n\n  const x = c.radius * Math.sin(c.phi) * Math.sin(c.theta);\n  const y = c.radius * Math.cos(c.phi);\n  const z = c.radius * Math.sin(c.phi) * Math.cos(c.theta);\n  camera.position.set(x, y, z);\n  camera.lookAt(0, 0, 0);\n}\n\n// Convert current canvas frame to a PNG data URL\nasync function encodeFrameToDataURL(canvas) {\n  const blob = await canvas.convertToBlob({ type: 'image/png' });\n  const arrayBuffer = await blob.arrayBuffer();\n  const uint8array = new Uint8Array(arrayBuffer);\n  const base64 = bytes.toBase64String(uint8array);\n  return `data:image/png;base64,${base64}`;\n}\n\n/* =========================\n   React App\n   ========================= */\nconst App = () => {\n  const [imgSrc, setImgSrc] = useState();\n\n  const rafId = useRef(null);\n  const runningRef = useRef(true);\n  const lastFrameTimeRef = useRef(0);\n  const lastAnimTimeRef = useRef(0);\n  const encodingRef = useRef(false);\n\n  const controlRef = useRef({\n    theta: Math.PI * 0.25,\n    phi:   Math.PI * 0.4,\n    radius: 4,\n    vTheta: 0,\n    vPhi:   0,\n    vRadius: 0\n  });\n\n  const limitsRef = useRef({ minRadius: 0.5, maxRadius: 50 });\n  const pointerRef = useRef({ isDown: false, lastX: 0, lastY: 0 });\n\n  useEffect(() => {\n    runningRef.current = true;\n\n    const { canvas, renderer } = createRenderer();\n    const { scene, camera } = createScene();\n\n    const loader = new GLTFLoader();\n    let mixer = null;\n\n    loader.load(\n      GLB_URL,\n      (gltf) => {\n        const root = gltf.scene;\n        scene.add(root);\n        frameObject(root, camera, controlRef, limitsRef);\n\n        if (gltf.animations && gltf.animations.length > 0) {\n          mixer = new THREE.AnimationMixer(root);\n          const action = mixer.clipAction(gltf.animations[0]);\n          action.play();\n        }\n      },\n      undefined,\n      () => {\n        const geo = new THREE.BoxGeometry(1,1,1);\n        const mat = new THREE.MeshNormalMaterial();\n        scene.add(new THREE.Mesh(geo, mat));\n      }\n    );\n\n    const minDeltaMs = 1000 / ENCODE_FPS;\n\n    const loop = async (t) => {\n      if (!runningRef.current) return;\n\n      const prev = lastAnimTimeRef.current || t;\n      const dtSec = Math.max(0, (t - prev) / 1000);\n      lastAnimTimeRef.current = t;\n      if (mixer) mixer.update(dtSec);\n\n      if (t - lastFrameTimeRef.current >= minDeltaMs) {\n        lastFrameTimeRef.current = t;\n\n        updateCameraFromControls(camera, controlRef, limitsRef);\n        renderer.render(scene, camera);\n\n        if (!encodingRef.current) {\n          encodingRef.current = true;\n          try {\n            const dataURL = await encodeFrameToDataURL(renderer.domElement);\n            if (runningRef.current) setImgSrc(dataURL);\n          } finally {\n            encodingRef.current = false;\n          }\n        }\n      }\n\n      rafId.current = self.requestAnimationFrame(loop);\n    };\n\n    rafId.current = self.requestAnimationFrame(loop);\n\n    return () => {\n      runningRef.current = false;\n      if (rafId.current) self.cancelAnimationFrame(rafId.current);\n      renderer.dispose();\n    };\n  }, []);\n\n  const clampRadius = (r) => {\n    const { minRadius, maxRadius } = limitsRef.current;\n    return Math.min(Math.max(r, minRadius), maxRadius);\n  };\n\n  // Predictable + smooth zoom: compute target by factor, then push velocity toward it\n  const applyZoomSmooth = (factor) => {\n    const c = controlRef.current;\n    const target = clampRadius(c.radius * factor);\n    c.vRadius += (target - c.radius) * 0.25;\n  };\n\n  const onPointerDown = (e) => {\n    pointerRef.current.isDown = true;\n    pointerRef.current.lastX = e.clientX ?? 0;\n    pointerRef.current.lastY = e.clientY ?? 0;\n  };\n\n  const onPointerMove = (e) => {\n    if (!pointerRef.current.isDown) return;\n    const x = e.clientX ?? 0;\n    const y = e.clientY ?? 0;\n    const dx = x - pointerRef.current.lastX;\n    const dy = y - pointerRef.current.lastY;\n    pointerRef.current.lastX = x;\n    pointerRef.current.lastY = y;\n\n    const c = controlRef.current;\n    c.vTheta += -dx * ROTATE_SPEED;\n    c.vPhi   += -dy * ROTATE_SPEED;\n  };\n\n  const onPointerUp = () => { pointerRef.current.isDown = false; };\n\n  return (\n    <div>\n      <h1>GLB Viewer</h1>\n\n      <div\n        style={{\n          position: 'relative',\n          width: VIEW_WIDTH,\n          height: VIEW_HEIGHT\n        }}\n      >\n        <div\n          role=\"img\"\n          aria-label=\"threejs frame\"\n          style={{\n            position: 'absolute',\n            inset: 0,\n            backgroundImage: imgSrc ? `url(${imgSrc})` : 'none',\n            backgroundRepeat: 'no-repeat',\n            backgroundPosition: 'center',\n            backgroundSize: 'contain',\n            pointerEvents: 'none',\n            zIndex: 0\n          }}\n        />\n        <div\n          onPointerDown={onPointerDown}\n          onPointerMove={onPointerMove}\n          onPointerUp={onPointerUp}\n          onPointerCancel={onPointerUp}\n          style={{\n            position: 'absolute',\n            inset: 0,\n            zIndex: 1,\n            background: 'transparent',\n            userSelect: 'none',\n            touchAction: 'none',\n            cursor: pointerRef.current.isDown ? 'grabbing' : 'grab'\n          }}\n        />\n        <div\n          style={{\n            position: 'absolute',\n            right: 8,\n            bottom: 8,\n            display: 'flex',\n            gap: 8,\n            zIndex: 2,\n            pointerEvents: 'auto'\n          }}\n        >\n          <button\n            onClick={() => applyZoomSmooth(ZOOM_IN_FACTOR)}\n            aria-label=\"Zoom in\"\n            style={{\n              padding: '6px 10px',\n              borderRadius: 8,\n              border: '1px solid #ccc',\n              background: '#fff',\n              cursor: 'pointer'\n            }}\n          >\n            +\n          </button>\n          <button\n            onClick={() => applyZoomSmooth(ZOOM_OUT_FACTOR)}\n            aria-label=\"Zoom out\"\n            style={{\n              padding: '6px 10px',\n              borderRadius: 8,\n              border: '1px solid #ccc',\n              background: '#fff',\n              cursor: 'pointer'\n            }}\n          >\n            â€“\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nos.compileApp('my-app', <App />);\n","onInstJoined":"@thisBot.mountApp();","onEggHatch":"@thisBot.mountApp();","onChat":"@const { message } = that;\n\nif (message === '.app') {\n    thisBot.mountApp();\n}","home":"true"}}}}