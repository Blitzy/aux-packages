{
  "version": 1,
  "state": {
    "rc-package-dev._packageInfo": {
      "id": "rc-package-dev._packageInfo",
      "space": "shared",
      "tags": {
        "system": "rc-package-dev._packageInfo",
        "version": "3.10",
        "versionDate": "üìÖ2025-06-06T10:20:19.801-04:00 local"
      }
    },
    "rc-package-dev.apps.commandHelpApp": {
      "id": "rc-package-dev.apps.commandHelpApp",
      "space": "shared",
      "tags": {
        "HelpApp": "@const AppContainer = rcdev.appComponents.AppContainer();\nconst Window = rcdev.appComponents.Window();\nconst TextLink = rcdev.appComponents.TextLink();\nconst css = rcdev.compileCSS([ thisBot, rcdev.appComponents ]);\n\nconst { useState, useEffect, useCallback, useRef, useMemo } = os.appHooks;\n\n/**\n * @param {Object} props\n * @param {Object.<string, Command>} props.commands\n */\nconst AvailableCommands = ({ commands, onCommandClick }) => {\n    const commandNames = Object.keys(commands).sort();\n\n    const onClose = useCallback(() => {\n        thisBot.unmount();\n    }, []);\n    \n    return (\n        <>\n            <p><TextLink onClick={onClose}>{'x Close'}</TextLink></p>\n            <h2>Available Commands</h2>\n            <p>Usage: $command [options]</p>\n            <br/>\n            <table className='help-table'>\n                {commandNames.map((name) => {\n                    const command = commands[name];\n\n                    let description = null;\n\n                    if (command.help) {\n                        if (command.help.shortDescription) {\n                            description = command.help.shortDescription;\n                        }\n                    }\n                    \n                    return (\n                        <tr>\n                            <td><TextLink onClick={() => onCommandClick(command.name)}>{command.name}</TextLink></td>\n                            <td>{description}</td>\n                        </tr>\n                    )\n                })}\n            </table>\n        </>\n    )\n}\n\n/**\n * @param {Object} props\n * @param {Command} props.command\n */\nconst SpecificCommand = ({ command, onBack }) => {\n    let usage = '';\n    let description = null;\n    let args = null;\n\n    if (command.help) {\n        if (command.help.usage) {\n            if (Array.isArray(command.help.usage)) {\n                usage = command.help.usage.join('\\n');\n            } else {\n                usage = command.help.usage;\n            }\n        }\n\n        if (command.help.longDescription) {\n            description = command.help.longDescription;\n        } else if (command.help.shortDescription) {\n            description = command.help.shortDescription;\n        }\n\n        if (command.help.args && command.help.args.length > 0) {\n            args = command.help.args;\n        }\n    }\n    \n    return (\n        <>  \n            <p><TextLink onClick={onBack}>{'< Back'}</TextLink></p>\n            <h2>{command.name}</h2>\n            { usage &&\n                <table className='usage-table'>\n                    <tr>\n                        <td><h3>Usage:</h3></td>\n                        <td>{usage}</td>\n                    </tr>\n                </table>\n            }\n            { description && \n                <div className='section'>\n                    <h3>Description:</h3>\n                    <p className='description'>{description}</p>\n                </div>\n            }\n            { args &&\n                <div className='section'>\n                    <h3>Arguments:</h3>\n                    <table className='args-table'>\n                        { args.map((arg) => {\n                            if (!arg.identifier) {\n                                return null;\n                            }\n                            \n                            let argIdentifierDisplay = null;\n                            let argDescriptionDisplay = null;\n\n                            if (Array.isArray(arg.identifier)) {\n                                argIdentifierDisplay = arg.identifier.join(',\\n');\n                            } else {\n                                argIdentifierDisplay = arg.identifier;\n                            }\n\n                            if (arg.description) {\n                                argDescriptionDisplay = arg.description;\n                            }\n\n                            return (\n                                <tr>\n                                    <td>{argIdentifierDisplay ?? ''}</td>\n                                    <td>{argDescriptionDisplay ?? ''}</td>\n                                </tr>\n                            )\n                        })}\n                    </table>\n                </div>\n            }\n            <br/>\n            <table className='help-table'>\n            </table>\n        </>\n    )\n}\n\n/**\n * @param {Object} props\n * @param {Object.<string, Command>} props.commands\n * @param {any[]} [props.args]\n */\nconst HelpApp = ({ commands, initialSelectedCommand }) => {\n    const [ selectedCommand, setSelectedCommand ] = useState(initialSelectedCommand);\n\n    // Escape key press event handler\n    useEffect(() => {\n        const onEscapeKeyPress = () => {\n            if (selectedCommand != null) {\n                setSelectedCommand(null);\n            } else {\n                thisBot.unmount();\n            }\n        }\n\n        thisBot.vars.onEscapeKeyPress.push(onEscapeKeyPress);\n\n        return () => {\n            const callbackIndex = thisBot.vars.onEscapeKeyPress.findIndex((callback) => callback === onEscapeKeyPress);\n            if (callbackIndex >= 0) {\n                thisBot.vars.onEscapeKeyPress.splice(callbackIndex, 1);\n            }\n        }\n    }, [selectedCommand]);\n    \n    const onBackgroundClick = useCallback(() => {\n        thisBot.unmount();\n    }, []);\n\n    const onCommandClick = useCallback((name) => {\n        setSelectedCommand(name);\n    }, [setSelectedCommand])\n\n    const content = useMemo(() => {\n        if (!selectedCommand) {\n            return <AvailableCommands commands={commands} onCommandClick={onCommandClick}/>\n        } else { \n            return <SpecificCommand command={commands[selectedCommand]} onBack={() => setSelectedCommand(null)}/>\n        }\n    }, [commands, selectedCommand, setSelectedCommand]);\n\n    return (\n        <>\n            <style>{css}</style>\n\n            <AppContainer onBackgroundClick={onBackgroundClick}>\n                <Window>\n                    {content}\n                </Window>\n            </AppContainer>\n        </>\n    )\n}\n\nreturn HelpApp;",
        "mount": "@const {\n    commandsManager,\n    selectedCommand\n} = that ?? {};\n\nif (masks.helpActive) {\n    await thisBot.unmount();\n}\n\nconst HelpApp = thisBot.HelpApp();\n\nawait os.registerApp('rc-command-help', thisBot);\nawait os.compileApp('rc-command-help', <HelpApp commands={commandsManager.commands} initialSelectedCommand={selectedCommand}/>);\n\nthisBot.vars.onEscapeKeyPress = [];\nmasks.helpActive = true;",
        "onBotAdded": "@if (!globalThis.rcdev) {\n    globalThis.rcdev = {};\n}\n\nrcdev.helpApp = thisBot;",
        "onDestroy": "@if (globalThis.rcdev) {\n    rcdev.helpApp = undefined;\n}",
        "onKeyDown": "@if (tags.helpActive && that.keys.includes('Escape')) {\n    if (thisBot.vars.onEscapeKeyPress) {\n        for (let callback of thisBot.vars.onEscapeKeyPress) {\n            if (typeof callback === 'function') {\n                callback();\n            }\n        }\n    }\n}",
        "style.css": ".help-table {\n  width: 100%;\n  border-spacing: 0;\n}\n\n.help-table td {\n  vertical-align: top;\n  padding-bottom: 8px;\n  white-space: pre-wrap;\n}\n\n.help-table td h3 {\n  margin: 0;\n}\n\n.help-table td:first-child {\n  min-width: 90px;\n  padding-right: 8px;\n}\n\n.section {\n  margin-top: 16px;\n}\n\n.section p:first-of-type {\n  margin-top: 4px;\n  margin-left: 16px;\n}\n\n.description { \n  white-space: pre-line;\n}\n\n.usage-table {\n  border-spacing: 0;\n}\n\n.usage-table td,h3 { \n  vertical-align: top;\n  white-space: pre-wrap;\n  margin: 0;\n}\n\n.usage-table td:first-child {\n  min-width: 60px;\n}\n\n.args-table {\n  margin-left: 16px;\n}\n\n.args-table td {\n  vertical-align: top;\n  padding-bottom: 8px;\n  white-space: pre-wrap;\n}\n\n.args-table td:first-child {\n  min-width: 90px;\n  padding-right: 8px;\n}\n\n@media (max-width: 640px), (max-height: 600px) {\n  .help-window {\n    width: 100%;\n    height: 100%;\n    left: unset;\n    top: unset;\n    transform: unset;\n    max-width: unset;\n    max-height: unset;\n    box-shadow: unset;\n  }\n}",
        "system": "rc-package-dev.apps.commandHelpApp",
        "unmount": "@await os.compileApp('rc-command-help', <></>);\nawait os.unregisterApp('rc-command-help');\n\nthisBot.vars.onEscapeKeyPress = undefined;\nmasks.helpActive = false;"
      }
    },
    "rc-package-dev.apps.compileCSS": {
      "id": "rc-package-dev.apps.compileCSS",
      "space": "shared",
      "tags": {
        "onBotAdded": "@function compileCSS (bots) {\n    bots = Array.isArray(bots) ? bots : [bots];\n\n    let css = [];\n\n    for (let bot of bots) {\n        for (let key in bot.tags) {\n            if (key.toLowerCase().endsWith('css')) {\n                if (tags.debug) {\n                    console.log(`[compileCSS] found CSS key: ${key}`);\n                }\n                css.push(bot.tags[key]);\n            }\n        }\n    }\n\n    const compiled = css.join('\\n\\n');\n    if (tags.debug) {\n        console.log(`[compileCSS] compiled CSS:\\n\\n`, compiled);\n    }\n\n    return compiled;\n}\n\nif (!globalThis.rcdev) {\n    globalThis.rcdev = {};\n}\n\nrcdev.compileCSS = compileCSS;",
        "onDestroy": "@if (globalThis.rcdev) {\n    rcdev.compileCSS = undefined;\n}",
        "system": "rc-package-dev.apps.compileCSS"
      }
    },
    "rc-package-dev.apps.components": {
      "id": "rc-package-dev.apps.components",
      "space": "shared",
      "tags": {
        "AppContainer": "@const { useCallback, useState } = os.appHooks;\n\nconst AppContainer = ({\n    id = uuid(),\n    onBackgroundClick,\n    children\n}) => {\n    const [appId, ] = useState(id);\n\n    const onClick = useCallback((e) => {\n        if (e.target.id === appId) {\n            if (onBackgroundClick) {\n                // Clicked on app background.\n                onBackgroundClick();\n            }\n        }\n    }, [appId]);\n\n    return (\n        <div id={appId} className='rc-app-bg' onClick={onClick}>\n            {children}\n        </div>\n    )\n}\n\nreturn AppContainer;",
        "BackgroundOverlay.css": ".rc-app-bg {\n    position: fixed;\n    background-color: rgba(0, 0, 0, 0.33);\n    width: 100%;\n    height: 100%;\n}",
        "TextLink": "@const TextLink = ({\n    onClick,\n    bold = false,\n    children,\n}) => {\n    return (\n        <span className='rc-app-text-link bold' onClick={onClick}>{children}</span>\n    )\n}\n\nreturn TextLink;",
        "TextLink.css": ".rc-app-text-link {\n  color: rgb(71 255 137);\n}\n\n.rc-app-text-link:hover {\n  cursor: pointer;\n  color: rgb(0 192 255);\n}\n\n.rc-app-text-link.bold {\n  font-weight: bold;\n}",
        "Window": "@const Window = ({\n    id,\n    disableShadow,\n    children,\n}) => {\n\n    let windowClassName = 'rc-app-window';\n\n    if (disableShadow) {\n        windowClassName += ' no-shadow';\n    }\n\n    return (\n        <div id={id} className={windowClassName}>\n            {children}\n        </div>\n    )\n}\n\nreturn Window;",
        "Window.css": ".rc-app-window {\n    position: fixed;\n    font-family: monospace;\n    color: white;\n    background-color: #2f2f2f;\n    width: 80vw;\n    height: 70vh;\n    max-width: 1500px;\n    max-height: 1000px;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n    box-shadow: 0px 0px 12px 0px black;\n    overflow: auto;\n    padding-left: 8px;\n    padding-right: 8px;\n}\n\n.rc-app-window.no-shadow {\n    box-shadow: none;\n}",
        "onBotAdded": "@if (!globalThis.rcdev) {\n    globalThis.rcdev = {};\n}\n\nrcdev.appComponents = thisBot;",
        "onDestroy": "@if (globalThis.rcdev) {\n    rcdev.appComponents = undefined;\n}",
        "system": "rc-package-dev.apps.components"
      }
    },
    "rc-package-dev.apps.consoleApp": {
      "id": "rc-package-dev.apps.consoleApp",
      "space": "shared",
      "tags": {
        "App": "@const { useState, useCallback, useEffect, useRef } = os.appHooks;\n\nconst LogViewer = () => {\n    const sectionRef = useRef(null);\n\n    useEffect(() => {\n        os.sleep(500).then(() => {\n            // console.log('sectionRef', sectionRef.current.scrollTop);\n            // sectionRef.current.scrollTop(sectionRef.current.offsetHeight);\n        })\n        // console.log('divRef', divRef);\n        \n        // function onConsoleLogAdded(listenerThat) {\n\n        // }\n    }, []);\n\n    /** @type ConsoleLog[] */\n    const logHistory = thisBot.vars.logHistory;\n\n    const messages = [];\n\n    for (let i = logHistory.length - 1; i >= 0; i--) {\n        const log = logHistory[i];\n\n        messages.push(\n            <div className={`message ${log.logType}`}>\n                {log.message}\n            </div>\n        )\n    }\n\n    return (\n        <section ref={sectionRef} className='log-viewer'>\n            <div className='scroll-anchor'></div>\n            {messages}\n        </section>\n    )\n}\n\nconst App = () => {\n    const inputRef = useRef(null);\n    const historyIndex = useRef(thisBot.vars.commandHistory.length);\n\n    useEffect(() => {\n        thisBot.sleepForFrames({ frames: 2 }).then(() => {\n            inputRef.current.focus();\n        });\n    }, [inputRef]);\n\n    const onSubmit = useCallback(() => {\n        const inputValue = inputRef.current.value;\n\n        if (inputValue) {\n            if (thisBot.vars.commandHistory) {\n                thisBot.vars.commandHistory.push(inputValue);\n                historyIndex.current = thisBot.vars.commandHistory.length;\n            }\n\n            shout('onChat', { message: inputValue });\n        }\n\n        thisBot.unmount();\n    }, []);\n\n    const onKeyDown = useCallback((e) => {\n        if (e.key === 'Enter') {\n            onSubmit();\n        } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {\n            const dir = e.key === 'ArrowUp' ? -1 : 1;\n            let hIndex = historyIndex.current + dir;\n\n            if (hIndex >= 0 && hIndex < thisBot.vars.commandHistory.length) {\n                const historicalText = thisBot.vars.commandHistory[hIndex];\n                inputRef.current.value = historicalText;\n                historyIndex.current = hIndex;\n            } else if (hIndex < 0) {\n                inputRef.current.value = '';\n                historyIndex.current = -1;\n            } else if (hIndex >= thisBot.vars.commandHistory.length) {\n                inputRef.current.value = '';\n                historyIndex.current = thisBot.vars.commandHistory.length;\n            }\n\n            let valueLength = inputRef.current.value.length;\n            inputRef.current.setSelectionRange(valueLength, valueLength);\n        }\n    }, [onSubmit]);\n\n    return (\n        <>\n            <style>{tags['style.css']}</style>\n            <div className='rc-console-app' onKeyDown={onKeyDown}>\n                { tags.showLogViewer && \n                    <LogViewer/>\n                }\n                <div className='input-bar'>\n                    <div className='input-carrot'>{'>'}</div>\n                    <input ref={inputRef} autofocus type='text'></input>\n                    <button className='send-button' onClick={onSubmit} id='console-close'>\n                        <span class=\"material-icons send-icon\">send</span>\n                    </button>\n                </div>\n            </div>\n        </>\n    )\n}\n\nreturn App;\n",
        "captureLogs": "false",
        "debug": "true",
        "forceUpdate": "@const App = thisBot.vars.appInstance;\n\nif (App) {\n    os.compileApp(tags.system, <App/>)\n}\n",
        "inPrimaryInst": "@const url = new URL(configBot.tags.url);\n\nlet primaryInst = url.searchParams.getAll('inst')[0]\n\nif (!primaryInst) {\n    primaryInst = url.searchParams.getAll('staticInst')[0]\n}\n\nconst currentInst = os.getCurrentInst();\n\n// Handle case where os.getCurrentInst returns a list of insts.\n// This is the case with older versions of CasualOS.\nif (currentInst.includes(',')) {\n    // Older versions of CasualOS did not have the ability to determine what inst a bot was a part of via os.getCurrentInst.\n    // In those cases we are going to ignore the keyboard input to open the custom app in scenarios where multiple insts are loaded\n    // in order to prevent multiple console apps being opened.\n    rcdev.warnAndToast(`Ignoring console app keyboard shortcut. Unable to determine whats insts bots belong too in older versions of CasualOS and so it is safer to ignore it. Use the built-in ab1 chat window instead (~ key).`);\n    return undefined;\n} else {\n    return primaryInst === currentInst;\n}",
        "mount": "@if (!thisBot.vars.appInstance) {\n    thisBot.vars.appInstance = thisBot.App();\n    await os.registerApp(tags.system, thisBot);\n\n    thisBot.forceUpdate();\n}\n",
        "onBotAdded": "@thisBot.vars.commandHistory = [];\n\n/**\n * @typedef ConsoleLog\n * @prop {'log'|'error'|'warn'|'info'} logType\n * @prop {string} message\n */\n\n/** @type ConsoleLog[] */\nconst logHistory = [];\nthisBot.vars.logHistory = logHistory;\n\nfunction generateLoremIpsum(size) {\n  const loremIpsum = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\";\n  let result = \"\";\n\n  while (result.length < size) {\n    result += loremIpsum + \" \";\n  }\n\n  return result.substring(0, size);\n}\n\nlogHistory.push({ logType: 'log', message: '--- fake logs start --- '});\nfor (let i = 0; i < 500; i++) {\n    let logType = 'log';\n\n    if (Math.random() < 0.2) {\n        logType = 'warn';\n    } else if (Math.random() < 0.05) {\n        logType = 'error';\n    }\n\n    logHistory.push({\n        logType,\n        message: `[${i}] ${generateLoremIpsum(math.random(20, 300))}`\n    })\n}\nlogHistory.push({ logType: 'log', message: '--- fake logs end --- '});\n\nfunction argsToString(...args) {\n    // Convert the arguments to a string.\n    // Join the arguments with a space between them.\n    let message = args.map(arg => {\n        if (typeof arg === 'object') {\n            if (arg instanceof Error) {\n                return arg.toString();\n            } else {\n                // If the argument is an object, convert it to a string using JSON.stringify\n                // Note that this will not work for circular structures in the object.\n                return JSON.stringify(arg);\n            }\n        } else {\n            // Otherwise, just convert the argument to a string\n            return String(arg);\n        }\n    }).join(' ');\n\n    return message;\n}\n\n// Capture console logs.\nconst originalLog = console.log;\nconst originalError = console.error;\nconst originalWarn = console.warn;\nconst originalInfo = console.info;\n\nconsole.log = function(...args) {\n    if (tags.captureLogs) {\n        logHistory.push({ logType: 'log', message: argsToString(...args) });\n        shout('onConsoleLogAdded', { log: logHistory[logHistory.length - 1], logHistory });\n    }\n    originalLog.apply(console, arguments);\n}\n\nconsole.error = function(...args) {\n    if (tags.captureLogs) {\n        logHistory.push({ logType: 'error', message: argsToString(...args) });\n        shout('onConsoleLogAdded', { log: logHistory[logHistory.length - 1], logHistory });\n    }\n    originalError.apply(console, arguments);\n}\n\nconsole.warn = function(...args) {\n    if (tags.captureLogs) {\n        logHistory.push({ logType: 'warn', message: argsToString(...args) });\n        shout('onConsoleLogAdded', { log: logHistory[logHistory.length - 1], logHistory });\n    }\n    originalWarn.apply(console, arguments);\n}\n\nconsole.info = function(...args) {\n    if (tags.captureLogs) {\n        logHistory.push({ logType: 'info', message: argsToString(...args) });\n        shout('onConsoleLogAdded', { log: logHistory[logHistory.length - 1], logHistory });\n    }\n    originalInfo.apply(console, arguments);\n}\n",
        "onDestroy": "@thisBot.unmount();",
        "onKeyDown": "@const { keys } = that;\n\nconst tilde = that.keys[0] === '~';\nconst esc = that.keys[0] === 'Escape';\n\nif (tilde) {\n    if (!thisBot.vars.appInstance) {\n        if (thisBot.inPrimaryInst()) {\n            thisBot.mount();\n        }\n    }\n} else if (esc) {\n    if (thisBot.vars.appInstance) {\n        thisBot.unmount();\n    }\n}",
        "showLogViewer": "false",
        "sleepForFrames": "@const { frames } = that ?? {};\n\nlet passedFrames = 0;\n\nif (frames > 0) {\n    while(passedFrames < frames) {\n        await new Promise((resolve) => {\n            self.requestAnimationFrame(() => {\n                passedFrames++;\n                resolve();\n            })\n        })\n    }\n}",
        "style.css": ".material-icons {\n    font-family: 'Material Icons';\n    font-weight: normal;\n    font-style: normal;\n    font-size: 24px;  /* Preferred icon size */\n    display: inline-block;\n    line-height: 1;\n    text-transform: none;\n    letter-spacing: normal;\n    word-wrap: normal;\n    white-space: nowrap;\n    direction: ltr;\n    user-select: none;\n\n    /* Support for all WebKit browsers. */\n    -webkit-font-smoothing: antialiased;\n    /* Support for Safari and Chrome. */\n    text-rendering: optimizeLegibility;\n\n    /* Support for Firefox. */\n    -moz-osx-font-smoothing: grayscale;\n\n    /* Support for IE. */\n    font-feature-settings: 'liga';\n}\n\n.rc-console-app {\n    width: 100vw;\n}\n\n.rc-console-app .input-bar {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: nowrap;\n    background: #1f1f1f;\n    margin: 4px;\n    border-radius: 4px;\n    color: white;\n    box-shadow: 2px 4px 4px #0000002b;\n}\n\n.rc-console-app .input-bar .input-carrot {\n    font-size: 18px;\n    align-self: center;\n    margin-left: 8px;\n    opacity: 0.6;\n    user-select: none;\n    font-weight: bold;\n    margin-bottom: 2px;\n    font-family: monospace;\n    transform: scale(0.75, 1.25);\n}\n\n.rc-console-app .input-bar input {\n    background: none;\n    border: none;\n    outline: none;\n    flex-grow: 1;\n    font-size: 16px;\n    padding: 12px 4px 12px 4px;\n    color: white;\n    font-family: monospace;\n}\n\n.rc-console-app .input-bar .send-button {\n    width: 48px;\n    background: none;\n    border: none;\n    outline: none;\n    cursor: pointer;\n    color: rgb(71 255 137)\n}\n\n.rc-console-app .log-viewer { \n    display: flex;\n    flex-direction: column-reverse;\n    background: #1f1f1f;\n    height: 35vh;\n    overflow-y: auto;\n    overflow-x: hidden;\n    overflow-wrap: anywhere;\n}\n\n.rc-console-app .log-viewer .scroll-anchor { \n    overflow-anchor: auto;\n    height: 1px;\n}\n\n.rc-console-app .log-viewer .message { \n    font-family: monospace;\n    font-size: 12px;\n    border-bottom: solid 1px #555;\n    padding-left: 16px;\n    padding-right: 16px;\n    padding-bottom: 2px;\n    padding-top: 2px;\n    overflow-anchor: none;\n}\n\n.rc-console-app .log-viewer .message.log { \n    color: white;\n}\n\n.rc-console-app .log-viewer .message.warn {\n    color: rgb(255, 217, 0);\n    background-color: rgba(255, 217, 0, 0.25);\n}\n\n.rc-console-app .log-viewer .message.error { \n    color: rgb(248, 88, 79);\n    background-color: rgba(245, 19, 7, 0.2);\n}\n\n.rc-console-app .log-viewer .message.info { \n    color: rgb(21, 185, 230);\n}\n\n@media (hover: hover) {\n    .rc-console-app .input-bar .send-button:hover {\n        transition: color 0.2s ease;\n        color: rgb(255, 255, 255)\n    }\n}\n\n.rc-console-app .input-bar .send-icon {\n}\n",
        "system": "rc-package-dev.apps.consoleApp",
        "unmount": "@if (thisBot.vars.appInstance) {\n    delete thisBot.vars.appInstance;\n    await os.unregisterApp(tags.system);\n}\n"
      }
    },
    "rc-package-dev.apps.packagesApp": {
      "id": "rc-package-dev.apps.packagesApp",
      "space": "shared",
      "tags": {
        "App": "@const AppContainer = rcdev.appComponents.AppContainer();\nconst Window = rcdev.appComponents.Window();\nconst TextLink = rcdev.appComponents.TextLink();\nconst css = rcdev.compileCSS([ thisBot, rcdev.appComponents ]);\n\nconst { useState, useCallback, useEffect, useMemo } = os.appHooks;\n\nconst PackageTable = ({\n    children\n}) => {\n    return (\n        <div className='package-table'>\n            <table>\n                <tr>\n                    <th style={{ width: '35%' }}>Package Name</th>\n                    <th style={{ width: '15%' }}>Version</th>\n                    <th>Version Date</th>\n                    <th>Actions</th>\n                </tr>\n                {children}\n            </table>\n        </div>\n    )\n}\n\nconst PackageTableRow = ({\n    name,\n    version,\n    versionDate,\n    onVersionBumped,\n    onUnloaded,\n    onPublishSelected\n}) => {\n    const onExportClick = useCallback(() => {\n        exporter.downloadPackages({ name: undefined, ...[name] })\n    }, [name]);\n\n    const onBumpVersion = useCallback(() => {\n        os.showInput(0, {\n            title: 'Version bump type',\n            type: 'list',\n            subtype: 'radio',\n            items: [\n                {\n                    label: 'None',\n                    value: 0,\n                },\n                {\n                    label: 'Minor (1.x)',\n                    value: 1,\n                },\n                {\n                    label: 'Major (x.0)',\n                    value: 2\n                }\n            ]\n        }).then((selectedItem) => {\n            if (selectedItem) {\n                if (selectedItem.value === 0) {\n                    // Do nothing.\n                } else if (selectedItem.value === 1) {\n                    packageInfo.bumpVersion({ name, bumpType: 'minor' });\n                    if (onVersionBumped) {\n                        onVersionBumped();\n                    }\n                } else if (selectedItem.value === 2) {\n                    packageInfo.bumpVersion({ name, bumpType: 'major' });\n                    if (onVersionBumped) {\n                        onVersionBumped();\n                    }\n                }\n            }\n        });\n    }, [name]);\n\n    const onUnloadClick = useCallback(() => {\n        const packages = exporter.getBotPackages(name);\n        \n        if (packages && packages[name]) {\n            os.showConfirm({\n                title: `Unload Package`,\n                content: `Are you sure you want to unload ${name} from the inst?`,\n                confirmText: 'Yes',\n                cancelText: 'Cancel'\n            }).then((confirmed) => {\n                if (confirmed) {\n                    let bots = packages[name];\n                    destroy(bots);\n\n                    if (onUnloaded) {\n                        onUnloaded();\n                    }\n                }\n            })\n        }\n    }, [name]);\n\n    const onPublishClick = useCallback(() => {\n        if (onPublishSelected) {\n            onPublishSelected(name);\n        }\n    }, [name])\n\n    return (\n        <tr>\n            <td>{name}</td>\n            <td>{version}</td>\n            <td>{versionDate ? versionDate.toLocaleString(DateTime.DATETIME_MED_WITH_SECONDS) : ''}</td>\n            <td>\n                <div className='package-action-container'>\n                    <button className='package-action' onClick={onBumpVersion}>üîº</button>\n                    <button className='package-action' onClick={onExportClick}>üíæ</button>\n                    { false && \n                        <button className='package-action' onClick={onPublishClick}>‚§¥Ô∏è</button>\n                    }\n                    <button className='package-action' onClick={onUnloadClick}>‚ùå</button>\n                </div>\n            </td>\n        </tr>\n    )\n}\n\nconst PublishWindow = ({\n    name,\n    onClose,\n}) => {\n    const [studioId, setStudioId] = useState(() => {\n        if (masks.lastSelectedStudioId) {\n            return masks.lastSelectedStudioId;\n        } else if (authBot) {\n            return authBot.id;\n        } else {\n            return null;\n        }\n    });\n\n    const [error, setError] = useState();\n\n    const studioOptions = useMemo(() => {\n        const options = [\n            {\n                label: '--Choose Studio--',\n                value: 'none',\n            },\n            {\n                label: 'My Studio',\n                value: authBot.id,\n            }\n        ];\n\n        if (configBot.tags.user_studios.studios && configBot.tags.user_studios.studios.length > 0) {\n            for (let i = 0; i < configBot.tags.user_studios.studios.length; i++) {\n                options.push({\n                    label: configBot.tags.user_studios.studios[i].displayName ?? 'Unknown Studio',\n                    value: configBot.tags.user_studios.studios[i].studioId,\n                });\n            }\n        }\n\n        return options.map((o) => {\n            return <option value={o.value} selected={o.value === studioId}>{o.label}</option>\n        })\n    }, [])\n\n    const onStudioSelect = useCallback((e) => {\n        if (e.currentTarget.value === 'none') {\n            setStudioId(null);\n        } else {\n            setStudioId(e.currentTarget.value);\n            masks.lastSelectedStudioId = e.currentTarget.value;\n        }\n    }, []);\n\n    const onPublishClick = useCallback(() => {\n        setError(null);\n\n        if (studioId) {\n            console.log(`on publish click - studio: ${studioId}`);\n        } else {\n            setError('Studio is required');\n        }\n    }, [studioId])\n\n    return (\n        <Window id='rc-app-publish-window' disableShadow>\n            <p><TextLink onClick={onClose}>{'< Back'}</TextLink></p>\n            <h2>{`Publish ${name}`}</h2>\n            <label for='studio-select'>Studio:</label>\n            <select id='studio-select' className='package-select' onChange={onStudioSelect}>\n                {studioOptions}\n            </select>\n            { error &&\n                <p style={{ color: 'red' }}>{error}</p>\n            }\n            <div>\n                <button className='package-button' onClick={onPublishClick}>Publish</button>\n            </div>\n        </Window>\n    )\n}\n        \nconst App = () => {\n    const [updateId, setUpdateId] = useState(uuid());\n    const [publishId, setPublishId] = useState();\n\n    const onBackgroundClick = useCallback(() => {\n        thisBot.unmount();\n    }, []);\n\n    const packageTableRows = useMemo(() => {\n        const packages = exporter.getBotPackages();\n        const packageNames = Object.keys(packages).sort();\n\n        const onVersionBumped = () => {\n            setUpdateId(uuid());\n        }\n\n        const onUnloaded = () => {\n            setUpdateId(uuid());\n        }\n\n        const rows = packageNames.map((name, index) => {\n            const packageInfoBot = packages[name].find(b => b.tags.system === `${name}._packageInfo`);\n\n            let version = '';\n            let versionDate = '';\n            \n            if (packageInfoBot && packageInfoBot.tags.version) {\n                version = packageInfoBot.raw.version;\n                versionDate = packageInfoBot.tags.versionDate ? packageInfoBot.tags.versionDate.toLocaleString(DateTime.DATETIME_MED_WITH_SECONDS) : '';\n            }\n\n\n            const onPublishSelected = () => {\n                console.log(`onPublishSelected`, name);\n                setPublishId(name);\n            }\n\n            return (\n                <PackageTableRow\n                    name={name}\n                    version={version}\n                    versionDate={versionDate}\n                    onVersionBumped={onVersionBumped}\n                    onUnloaded={onUnloaded}\n                    onPublishSelected={onPublishSelected}\n                ></PackageTableRow>\n            )\n        })\n\n        return rows;\n    }, [updateId]);\n    \n    const onClose = useCallback(() => {\n        thisBot.unmount();\n    }, []);\n\n    return (\n        <>\n            <style>{css}</style>\n\n            <AppContainer id='rc-app-packages' onBackgroundClick={onBackgroundClick}>\n                <Window>\n                    <p><TextLink onClick={onClose}>{'x Close'}</TextLink></p>\n                    <h2>Loaded Packages {`(${os.getCurrentInst()})`}</h2>\n                    <PackageTable>\n                        {packageTableRows}\n                    </PackageTable>\n                </Window>\n                { publishId &&\n                    <PublishWindow\n                        name={publishId}\n                        onClose={() => setPublishId(null)}\n                    ></PublishWindow>\n                }\n            </AppContainer>\n        </>\n    )\n}\n\nreturn App;\n",
        "forceUpdate": "@const App = thisBot.vars.appInstance;\n\nif (App) {\n    os.compileApp(tags.system, <App/>)\n}\n",
        "mount": "@if (!thisBot.vars.appInstance) {\n    thisBot.vars.appInstance = thisBot.App();\n    await os.registerApp(tags.system, thisBot);\n\n    thisBot.forceUpdate();\n}\n",
        "onBotAdded": "@if (!globalThis.rcdev) {\n    globalThis.rcdev = {};\n}\n\nrcdev.packagesApp = thisBot;",
        "onDestroy": "@thisBot.unmount();\n\nif (globalThis.rcdev) {\n    rcdev.packagesApp = undefined;\n}",
        "style.css": ".package-table {\n    font-size: 16px;\n    font-family: monospace;\n}\n\n.package-table table {\n    width: 100%\n}\n\n.package-table th {\n    text-align: left;\n}\n\n.package-table tr:nth-child(even) {\n    background-color: rgb(56, 69, 56);\n}\n\n.package-action-container {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n}\n\n.package-action {\n    border: none;\n    background-color: transparent;\n    user-select: none;\n    font-size: 1em;\n    padding: 2px;\n    line-height: 1.3em;\n    border-radius: 4px;\n    margin: 0;\n}\n\n.package-action:hover {\n    background-color: rgb(0 192 255);\n    cursor: pointer;\n}\n\n.package-select {\n    background-color: #262626;\n    color: white;\n    font-family: monospace;\n    font-size: 1.1em;\n    padding: 0.15em;\n}\n\n.package-select:hover {\n    cursor: pointer;\n}\n\n.package-button {\n    background-color: #505050;\n    color: white;\n    font-family: monospace;\n    font-size: 1.1em;\n    padding: 0.15em 1em;\n}\n\n.package-button:hover {\n    background-color: #474747;\n    cursor: pointer;\n}",
        "system": "rc-package-dev.apps.packagesApp",
        "unmount": "@if (thisBot.vars.appInstance) {\n    delete thisBot.vars.appInstance;\n\n    // Compiling the app with an empty root value is a workaround that allows the\n    // previous components to perform their unmounting code properly.\n    await os.compileApp(tags.system, <></>);\n\n    await os.unregisterApp(tags.system);\n}\n"
      }
    },
    "rc-package-dev.codeButtons.copyBot": {
      "id": "rc-package-dev.codeButtons.copyBot",
      "space": "shared",
      "tags": {
        "form": "codeButton",
        "label": "Copy Bot To Clipboard",
        "onClick": "@let selectedBot = configBot.links.systemPortalBot;\nif (!selectedBot) {\n    selectedBot = configBot.links.editingBot;\n}\n\nif (selectedBot) {\n    let aux = {\n        version: 1,\n        state: {\n            [selectedBot.id]: selectedBot\n        }\n    }\n\n    os.setClipboard(JSON.stringify(aux));\n\n    let botDisplayName = selectedBot.tags.system;\n    if (!botDisplayName) {\n        botDisplayName = selectedBot.id.substring(0, 5);\n    }\n\n    rcdev.logAndToast(`${botDisplayName} copied to clipboard.`);\n} else {\n    rcdev.warnAndToast(`Nothing copied to clipboard. Could not find selected bot.`);\n}",
        "system": "rc-package-dev.codeButtons.copyBot",
        "true": "true"
      }
    },
    "rc-package-dev.codeButtons.renameTag": {
      "id": "rc-package-dev.codeButtons.renameTag",
      "space": "shared",
      "tags": {
        "form": "codeButton",
        "label": "Rename Tag",
        "onClick": "@let selectedBot = configBot.links.systemPortalBot;\nif (!selectedBot) {\n    selectedBot = configBot.links.editingBot;\n}\n\nlet selectedTag = configBot.tags.systemPortalTag;\nif (!selectedTag) {\n    selectedTag = configBot.tags.editingTag;\n}\n\nif (!selectedBot || !selectedTag) {\n    return;\n}\n\nconst input = await os.showInput(selectedTag, { title: 'Rename Tag', autoSelect: true });\n\nif (input && input !== selectedTag) {\n    const value = selectedBot.tags[selectedTag];\n\n    let performOperation = true;\n    const otherValue = selectedBot.tags[input];\n    const hasOtherTag = otherValue !== undefined && otherValue !== null && otherValue !== '';\n\n    if (hasOtherTag) {\n        performOperation = await os.showConfirm({\n            title: 'Overwrite Tag?',\n            content: `There is already a tag named ${input}, do you want to overwrite it?`,\n            confirmText: 'Yes',\n            cancelText: 'No'\n        });\n    }\n\n    if (performOperation) {\n        selectedBot.tags[input] = value; // Write value to other tag.\n        selectedBot.tags[selectedTag] = null; // Remove old tag.\n        configBot.tags.systemPortalTag = input; // Select other tag.\n    }\n}",
        "system": "rc-package-dev.codeButtons.renameTag",
        "true": "true"
      }
    },
    "rc-package-dev.command": {
      "id": "rc-package-dev.command",
      "space": "shared",
      "tags": {
        "cmdBackup": "@/**@type {string[]} */\nlet args = that;\n\nlet name;\nlet inst;\nlet star;\n\nif (args && args.length) {\n    const nameIndex = args.findIndex(arg => arg === '-n');\n    if (nameIndex >= 0) {\n        name = args[nameIndex + 1];\n        args.splice(nameIndex, 2);\n    }\n\n    const instIndex = args.findIndex(arg => arg === '-inst');\n    if (instIndex >= 0) {\n        inst = true;\n        args.splice(instIndex, 1);\n    }\n\n    const starIndex = args.findIndex(arg => arg === '*');\n    if (starIndex >= 0) {\n        star = true;\n        args.splice(starIndex, 1);\n    }\n\n    if (star && inst) {\n        throw new Error('[backup] Cannot use both * and -inst in backup command, they are mutually exclusive.');\n    }\n}\n\nif (inst) {\n    exporter.downloadInst({ name });\n} else if (star) {\n    exporter.downloadPackages({ name });\n} else if (args && args.length) {\n    exporter.downloadPackages({ name, ...args });\n} else {\n    exporter.downloadBundle({ name });\n}",
        "cmdBumpVersion": "@const args = that;\n\nif (!args) {\n    return;\n}\n\n// Get the bump type.\nlet bumpType = 'minor';\n\nconst bumpTypeArgIndex = args.findIndex(a => a === '-major' || a === '-minor');\nif (bumpTypeArgIndex >= 0) {\n    const bumpTypeArgValue = args[bumpTypeArgIndex];\n\n    if (bumpTypeArgValue === '-minor') {\n        bumpType = 'minor';\n    } else if (bumpTypeArgValue === '-major') {\n        bumpType = 'major';\n    } else {\n        rcdev.logAndToast(`[${tags.system}] [bumpVersion] unknown bump type arg ${arg}`);\n    }\n\n    args.splice(bumpTypeArgIndex, 1);\n}\n\nconst packages = thisBot.parsePackageArgs(args);\n\nfor (let key in packages) {\n    packageInfo.bumpVersion({ name: key, bumpType });\n}",
        "cmdCreateAppBot": "@const args = that;\n\nif (!args || args.length === 0) {\n    rcdev.errorAndToast('Error: createappbot requires system tag argument.');\n    return;\n}\n\nconst system = args[0];\n\nconst appBot = create({\n    space: 'shared',\n    system,\n    Introduction: \n`@const Introduction = ({ appName }) => {\n    return (\n        <div className='introduction'>\n            <h1>Hello, World!</h1>\n            <p>This is your new custom app! You can find your new app bot in the system portal under the name \"{appName}\".\\\\nRefer to the createappbot help for more information on how each tag and listener in this boilerplate app works.</p>\n        </div>\n    )\n}\n\nreturn Introduction;\n`,\n    App:\n`@const { useState, useCallback } = os.appHooks;\n\nconst Introduction = thisBot.Introduction();\n        \nconst App = () => {\n    const [ clickCount, setClickCount ] = useState(0);\n\n    const onClickerClick = useCallback(() => {\n        setClickCount(clickCount + 1);\n    }, [clickCount, setClickCount]);\n\n    const onUnmountClick = useCallback(() => {\n        thisBot.unmount();\n    }, []);\n\n    return (\n        <>\n            <style>{tags['style.css']}</style>\n            <div className='custom-app'>\n                <Introduction appName={tags.system} />\n                <button onClick={onClickerClick}>Click</button>\n                <span>Click Count: {clickCount}</span>\n                <br/><br/>\n                <button onClick={onUnmountClick}>Unmount App</button>\n            </div>\n        </>\n    )\n}\n\nreturn App;\n`,\n    mount: \n`@if (!thisBot.vars.appInstance) {\n    thisBot.vars.appInstance = thisBot.App();\n    await os.registerApp(tags.system, thisBot);\n\n    thisBot.forceUpdate();\n}\n`,\n    unmount: \n`@if (thisBot.vars.appInstance) {\n    delete thisBot.vars.appInstance;\n\n    // Compiling the app with an empty root value is a workaround that allows the\n    // previous components to perform their unmounting code properly.\n    await os.compileApp(tags.system, <></>);\n\n    await os.unregisterApp(tags.system);\n}\n`,\n    forceUpdate: \n`@const App = thisBot.vars.appInstance;\n\nif (App) {\n    os.compileApp(tags.system, <App/>)\n}\n`,\n    'style.css': \n`.custom-app {\n    background-color: white;\n    padding: 12px;\n}\n\n.introduction p {\n    white-space: pre-line;\n}\n`,\n    onDestroy: `@thisBot.unmount();`\n});\n\n// Automatically mount the app after running the command.\nappBot.mount();\n\nrcdev.logAndToast(`Created ${system} app bot.`);\n",
        "cmdFilesUpload": "@const args = that;\n\n// Parse -studio arg.\nconst studio = rcdev.parseArgValue(args, '-studio');\n\nconst selectedFiles = await os.showUploadFiles();\nconst publishRecord = getBot('system', 'rc-package-dev.publishRecord');\n\nif (selectedFiles && selectedFiles.length) {\n    if (tags.debug) {\n        console.log(`[${tags.system}.${tagName}] Upload ${selectedFiles.length} files...`);\n    }\n\n    let doneHtml = '';\n\n    if (studio) {\n        doneHtml += `<h2>Studio Id</h2>`;\n        doneHtml += `<p>${studio}</p>`;\n    }\n\n    doneHtml += '<h2>Uploaded Files</h2>';\n    \n    for (let i = 0; i < selectedFiles.length; i++) {\n        os.showHtml(`Uploading ${selectedFiles[i].name}...`);\n        \n        const result = await publishRecord.uploadFile({\n            file: selectedFiles[i],\n            studio,\n            onProgress: (fileProgress) => {\n                os.showHtml(`Uploading ${selectedFiles[i].name} ${Math.ceil(fileProgress * 100)}%`);\n            }\n        });\n        \n        if (result.url) {\n            doneHtml += `<a href=\"${result.url}\" target=\"_blank\">${selectedFiles[i].name}</a></br>`;\n        }\n\n        console.log(`[${tags.system}.${tagName}] Upload ${selectedFiles[i].name} result:`, result);\n    }\n\n    os.showHtml(doneHtml);\n}",
        "cmdGithub": "@const args = that;\n\nif (!args || args.length === 0) {\n    rcdev.errorAndToast('github requires some parameters, check the docs with $help github');\n    return;\n}\n\nconst pushFlag = rcdev.parseArgFlag(args, '-push');\nconst pullFlag = rcdev.parseArgFlag(args, '-pull');\nconst setupFlag = rcdev.parseArgFlag(args, '-setup');\n\nif (pullFlag) {\n    rcdev.errorAndToast('-pull is not supported yet');\n    return;\n}\n\nif (pushFlag && pullFlag) {\n    rcdev.errorAndToast('Cannot use push and pull at the same time.');\n    return;\n}\n\nconst SETUP_INPUT_CONFIGS = [\n    {\n        name: 'username',\n        storeKey: `rc-package-dev::${crypto.hash('sha1', 'base64', 'username')}`,\n        title: 'GitHub Username',\n    },\n    {\n        name: 'repo',\n        storeKey: `rc-package-dev::${crypto.hash('sha1', 'base64', 'repo')}}`,\n        title: 'GitHub Repo',\n    },\n    {\n        name: 'branch',\n        storeKey: `rc-package-dev::${crypto.hash('sha1', 'base64', 'branch')}}`,\n        title: 'GitHub Branch',\n    },\n    {\n        name: 'rootPath',\n        storeKey: `rc-package-dev::${crypto.hash('sha1', 'base64', 'rootPath')}}`,\n        title: 'GitHub Package Root Path',\n    },\n    {\n        name: 'token',\n        storeKey: `rc-package-dev::${crypto.hash('sha1', 'base64', 'token')}}`,\n        title: 'GitHub Personal Token',\n    },\n];\n\nconst RECORD_ADDRESS = 'rc-package-dev-github';\nconst playerRecordKey = globalThis.authBot ? authBot.id : null;\n\nif (!playerRecordKey) {\n    rcdev.errorAndToast('Could not find authBot to get player record key.');\n    return;\n}\n\nasync function getRecordData() {\n    let getDataResult = await os.getData(playerRecordKey, RECORD_ADDRESS);\n\n    if (!getDataResult.success && getDataResult.errorCode === 'not_authorized') {\n        await os.grantInstAdminPermission(playerRecordKey);\n        getDataResult = await os.getData(playerRecordKey, RECORD_ADDRESS);\n    }\n\n    let recordData;\n\n    if (getDataResult.success) {\n        recordData = getDataResult.data;\n    } else {\n        if (getDataResult.errorCode === 'data_not_found') {\n            recordData = {};\n        } else {\n            throw new Error(`Failed to get github record. Error code: ${getDataResult.errorCode}`);\n        }\n    }\n\n    return recordData;\n}\n\nasync function setupSettings() {\n    const recordData = await getRecordData();\n    let changed = false;\n    \n    for (let inputConfig of SETUP_INPUT_CONFIGS) {\n        let value = recordData[inputConfig.storeKey];\n        let input = await os.showInput(value, { autoSelect: false, title: inputConfig.title });\n\n        if (input !== value) {\n            recordData[inputConfig.storeKey] = input;\n            changed = true;\n        }\n    }\n\n    if (changed) {\n        let recordResult = await os.recordData(playerRecordKey, RECORD_ADDRESS, recordData, { marker: 'secret' });\n\n        if (!recordResult.success && recordResult.errorCode === 'not_authorized') {\n            await os.grantInstAdminPermission(playerRecordKey);\n            recordResult = await os.recordData(playerRecordKey, RECORD_ADDRESS, recordData, { marker: 'secret' });\n        }\n\n        \n        if (recordResult.success) {\n            rcdev.logAndToast('GitHub settings saved.');\n        } else {\n            rcdev.errorAndToast('Failed to save Github settings.');\n        }\n    }\n}\n\nasync function getSettings() {\n    const recordData = await getRecordData();\n\n    const settings = {};\n\n    for (let inputConfig of SETUP_INPUT_CONFIGS) {\n        settings[inputConfig.name] = recordData[inputConfig.storeKey];\n    }\n\n    return settings;\n}\n\nif (setupFlag) {\n    await setupSettings();\n}\n\n// This function should be called within a web worker.\nasync function commitFileToGitHub(username, repo, path, message, blob, token) {\n    const url = `https://api.github.com/repos/${username}/${repo}/contents/${path}`;\n    const headers = {\n        'Authorization': `token ${token}`,\n        'Content-Type': 'application/json',\n    };\n\n    // Convert the blob to base64\n    const base64Content = await new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = () => resolve(reader.result.split(',')[1]);\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n    });\n\n    // Get the SHA and content of the existing file, if it exists\n    let sha = null;\n    try {\n        const response = await self.fetch(url, { headers });\n        if (response.ok) {\n            const data = await response.json();\n            sha = data.sha;\n\n            // Compare the new content with the existing content\n            if (data.content.replace(/\\n/g, '') === base64Content) {\n                rcdev.logAndToast(`No changes to commit for ${username}/${repo}/${path}`);\n                return { status: 'unchanged', data };\n            }\n        }\n    } catch (error) {\n        rcdev.errorAndToast('Error fetching existing file:', error);\n    }\n\n    // Create the request body\n    const body = JSON.stringify({\n        message,\n        content: base64Content,\n        sha,\n    });\n\n    // Commit the file to the repository\n    try {\n        const response = await self.fetch(url, {\n            method: 'PUT',\n            headers,\n            body,\n        });\n        if (!response.ok) {\n            throw new Error(`GitHub API returned status ${response.status}`);\n        }\n\n        rcdev.logAndToast(`Commited ${username}/${repo}/${path}`);\n        return await response.json();\n    } catch (error) {\n        rcdev.errorAndToast('Error committing file:', error);\n        throw error;\n    }\n}\n\nfunction combinePaths(path1, path2) {\n    // Ensure the first path ends with a slash\n    if (!path1.endsWith('/')) {\n        path1 += '/';\n    }\n\n    // Remove leading slash from the second path if it exists\n    if (path2.startsWith('/')) {\n        path2 = path2.substring(1);\n    }\n\n    // Combine the two paths\n    return path1 + path2;\n}\n\nif (pushFlag || pullFlag) {\n    const settings = await getSettings();\n    const packageArgCount = args.length;\n    const packages = exporter.getBotPackages(args);\n    const packageCount = Object.keys(packages).length;\n    \n\n    if (packageArgCount !== packageCount) {\n        rcdev.errorAndToast(`Could not find ${packageArgCount - packageCount} package(s).`);\n    }\n\n    if (packages && packageCount > 0) {\n        if (pushFlag) {\n            let commitedCount = 0;\n\n            for (let packageName in packages) {\n                const bots = packages[packageName];\n                exporter.sortBotsBySystemTag({ bots });\n                const aux = exporter.botsToAUX({ bots });\n                let packageInfoBot = packages[packageName].find(b => b.tags.system.endsWith('._packageInfo'));\n                let packageVersion = null;\n\n                if (packageInfoBot && packageInfoBot.tags.version != null) {\n                    packageVersion = packageInfoBot.tags.version;\n                }\n\n                const blob = new Blob([JSON.stringify(aux, undefined, 2)], { type: 'application/json' });\n                const path = combinePaths(settings.rootPath, `${packageName}/${packageName}.aux`);\n\n                let message = `Commit ${packageName}`;\n                if (packageVersion) {\n                    message += ` v${packageVersion}`;\n                }\n\n                await commitFileToGitHub(settings.username, settings.repo, path, message, blob, settings.token);\n                commitedCount++;\n            }\n\n            rcdev.logAndToast(`GitHub commit(s) finished. Commited ${commitedCount}/${packageArgCount} package(s).`);\n        } else if (pullFlag) {\n            rcdev.warnAndToast('TODO: pull ' + packageName);\n        }\n\n    } else {\n        rcdev.logAndToast(`None of the specified packages were found.`);\n    }\n}\n",
        "cmdIDE": "@const args = that;\n\nconst url = new URL(configBot.tags.url);\n\n// Remove any portals that are set in the URL.\nlet params = url.searchParams.keys();\nfor (let param of params) {\n    if (param.endsWith('Portal')) {\n        url.searchParams.delete(param);\n    }\n}\n\n// Turn on the system portal.\nurl.searchParams.delete('systemTagName');\nurl.searchParams.set('systemPortal', 'true');\nurl.searchParams.set('theme', 'dark');\n\nos.openURL(url.href);",
        "cmdInstUpdates": "@const args = that;\n\nlet logUpdates = false;\n\nif (args) {\n    logUpdates = args.includes('-l');\n}\n\nfunction roughSizeOfObject(object) {\n    var objectList = [];\n    var stack = [ object ];\n    var bytes = 0;\n\n    while (stack.length) {\n        var value = stack.pop();\n\n        if (typeof value === 'boolean') {\n            bytes += 4;\n        }\n        else if (typeof value === 'string') {\n            bytes += value.length * 2;\n        }\n        else if (typeof value === 'number') {\n            bytes += 8;\n        }\n        else if (typeof value === 'object'\n                && objectList.indexOf(value) === -1)\n        {\n            objectList.push(value);\n\n            for(var i in value) {\n                stack.push(value[i]);\n            }\n        }\n    }\n\n    return bytes;\n}\n\nfunction formatBytes(bytes, decimals = 2) {\n    if (bytes === 0) return '0 Bytes';\n\n    const k = 1024;\n    const dm = decimals < 0 ? 0 : decimals;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];\n\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];\n}\n\nrcdev.logAndToast('Fetching inst updates...');\nconst updates = await os.listInstUpdates();\nconst sizeEstimateBytes = roughSizeOfObject(updates);\n\nlet message = '';\nmessage += `Inst update count: ${updates.length}\\n`;\nmessage += `Inst size estimate: ${formatBytes(sizeEstimateBytes)}.`;\n\nif (masks.prevInstUpdateCount != null) {\n    const diffCount = updates.length - masks.prevInstUpdateCount;\n    const diffSizeBytes = sizeEstimateBytes - masks.prevInstUpdateSizeBytes;\n    message += '\\n\\n';\n    message += `${diffCount} new updates since last checked.\\n`;\n    message += `${formatBytes(diffSizeBytes)} estimated size increase since last checked.`;\n}\n\nif (logUpdates) {\n    message += '\\n    \\n';\nmessage += `The inst updates have been logged to the browser's developer console.`;\n}\n\nconsole.log(message);\n\nif (logUpdates) {\n    console.log('Inst updates:', updates);\n}\n\nos.showHtml('<p style=\"white-space: pre; margin: 0; padding: 8px\">' + message + '</p>');\n\nmasks.prevInstUpdateCount = updates.length;\nmasks.prevInstUpdateSizeBytes = sizeEstimateBytes;",
        "cmdPkgPublish": "@let args = that;\n\n// Parse --studio and --branch args.\nconst studio = rcdev.parseArgValue(args, '--studio');\nconst branch = rcdev.parseArgValue(args, '--branch');\n\nconst packages = thisBot.parsePackageArgs(args);\n\nfor (let key in packages) {\n    try {\n        rcdev.logAndToast(`[${tags.system}] Publishing ${key}${branch ? `-${branch}` : ''}...`);\n        const publishRecord = getBot('system', 'rc-package-dev.publishRecord');\n        await publishRecord.publishPackage({ \n            name: key,\n            secret: packages[key].secret,\n            isPrivate: packages[key].private,\n            branch,\n            studio,\n        });\n    } catch (e) {\n        rcdev.logAndToast(`[${tags.system}] Publish error. See console for more details.`);\n        console.error(`[${tags.system}] Publish error:`, e);\n        return;\n    }\n}\n\nrcdev.logAndToast(`[${tags.system}] Publishing complete!`);",
        "cmdPkgUnload": "@const args = that;\n\nif (!args || args.length === 0) {\n    \n}\nconst packages = thisBot.parsePackageArgs(args);\n\nfor (let name in packages) {\n    const packages = exporter.getBotPackages(name);\n    let bots = [];\n\n    if (packages && packages[name]) {\n        bots = packages[name];\n        destroy(bots);\n    }\n\n    console.log(`[${tags.system}.${tagName}] unloaded package ${name}. Destroyed ${bots.length} bots.`);\n}\n",
        "cmdSheet": "@const args = that;\n\nlet portal;\nlet newTab = false;\n\nif (args) {\n    for (let i = 0; i < args.length; i++) {\n        const arg = args[i];\n        if (arg.startsWith('-')) {\n            if (arg === '-t') {\n                newTab = true;\n            }\n        } else if (!portal) {\n            portal = arg;\n        }\n    }\n}\n\nif (!portal) {\n    portal = os.getCurrentDimension();\n}\n\nconst helperBots = {\n    'configBot': configBot,\n    'gridPortalBot': gridPortalBot,\n    'sheetPortalBot': sheetPortalBot,\n    'systemPortalBot': systemPortalBot,\n    'miniGridPortalBot': miniGridPortalBot,\n    'mapPortalBot': mapPortalBot,\n    'miniMapPortalBot': miniMapPortalBot,\n    'menuPortalBot': menuPortalBot,\n    'leftWristPortalBot': leftWristPortalBot,\n    'rightWristPortalBot': rightWristPortalBot,\n    'meetPortalBot': meetPortalBot,\n    'tagPortalBot': tagPortalBot,\n    'imuPortalBot': imuPortalBot,\n};\n\n// Function to resolve a portal reference to a specific bot\nfunction resolvePortalToBot(path) {\n    if (!path || path === '') return null;\n    \n    // First check if it's directly in helperBots\n    if (helperBots[path]) {\n        return helperBots[path];\n    }\n\n    // Perhaps the path is a bot id.\n    let botFromIdSearch = getBot('id', path);\n    if (botFromIdSearch) {\n        return botFromIdSearch;\n    }\n    \n    // Check for both direct and nested paths in globalThis\n    let pathParts = path.split('.');\n    let currentObj = globalThis;\n    let startIndex = 0;\n    \n    // Handle if the path explicitly starts with 'globalThis'\n    if (pathParts[0] === 'globalThis') {\n        startIndex = 1; // Skip the 'globalThis' part since we're already starting there\n    }\n    \n    // Traverse the path\n    for (let i = startIndex; i < pathParts.length; i++) {\n        const part = pathParts[i];\n        if (!currentObj[part]) {\n            return null; // Path segment doesn't exist\n        }\n        currentObj = currentObj[part];\n    }\n    \n    // Check if the final object is a bot (has id and tags)\n    if (currentObj && currentObj.id && currentObj.tags) {\n        return currentObj;\n    }\n    \n    return null; // Not a valid bot\n}\n\n// Search to see if portal argument is specific to a bot\nlet uniqueBot = resolvePortalToBot(portal);\n\nif (uniqueBot) {\n    if (uniqueBot.tags.space === 'tempLocal' ||\n        uniqueBot.tags.space === 'tempShared'\n    ) {\n        // Force sheet to open in same tab if the bot only lives in this tab.\n        newTab = false;\n    }\n    portal = uniqueBot.id;\n}\n\nif (newTab) {\n    os.openURL(`/?inst=${os.getCurrentInst()}&sheetPortal=${portal}`);\n} else {\n    configBot.tags.sheetPortal = portal;\n}",
        "cmdTransform": "@const args = that;\n\n// let selectedBotId = null;\n\n// if (args && args.length) {\n//     selectedBotId = args[0];\n\n//     if (selectedBotId) {\n//         // Confirm that the given bot id exists.\n//         const exists = !!getBot('id', selectedBotId);\n\n//         if (!exists) {\n//             rcdev.warnAndToast(`[tags.system] ${selectedBotId} is not a valid bot id`);\n//             selectedBotId = null;\n//         }\n//     }\n// }\n\nlet controller = getBot('rcTransformController', true);\n\nif (controller) {\n    destroy(controller);\n}\n\nconst App = `@\n    const { useState, useEffect, useCallback } = os.appHooks;\n\n    const App = () => {\n\n        const bot = links.selectedBot;\n        const dim = tags.selectedBotDimension;\n        const inputStep = 0.1;\n\n        const onInput = (event) => {\n            let changed = true;\n\n            switch (event.currentTarget.id) {\n                case 'pos-x':\n                    bot.tags[dim + 'X'] = event.currentTarget.value;\n                    break;\n                case 'pos-y':\n                    bot.tags[dim + 'Y'] = event.currentTarget.value;\n                    break;\n                case 'pos-z':\n                    bot.tags[dim + 'Z'] = event.currentTarget.value;\n                    break;\n\n                case 'rot-x':\n                    bot.tags[dim + 'RotationX'] = event.currentTarget.value;\n                    break;\n                case 'rot-y':\n                    bot.tags[dim + 'RotationY'] = event.currentTarget.value;\n                    break;\n                case 'rot-z':\n                    bot.tags[dim + 'RotationZ'] = event.currentTarget.value;\n                    break;\n\n                case 'scale-x':\n                    bot.tags['scaleX'] = event.currentTarget.value;\n                    break;\n                case 'scale-y':\n                    bot.tags['scaleY'] = event.currentTarget.value;\n                    break;\n                case 'scale-z':\n                    bot.tags['scaleZ'] = event.currentTarget.value;\n                    break;\n                default: \n                    changed = false;\n                    break;\n            }\n\n            if (changed) {\n                tags.ignoreNextChangeCheck = true;\n            }\n        }\n\n        const onCopy = (event) => {\n            switch(event.currentTarget.id) {\n                case 'copy-pos':\n                    let pos = {\n                        x: bot.tags[dim + 'X'] ?? null,\n                        y: bot.tags[dim + 'Y'] ?? null,\n                        z: bot.tags[dim + 'Z'] ?? null\n                    }\n                    os.toast('Copied position to clipboard');\n                    thisBot.vars.clipboard = pos;\n                    os.setClipboard(JSON.stringify(pos));\n                    break;\n                case 'copy-rot':\n                    let rot = {\n                        x: bot.tags[dim + 'RotationX'] ?? null,\n                        y: bot.tags[dim + 'RotationY'] ?? null,\n                        z: bot.tags[dim + 'RotationZ'] ?? null\n                    }\n                    os.toast('Copied rotation to clipboard');\n                    thisBot.vars.clipboard = rot;\n                    os.setClipboard(JSON.stringify(rot));\n                    break;\n                case 'copy-scale':\n                    let scale = {\n                        x: bot.tags['scaleX'] ?? null,\n                        y: bot.tags['scaleY'] ?? null,\n                        z: bot.tags['scaleZ'] ?? null\n                    }\n                    os.toast('Copied scale to clipboard');\n                    thisBot.vars.clipboard = scale;\n                    os.setClipboard(JSON.stringify(scale));\n                    break;\n            }\n        }\n\n        const onPaste = (event) => {\n            const clipboard = thisBot.vars.clipboard;\n\n            if (!clipboard) {\n                // Nothing in the bot's clipboard.\n                return;\n            }\n\n            switch(event.currentTarget.id) {\n                case 'paste-pos':\n                    bot.tags[dim + 'X'] = clipboard.x;\n                    bot.tags[dim + 'Y'] = clipboard.y;\n                    bot.tags[dim + 'Z'] = clipboard.z;\n                    os.toast('Pasted values to position');\n                    break;\n                case 'paste-rot':\n                    bot.tags[dim + 'RotationX'] = clipboard.x;\n                    bot.tags[dim + 'RotationY'] = clipboard.y;\n                    bot.tags[dim + 'RotationZ'] = clipboard.z;\n                    os.toast('Pasted values to rotation');\n                    break;\n                case 'paste-scale':\n                    bot.tags['scaleX'] = clipboard.x;\n                    bot.tags['scaleY'] = clipboard.y;\n                    bot.tags['scaleZ'] = clipboard.z;\n                    os.toast('Pasted values to scale');\n                    break;\n            }\n        }\n\n        const onClose = () => {\n            destroy(thisBot);\n        }\n\n        const Controls = () => {\n            if (bot && dim) {\n                return (\n                    <div>\n                        <div className='bot-info'>\n                            <p><b>id:</b> {bot.id}</p>\n                            <p><b>space:</b> {bot.space}</p>\n                            <p><b>system:</b> {bot.system ?? 'null'}</p>\n                            <p><b>dimension:</b> {dim}</p>\n                        </div>\n\n                        <div className='position xyz'>\n                            <h2>Position</h2>\n                            <label for='pox-x'>X:</label>\n                            <input \n                                id='pos-x'\n                                name='pos-x'\n                                type='number'\n                                value={bot.tags[dim + 'X']}\n                                step={inputStep}\n                                onInput={onInput}\n                            ></input>\n                            <label for='pox-y'>Y:</label>\n                            <input \n                                id='pos-y'\n                                name='pos-y'\n                                type='number'\n                                value={bot.tags[dim + 'Y']}\n                                step={inputStep}\n                                onInput={onInput}\n                            ></input>\n                            <label for='pox-z'>Z:</label>\n                            <input \n                                id='pos-z'\n                                name='pos-z'\n                                type='number'\n                                value={bot.tags[dim + 'Z']}\n                                step={inputStep}\n                                onInput={onInput}\n                            ></input>\n                            <button title=\"Copy position\" id='copy-pos' onClick={onCopy}>C</button>\n                            <button title=\"Paste position\"id='paste-pos' onClick={onPaste}>P</button>\n                        </div>\n\n                        <div className='rotation xyz'>\n                            <h2>Rotation</h2>\n                            <label for='rot-x'>X:</label>\n                            <input \n                                id='rot-x'\n                                name='rot-x'\n                                type='number'\n                                value={bot.tags[dim + 'RotationX']}\n                                step={inputStep}\n                                onInput={onInput}\n                            ></input>\n                            <label for='rot-y'>Y:</label>\n                            <input \n                                id='rot-y'\n                                name='rot-y'\n                                type='number'\n                                value={bot.tags[dim + 'RotationY']}\n                                step={inputStep}\n                                onInput={onInput}\n                            ></input>\n                            <label for='rot-z'>Z:</label>\n                            <input \n                                id='rot-z'\n                                name='rot-z'\n                                type='number'\n                                value={bot.tags[dim + 'RotationZ']}\n                                step={inputStep}\n                                onInput={onInput}\n                            ></input>\n                            <button title=\"Copy rotation\" id='copy-rot' onClick={onCopy}>C</button>\n                            <button title=\"Paste rotation\" id='paste-rot' onClick={onPaste}>P</button>\n                        </div>\n\n                        <div className='scale xyz'>\n                            <h2>Scale</h2>\n                            <label for='scale-x'>X:</label>\n                            <input \n                                id='scale-x'\n                                name='scale-x'\n                                type='number'\n                                value={bot.tags['scaleX']}\n                                step={inputStep}\n                                onInput={onInput}\n                            ></input>\n                            <label for='scale-y'>Y:</label>\n                            <input \n                                id='scale-y'\n                                name='scale-y'\n                                type='number'\n                                value={bot.tags['scaleY']}\n                                step={inputStep}\n                                onInput={onInput}\n                            ></input>\n                            <label for='scale-z'>Z:</label>\n                            <input \n                                id='scale-z'\n                                name='scale-z'\n                                type='number'\n                                value={bot.tags['scaleZ']}\n                                step={inputStep}\n                                onInput={onInput}\n                            ></input>\n                            <button title=\"Copy scale\" id='copy-scale' onClick={onCopy}>C</button>\n                            <button title=\"Paste scale\" id='paste-scale' onClick={onPaste}>P</button>\n                        </div>\n                    </div>\n                )\n            } else {\n                return (\n                    <p>Click on a bot to select it.</p>\n                )\n            }\n        }\n\n        return (\n            <>\n                <style>{tags.style}</style>\n                <div className='transform-app'>\n                    <div className='header'>\n                        <button onClick={onClose}>Close</button>\n                        <h1>Transform</h1>\n                    </div>\n                    <Controls/>\n                </div>\n            </>\n        )\n    }\n\n    return App;\n;`\n\nconst style = `\n    .transform-app {\n        position: fixed;\n        bottom: 0;\n        left: 0;\n        background-color: #2f2f2f;\n        color: white;\n        padding: 12px;\n        border-style: solid solid none none;\n        border-radius: 0 4px 0 0;\n        border-width: 4px;\n        border-color: #1c1c1c;\n        z-index: 100;\n    }\n\n    .transform-app .header button {    \n        width: 100%;\n        margin-top: 4px;\n    }\n\n    .transform-app .bot-info p {\n        margin: 0;\n    }\n\n    .transform-app h1 {\n        font-size: 1.4em;\n    }\n\n    .transform-app h2 {    \n        font-size: 1.15em;\n        margin-bottom: 0.33em;\n    }\n\n    .transform-app .xyz {\n\n    }\n\n    .transform-app .xyz label {\n        font-weight: bold;\n    }\n\n    .transform-app .xyz input {\n        width: 90px;\n        background-color: #1d1d1d;\n        color: white;\n    }\n`;\n\ncontroller = create({\n    space: 'tempLocal',\n    rcTransformController: true,\n    appId: uuid(),\n    App,\n    style,\n    onBotAdded: `@\n        // Mount app.\n        await os.registerApp(tags.appId, thisBot);\n\n        const App = thisBot.App();\n        thisBot.vars.appInstance = App;\n\n        thisBot.forceUpdateApp();\n    `,\n    onDestroy: `@\n        delete thisBot.vars.appInstance;\n        \n        await os.compileApp(tags.appId, <></>);\n        await os.unregisterApp(tags.appId);\n    `,\n    forceUpdateApp: `@\n        const App = thisBot.vars.appInstance;\n\n        if (App) {\n            await os.compileApp(tags.appId, <App/>);\n        }\n    `,\n    selectBot: `@\n        const { bot, dimension } = that;\n\n        assert(bot, '[transform] bot is a required parameter.');\n        assert(dimension, '[transform] dimension is a required parameter.');\n\n        links.selectedBot = bot;\n        tags.selectedBotDimension = dimension;\n\n        thisBot.forceUpdateApp();\n    `,\n    clearSelection: `@\n        links.selectedBot = null;\n        tags.selectedBotDimension = null;\n\n        thisBot.forceUpdateApp();\n    `,\n    onAnyBotClicked: `@\n        const { bot, dimension } = that;\n\n        thisBot.selectBot({ bot, dimension });\n    `,\n    onAnyBotsChanged: `@\n        for (let changed of that) {\n            const changedBot = changed.bot;\n            const changedTags = changed.tags;\n\n            if (links.selectedBot && changedBot === links.selectedBot) {\n                if (tags.ignoreNextChangeCheck) {\n                    tags.ignoreNextChangeCheck = false;\n                } else {\n                    thisBot.forceUpdateApp();\n                }\n            }\n        }\n    `,\n    onAnyBotsRemoved: `@\n        const { botIDs } = that;\n\n        if (!links.selectedBot || botIDs.includes(links.selectedBot.id)) {\n            thisBot.clearSelection();\n        }\n    `,\n    onGridClick: `@\n        thisBot.clearSelection();\n    `,\n})\n\n",
        "initialize": "@if (masks.initialized) {\n    return;\n}\n\nmasks.initialized = true;\n\n/**\n * @typedef {object} CommandHelp\n * @prop {string} shortDescription Short description of the command.\n * @prop {string} [longDescription] Long description of the command.\n * @prop {CommandArg[]} [args] List of args the command accepts.\n * @prop {string | string[]} [usage] Example of how to use the command.\n */\n\n/**\n * @typedef {object} CommandArg\n * @prop {string[] | string} identifier The identifier(s) of the arg.\n * @prop {string} description Description of the arg.\n */\n\n/** \n * @typedef {object} Command\n * @prop {string} name Name of the command\n * @prop {CommandCallback} callback\n * @prop {CommandHelp} help\n */\n\n/**\n * @callback CommandCallback\n * @param {any[]} [args]\n */\n\n/**\n * CommandsManager is part of the rc-package-dev aux.\n * You can register commands to it that can be invoked using '$<command>' with the CasualOS chat bar.\n * Its generally not recommended to create this yourself but instead to listen for the @onCommandsManagerCreated shout\n * and to register your commands there.\n * @prop {string[]} commands\n */\nclass CommandsManager {\n    constructor() {\n        /**@type {Object.<string, Command>} */\n        this.commands = {};\n\n        // Shout that an instance of CommandsManager has been created and allow any listeners\n        // to add their own commands to the instance.\n        shout('onCommandsManagerCreated', this);\n    }\n\n    /**\n     * Add a command to CommandsManager.\n     * This command will be available to invoke using '$<name>' on the CasualOS chat bar.\n     * @param {string} name\n     * @param {CommandCallback} callback\n     * @param {CommandHelp} help\n     * @returns {boolean} Wether or not the command was successfully added.\n     */\n    addCommand(name, callback, help) {\n        if (!name || typeof name !== 'string') {\n            console.error(`[CommandsManager] string name is required for commands.`);\n            return false;\n        }\n\n        if (this.commands[name]) {\n            console.error(`[CommandsManager] ${name} is already exists as a command.`);\n            return false;\n        }\n\n        if (!callback || typeof callback !== 'function') {\n            console.error(`[CommandsManager] ${name} command requires a callback function.`);\n            return false;\n        }\n\n        if (!help) {\n            console.error(`[CommandsManager] ${name} command requires help object.`);\n            return false;\n        }\n\n        if (!help.shortDescription) {\n            console.error(`[CommandsManager] ${name} command is missing shortDescription from help object.`);\n            return false;\n        }\n\n        this.commands[name] = { name, callback, help };\n        return true;\n    }\n\n    /**\n     * Remove a command from CommandsManager\n     * @returns {boolean} Wether or not the specified command was removed. If the command doesn't exist false will also be returned.\n     */\n    removeCommand(name) {\n        if (this.commands[name]) {\n            delete this.commands[name];\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * Call the specified command with the provided args (if any).\n     * @param {string} name\n     * @param {any[]} [args]\n     * @returns {boolean} Wether or not the command was executed.\n     */\n    callCommand(name, args) {\n        const command = this.commands[name];\n        if (command) {\n            if (args) {\n                const validArgs = [];\n\n                if (command.help.args) {\n                    for (const helpArg of command.help.args) {\n                        if (Array.isArray(helpArg.identifier)) {\n                            validArgs.push(...helpArg.identifier);\n                        } else {\n                            validArgs.push(helpArg.identifier);\n                        }\n                    }\n                }\n\n                // Assert that the input args are valid against the command help documentation.\n                // This is an easy way to validate args before executing a command.\n                rcdev.assertValidArgs(args, validArgs);\n            }\n            command.callback(args);\n            return true;\n        } else {\n            console.error(`[CommandsManager] ${name} is not a valid command.`);\n            return false;\n        }\n    }\n}\n\nglobalThis.CommandsManager = CommandsManager;",
        "onAuxPackageLoaded": "@thisBot.initialize();",
        "onBotAdded": "@thisBot.initialize();",
        "onChat": "@if (that.message[0] == '$')\n{\n    // Get command and args.\n    let args = that.message.split(' ');\n    const cmd = args[0].slice(1);\n    args.splice(0, 1);\n    args = args.filter(arg => arg !== '');\n    args = args.length ? args : undefined;\n\n    // Create a fresh CommandsManager with each call so that we always have the latest commands and functionality.\n    const commandsMgr = new CommandsManager();\n\n    if (commandsMgr) {\n        const executed = commandsMgr.callCommand(cmd, args);\n        if (!executed) {\n            rcdev.logAndToast(`[${tags.system}] CommandsManager command '${cmd}' is not recognized.`);\n        }\n    } else {\n        console.error(`[${tags.system}] CommandsManager has not been instantiated, ignoring command: ${cmd}, args:`, args);\n    }\n\n    os.hideChat();\n}",
        "onCommandsManagerCreated": "@/**@type {CommandsManager} */\nlet commandsMgr = that;\n\n// These are all the built-in commands.\n\ncommandsMgr.addCommand('help', (args) => {\n    const commands = commandsMgr.commands;\n    const commandKeys = Object.keys(commands);\n\n    let selectedCommand;\n    if (commandKeys && commandKeys.length && args && args.length) {\n        const commandKeyMatch = commandKeys.find(key => key === args[0]);\n        selectedCommand = commandKeyMatch;\n    }\n    \n    rcdev.helpApp.mount({ commandsManager: commandsMgr, selectedCommand });\n}, {\n    shortDescription: 'Show this help window. Can specify a command to open the help page for that command directly.',\n    usage: ['$help', '$help [command]']\n});\n\ncommandsMgr.addCommand('packages', (args) => {\n    rcdev.packagesApp.mount();\n}, {\n    shortDescription: 'Show all loaded packages and their version info.',\n    usage: '$packages'\n});\n\ncommandsMgr.addCommand('backup', args => thisBot.cmdBackup(args), {\n    shortDescription: 'Download backup copies of aux packages.',\n    longDescription: `Download backup copies of aux packa    ges.\n\n    You can use the @onExporterExtraFiles shout to create and store extra files in backups other than the specified aux packages.\n    `,\n    usage: ['$backup', '$backup *', '$backup [package ...]', '$backup -inst'],\n    args: [\n        {\n            identifier: '<none>',\n            description: 'Backup all packages found in the inst in a single aux file.'\n        },\n        {\n            identifier: '-inst',\n            description: 'Backup all shared bots in the inst, regardless of wether they are part of an aux package or not.'\n        },\n        {\n            identifier: '-n',\n            description: 'Custom name of the backed up aux bundle, zip archive, or inst backup. This is ignored if only one aux package is being backed up.'\n        },\n        {\n            identifier: '*',\n            description: 'Backup all packages found in the inst into a .zip archive where each package is a seperate aux file.'\n        },\n        {\n            identifier: 'package',\n            description: 'The name of the package to backup. Can specify more than one package. If more than one package is listed it will be backed up as a .zip archive where each package is a seperate aux file. This is ignored if -inst is used'\n        },\n    ]\n});\n\ncommandsMgr.addCommand('unload', args => thisBot.cmdPkgUnload(args), {\n    shortDescription: 'Unload aux package(s) from inst',\n    usage: ['$unload <package ...>'],\n    args: [\n        {\n            identifier: 'package',\n            description: 'The name of the package to unload. Can specify more than one package.'\n        }\n    ]\n});\n\ncommandsMgr.addCommand('upload', args => thisBot.cmdFilesUpload(args), {\n    shortDescription: 'Upload file(s) to permanent storage using ab1.',\n    usage: '$upload',\n    args: [\n        {\n            identifier: '-studio',\n            description: 'Optionally publish file(s) to a specific studio id. This is only relevant on distributions that use ABPro. If omitted, file(s) will be published to the user\\'s default studio.'\n        }\n    ]\n});\n\ncommandsMgr.addCommand('publish', args => thisBot.cmdPkgPublish(args), {\n    shortDescription: 'Publish aux package(s) to permanent storage using ab1.',\n    usage: [\n        '$publish <package [options] ...>',\n        '$publish [--studio <studio_id>] [--branch <branch>] <package [options] ...>',\n        '$publish myPrivatePackage01 -x myPublicPackage01 myPublicPackage02 myPublicProtectedPackage03 -s abc123',\n    ],\n    args: [\n        {\n            identifier: '--studio',\n            description: 'Optionally publish the aux package(s) to a specific studio id. This is only relevant on distributions that use ABPro. If omitted, packages will be published to the user\\'s default studio. This will be applied to all packages provided to the command.\\n\\nExample:\\n$publish --studio abc-123-456-789 myCoolPackage01 myCoolPackage02\\nThis will publish myCoolPackage01 and myCoolPackage02 to the studio id abc-123-456-789'\n        },\n        {\n            identifier: '--branch',\n            description: 'Optionally publish to an egg(s) with the given branch name appended to the name of the aux package. This will be applied to all packages provided to the command.\\n\\nExample:\\n$publish --branch dev myCoolPackage01 myCoolPackage02\\nThis will publish myCoolPackage01 as myCoolPackage01-dev and myCoolPackage02 as myCoolPackage02-dev.'\n        },\n        {\n            identifier: '-s',\n            description: 'The secret / password to encrypt this package with. This secret will be required to load the package afterwards. This is unique to each package provided to the command.'\n        },\n        {\n            identifier: '-x',\n            description: 'Optionally publish the aux package as a private ab. It will require that you are signed in to the account you are publishing under. This is only relevant on distributions that use ABPro. If omitted, the package will be public by default.  This is unique to each package provided to the command.'\n        }\n    ]\n});\n\ncommandsMgr.addCommand('ide', args => thisBot.cmdIDE(args), {\n    shortDescription: 'Open the system portal (IDE) for the inst.',\n    usage: '$ide'\n});\n\ncommandsMgr.addCommand('system', args => thisBot.cmdIDE(args), {\n    shortDescription: 'Open the system portal (IDE) for the inst.',\n    usage: '$system'\n});\n\ncommandsMgr.addCommand('sheet', args => thisBot.cmdSheet(args), {\n    shortDescription: 'Open the sheet portal for specified bot or an entire dimension.',\n    usage: [\n        '$sheet [options] [portal | helperBotName | botId | globalThisPath]',\n        'ex. $sheet home',\n        'ex. $sheet configBot',\n        'ex. $sheet -t a2cf4739-39a2-4fd6-b3ef-cc4782f97089',\n        'ex. $sheet globalThis.myObject.myBot',\n        'ex. $sheet myObject.myBot'\n    ],\n    args: [\n        {\n            identifier: '-t',\n            description: 'Open the sheet portal in a new browser tab. \\n\\nNOTE: $sheet will automatically inspect the space of a bot and force opening in the same tab if a bot is in tempLocal or tempShared space.',\n        }\n    ]\n});\n\ncommandsMgr.addCommand('bumpversion', args => thisBot.cmdBumpVersion(args), {\n    shortDescription: 'Bump the stored version number of the specified package(s).',\n    usage: [\n        '$bumpversion <package ...> (Run as -minor by default)',\n        '$bumpversion -minor <package ...>',\n        '$bumpversion -major <package ...>',\n    ],\n    args: [\n        {\n            identifier: '-minor',\n            description: 'Perform a minor version bump. ie 1.1 -> 1.2',\n        },\n        {\n            identifier: '-major',\n            description: 'Perform a major version bump. ie 1.1 -> 2.0',\n        },\n        {\n            identifier: 'package',\n            description: 'The name of the package to bump the version of. Can specify more than one package.'\n        },\n    ]\n});\n\ncommandsMgr.addCommand('urlqr', () => os.showQRCode(configBot.tags.url), {\n    shortDescription: 'Show a QR code for the brower tab\\'s current URL.',\n    usage: '$urlqr'\n});\n\ncommandsMgr.addCommand('dim', (args) => {\n    if (args && args.length) {\n        const name = args.join(' ');\n        os.goToDimension(name);\n    }\n}, {\n    shortDescription: 'Go to specified dimension / portal.',\n    usage: '$dim <dimension | portal>',\n});\n\ncommandsMgr.addCommand('uuid', () => {\n    os.setClipboard(uuid());\n    rcdev.logAndToast('Copied new uuid to clipboard');\n}, {\n    shortDescription: 'Generate a universally unique identifier (uuid) and copy it to the clipboard.',\n    usage: '$uuid'\n});\n\ncommandsMgr.addCommand('dup', (args) => {\n    const botId = args ? args[0] : undefined;\n    if (botId) {\n        const bot = getBot('id', botId);\n        if (bot) {\n            const dupBot = create(bot);\n            os.setClipboard(dupBot.id);\n            os.toast('Duplicate bot id copied to clipboard.');\n        } else {\n            os.toast(`No bot found with id ${botId}`);\n        }\n    } else {\n        os.toast('Provide the id of the bot you want to duplicate');\n    }\n}, {\n    shortDescription: 'Duplicate a specified bot and copy the new bot\\'s id to the clipboard.',\n    usage: '$dup <botId>'\n});\n\ncommandsMgr.addCommand('createappbot', args => thisBot.cmdCreateAppBot(args), {\n    shortDescription: 'Create a new custom app bot with boilerplate functionality.',\n    longDescription: `Create a new custom app bot with all the boilerplate code and functionality for mounting and displaying the app.\n    \n    Requires that you provide the system tag for the bot so that it is displayed in the system portal:\n\n    > $createappbot myCoolPackage.app\n    \n    You can find the bot in the system portal under the name your provide above.\n    After the app bot is created the command will automatically mount it and make the boilerplate app visible.\n\n    ================\n    Tags & Listeners\n    ================\n\n    #App - This is the root preact component. Apps can be made up of many components but they can only have one root compon    \n\n    @mount - Registers and compiles the root component (App) to the screen.\n\n    @unmount - Unregisters and removes the app from the screen.\n\n    @forceUpdate - Will re-compile the entire app. This is NOT recommended for normal use. You should utilize Preact hooks as much as possible that are provided by CasualOS via os.appHooks. Running forceUpdate is slow as every component is re-evaluated and subverts the efficiencies that Preact provides with its state-based rendering updates.\n\n    #style.css - This is root CSS stylesheet for the app. You can have many stylesheets if you wish to organize it that way but you will be responsible for making sure they are added to the <style> tag.\n\n    ================\n    More Information\n    ================\n\n    If you need more information about how to use Preact and its various hooks or how Preact works in general - you should refer to Preact's official documentation for more details.\n    `,\n    usage: ['$createappbot <system_tag>'],\n});\n\ncommandsMgr.addCommand('transform', args => thisBot.cmdTransform(args), {\n    shortDescription: 'Open the bot transform too, making it easier to hand place bots in the gridPortal.',\n    usage: ['$transform'],\n});\n\ncommandsMgr.addCommand('instupdates', args => thisBot.cmdInstUpdates(args), {\n    shortDescription: 'List the number of updates that have occured in the shared space.',\n    longDescription: `Fetches the number of updates that have occured in the shared space of this inst.\n\n    Once the fetch is complete a popup window will show the number of updates in the shared space, as well as a rough estimate of the total size of those object. \n    \n    * PLEASE NOTE that the size calculation is rough and will not neseccarily be accurate to how the data is being stored in the CasualOS data store.\n\n    If this command is run more than once, it will also provide the number of updates that have occured since the comamnd was last run.\n    `,\n    usage: ['$instupdates [options]'],\n    args: [\n        {\n            identifier: '-l',\n            description: 'Log the content of the updates to the browser\\'s developer console.'\n        }\n    ]\n});\n\ncommandsMgr.addCommand('currentinst', () => {\n    let currentInst = os.getCurrentInst();\n    let primaryInst = Array.isArray(configBot.tags.inst) ? configBot.tags.inst[0] : configBot.tags.inst;\n\n    console.log('currentInst:', currentInst);\n    console.log('primaryInst:', primaryInst);\n    console.log('insts:', configBot.tags.inst);\n\n}, {\n    shortDescription: 'Print the current inst and the primary inst',\n    usage: ['$currentinst'],\n})\n\ncommandsMgr.addCommand('github', args => thisBot.cmdGithub(args), {\n    shortDescription: 'Push packages to your Github repository.',\n    usage: [\n        '$github -setup',\n        '$github -push <package ...>',\n        // '$github -pull <package ...>',\n    ],\n    args: [\n        {\n            identifier: '-setup',\n            description: 'Setup the information required for this command to access your GitHub repository.'\n        },\n        {\n            identifier: '-push',\n            description: 'Push the specified package(s) to your GitHub repository.'\n        },\n        // {\n        //     identifier: '-pull',\n        //     description: 'Pull the specified package(s) from your github repository.'\n        // },\n    ]\n})",
        "onEggHatch": "@thisBot.initialize();",
        "onInstJoined": "@console.log('command onInstJoined');\nthisBot.initialize();",
        "parsePackageArgs": "@const args = that;\n\nconst packages = {};\nlet name;\nlet data = {};\n\nfor (let i = 0; i <= args.length;) {\n    let arg;\n    if (i < args.length) {\n        arg = args[i];\n    }\n    let indexAdd = 1;\n\n    if (arg && arg.startsWith('-')) {\n        // Arguments\n        if (arg === '-s') {\n            // Secret\n            const valueIndex = i + 1;\n            if (valueIndex < args.length) {\n                data.secret = args[valueIndex];\n                indexAdd = 2;\n            }\n        } else if (arg === '-v') {\n            // Version\n            const valueIndex = i + 1;\n            if (valueIndex < args.length) {\n                data.version = args[valueIndex];\n                indexAdd = 2;\n            }\n        } else if (arg === '-x') {\n            // Private\n            data.private = true;\n        } else {\n            throw new Error(`Unknown argument type ${arg}`);\n        }\n    } else {\n        if (name) {\n            // Add package to collection.\n            if (!data.version) {\n                data.version = \"*\";\n            }\n            packages[name] = data;\n\n            // Reset working variables.\n            data = {};\n            name = undefined;\n        }\n\n        if (arg) {\n            // Name of package.\n            name = arg;\n        }\n    }\n\n    i += indexAdd;\n}\n\nreturn packages;",
        "system": "rc-package-dev.command"
      }
    },
    "rc-package-dev.exporter": {
      "id": "rc-package-dev.exporter",
      "space": "shared",
      "tags": {
        "botsToAUX": "@const { bots } = that;\n\nconst aux = { version: 1, state: {} };\nfor (let bot of bots) {\n    const id = bot.tags.system ?? bot.id;\n\n    if (!aux.state[id]) {\n        const mod = getSnapshot(bot)[bot.id].tags;\n        delete mod['auxCodeOrigin'];\n        delete mod['creator'];\n        delete mod['abIDOrigin'];\n        delete mod['abIDStudio'];\n\n        for (let tag in mod) {\n            if (mod[tag] === undefined || mod[tag] === null) {\n                delete mod[tag];\n            }\n        }\n        \n        // Sort the tags alphabetically.\n        const sortedTags = Object.keys(mod).sort();\n        const sortedMod = {};\n        for (let tag of sortedTags) {\n            sortedMod[tag] = mod[tag];\n        }\n        \n        aux.state[id] = {\n            id,\n            space: bot.space,\n            tags: sortedMod,\n        }\n    } else {\n        throw new Error(`Cannot export aux that has two bots with duplicate ids. Duplicate id: ${id}`);\n    }\n}\n\nreturn aux;",
        "downloadBundle": "@const { name } = that ?? {};\n\nconst bots = thisBot.getSystemBots();\nthisBot.sortBotsBySystemTag({ bots });\n\nconst aux = thisBot.botsToAUX({ bots });\nconst baseFilename = name ? `${name}_bundle` : `aux_packages_bundle`;\nconst auxFilename = thisBot.vars.filenameWithDate( baseFilename, '.aux');\nconst auxJson = JSON.stringify(aux, undefined, 2);\n\nconsole.log(`[${tags.system}.${tagName}] download ${auxFilename} w/ ${bots.length} bots.`);\nos.download(auxJson, auxFilename);",
        "downloadInst": "@const { name } = that ?? {};\n\nconst bots = getBots((b) => {\n    return !b.tags.ab1ID &&\n           !b.tags.abID &&\n           !b.tags.ab1Ignore &&\n           !b.tags.abIgnore &&\n           b.space === 'shared'\n});\n\nthisBot.sortBotsBySystemTag({ bots });\n\nconst aux = thisBot.botsToAUX({ bots });\nconst baseFilename = name ? `${name}_inst_backup` : `${configBot.tags.inst}_inst_backup`;\nconst auxFilename = thisBot.vars.filenameWithDate( baseFilename, '.aux');\nconst auxJson = JSON.stringify(aux, undefined, 2);\n\nconsole.log(`[${tags.system}.${tagName}] download ${auxFilename} w/ ${bots.length} bots.`);\nos.download(auxJson, auxFilename);",
        "downloadPackages": "@let { name, ...whitelist} = that ?? {};\n\n// Convert white list back to an array\nconst whitelistKeys = Object.keys(whitelist);\nif (whitelistKeys && whitelistKeys.length) {\n    whitelist = whitelistKeys.map(i => whitelist[i]);\n} else {\n    whitelist = undefined;\n}\n\nconst packages = thisBot.getBotPackages(whitelist);\nconst packageCount = Object.keys(packages).length;\nconst extraFiles = await thisBot.getExtraFiles();\n\nconsole.log(`[${tags.system}.${tagName}] extraFiles:`, extraFiles);\n\nconst totalFileCount = packageCount + extraFiles.length;\n\nif (totalFileCount > 0) {\n    if (totalFileCount > 1) {\n        // Download packages as a zip archive.\n        let jszipModule;\n        \n        if (!links.localFileIO) {\n            const localFileIO = getBot((b) => {\n                return b.tags.ab1ID === 'localServerFileIO' || \n                       b.tags.abID === 'localServerFileIO'\n            });\n            \n            if (localFileIO) {\n                masks.localFileIO = localFileIO.link;\n            }\n        }\n\n        if (links.localFileIO) {\n            jszipModule = await import( links.localFileIO.getFileURL({ filename: 'jszip.js' }) );\n        } else {\n            // jszip.js\n            jszipModule = await import('https://publicos-link-filesbucket-404655125928.s3.amazonaws.com/ab-1/028d78e26fdd9e7d7c34ac02fe22913b6b4dc4ab2410f90ef29ab435b5675688');\n        }\n        \n        const zip = new jszipModule.default();\n\n        for (let packageId in packages) {\n            const bots = packages[packageId];\n            thisBot.sortBotsBySystemTag({ bots });\n\n            const aux = thisBot.botsToAUX({ bots });\n            const auxFilename = `${packageId}.aux`;\n            const auxJson = JSON.stringify(aux, undefined, 2);\n            \n            zip.file(auxFilename, auxJson, { compression: \"STORE\" });\n        }\n\n        for (let extraFile of extraFiles) {\n            zip.file(extraFile.name, extraFile.data, extraFile.options);\n        }\n\n        const zipContent = await zip.generateAsync({\n            type: \"blob\",\n            compression: \"STORE\",\n            mimeType: \"application/json\"\n        });\n        const baseFilename = name ? `${name}_packages` : `aux_packages`;\n        const zipFilename = thisBot.vars.filenameWithDate(baseFilename, '.zip');\n        \n        os.download(zipContent, zipFilename);\n    } else {\n        // Download a single package as an aux file or a single extra file.\n        if (packageCount === 1) {\n            const packageId = Object.keys(packages)[0];\n            const bots = packages[packageId];\n            thisBot.sortBotsBySystemTag({ bots });\n\n            const aux = thisBot.botsToAUX({ bots });\n            const auxFilename = thisBot.vars.filenameWithDate(packageId, '.aux');\n            const auxJson = JSON.stringify(aux, undefined, 2);\n\n            os.download(auxJson, auxFilename);\n        } else if (extraFiles.length === 1) {\n            // Handle single extra file\n            const extraFile = extraFiles[0];\n            const fileName = extraFile.name;\n            const fileData = extraFile.data;\n\n            os.download(fileData, fileName);\n        }\n    }\n} else {\n    rcdev.logAndToast(`[exporter] no packages or files to download.`);\n}",
        "getBotPackages": "@let whitelist = that;\nif (that) {\n    whitelist = Array.isArray(that) ? that : [that];\n}\n\nconst bots = thisBot.getSystemBots();\n\n// Sort each bot into their appropriate package using\n// the system tag name.\nconst packages = {};\n\nfor (let b of bots) {\n    const packageId = b.tags.system.split('.', 1)[0];\n    if (!packages[packageId]) {\n        packages[packageId] = [];\n    }\n    packages[packageId].push(b);\n}\n\nif (whitelist) {\n    // Filter out packages that are not in the whitelist.\n    const packageIds = Object.keys(packages);\n    for (const packageId of packageIds) {\n        if (!whitelist.includes(packageId)) {\n            delete packages[packageId];\n        }\n    }\n}\n\nreturn packages;",
        "getExtraFiles": "@/**\n * @typedef {Object} JSZipFileInput\n * @property {string} name - The name of the file. You can specify folders using forward slashes (\"/\").\n * @property {string|ArrayBuffer|Uint8Array|Buffer|Blob|Promise<any>|NodeJS.ReadableStream} data - The content of the file.\n * @property {JSZipFileOptions} [options] - Optional parameters for file configuration.\n */\n\n/**\n * Give outside bots a chance to add extra files to the export bundle.\n * Expecting shout responses to be an optional single JSZipFileInput object or an array of JSZipFileInput.\n * See the official JSZip documentation for more information: https://stuk.github.io/jszip/documentation/api_jszip/file_data.html\n */\nlet shoutResponses = await Promise.allSettled(shout('onExporterExtraFiles'));\nconsole.log(`[${tags.system}.${tagName}] shoutResponses:`, shoutResponses);\n\nlet extraFiles: JSZipFileInput[] = [];\n\nfunction isJSZipFileInput(obj) {\n    if (typeof obj !== 'object' || obj == null) return false;\n\n    const hasValidName = typeof obj.name === 'string';\n\n    const isValidData =\n        typeof obj.data === 'string' ||\n        obj.data instanceof ArrayBuffer ||\n        obj.data instanceof Uint8Array ||\n        (typeof Buffer !== 'undefined' && obj.data instanceof Buffer) ||\n        (typeof Blob !== 'undefined' && obj.data instanceof Blob) ||\n        (obj.data && typeof obj.data.then === 'function') || // crude check for Promise\n        (typeof Readable !== 'undefined' && obj.data instanceof Readable); // Node.js stream\n\n    return hasValidName && isValidData;\n}\n\nfor (let response of shoutResponses) {\n    if (response) {\n        if (response.status === 'fulfilled') {\n            let value = response.value;\n\n            if (!Array.isArray(value)) {\n                value = [value];\n            }\n            \n            for (let entry of value) {\n                if (isJSZipFileInput(entry)) {\n                    extraFiles.push(entry);\n                } else {\n                    console.error(`[${tags.system}.${tagName}] onExporterExtraFiles response value is not a JSZipFileInput:`, entry);\n                }\n            }\n        } else {\n            console.error(`[${tags.system}.${tagName}] onExporterExtraFiles shout rejected reason:`, response.reason);\n        }\n\n    }\n}\n\nreturn extraFiles;",
        "getSystemBots": "@const bots = getBots((b) => {\n    return !b.tags.ab1ID &&\n           !b.tags.abID &&\n           b.space === 'shared' &&\n           !b.tags.ab1PublishIgnore &&\n           !b.tags.abPublishIgnore &&\n           !b.tags.ab1Ignore &&\n           !b.tags.abIgnore &&\n           b.tags.system &&\n           !b.tags.system.startsWith('ab.');\n});\n\nreturn bots;",
        "onBotAdded": "@globalThis.exporter = thisBot;\n\nthisBot.vars.filenameWithDate = (baseFilename, ext) => {\n    const date = new Date();\n    let timecode = '';\n    timecode += date.getFullYear().toString().padStart(2, '0');\n    timecode += (date.getMonth() + 1).toString().padStart(2, '0');\n    timecode += date.getDate().toString().padStart(2, '0');\n    timecode += '_';\n    timecode += date.getHours().toString().padStart(2, '0');\n    timecode += date.getMinutes().toString().padStart(2, '0');\n    timecode += date.getSeconds().toString().padStart(2, '0');\n    let filename = `${baseFilename}_${timecode}`;\n    if (ext) {\n        filename += ext;\n    }\n    return filename;\n}",
        "onDestroy": "@globalThis.exporter = undefined;",
        "sortBotsBySystemTag": "@const { bots } = that;\n\nbots.sort((a, b) => {\n    const sortById = (a, b) => {\n        if (a.id < b.id) {\n            return -1;\n        } else if (a.id > b.id) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n\n    if (a.tags.system && b.tags.system) {\n        if (a.tags.system < b.tags.system) {\n            return -1;\n        } else if (a.tags.system > b.tags.system) {\n            return 1;\n        } else {\n            return sortById(a, b);\n        }\n    } else if (a.tags.system && !b.tags.system) {\n        return -1;\n    } else if (!a.tags.system && b.tags.system) {\n        return 1;\n    } else {\n        return sortById(a, b);\n    }\n});\n\nreturn bots;",
        "system": "rc-package-dev.exporter"
      }
    },
    "rc-package-dev.logAndToast": {
      "id": "rc-package-dev.logAndToast",
      "space": "shared",
      "tags": {
        "onBotAdded": "@function toast(...args) {\n    // convert the arguments to a string for the toast\n    // join the arguments with a space between them\n    let toastMessage = args.map(arg => {\n        if (typeof arg === 'object') {\n            // If the argument is an object, convert it to a string using JSON.stringify\n            // Note that this will not work for circular structures in the object\n            return JSON.stringify(arg);\n        } else {\n            // Otherwise, just convert the argument to a string\n            return String(arg);\n        }\n    }).join(' ');\n\n    // call os.toast with the message\n    os.toast(toastMessage, 4);\n}\n\nfunction logAndToast(...args) {\n    console.log(...args);\n    toast(...args);\n}\n\nfunction warnAndToast(...args) {\n    console.warn(...args);\n    toast(...args);\n}\n\nfunction errorAndToast(...args) {\n    console.error(...args);\n    toast(...args);\n}\n\nif (!globalThis.rcdev) { globalThis.rcdev = {}; }\nrcdev.logAndToast = logAndToast;\nrcdev.warnAndToast = warnAndToast;\nrcdev.errorAndToast = errorAndToast;",
        "system": "rc-package-dev.logAndToast"
      }
    },
    "rc-package-dev.packageInfo": {
      "id": "rc-package-dev.packageInfo",
      "space": "shared",
      "tags": {
        "bumpVersion": "@const { name, bumpType = 'minor' } = that;\n\nconst packageInfoBot = thisBot.getPackageInfoBot({ name });\nlet version = packageInfoBot.raw.version;\n\nif (typeof version !== 'string') {\n    version = '0.0';\n}\n\nlet [ major, minor ] = version.split('.');\nmajor = Number.parseInt(major);\nminor = Number.parseInt(minor);\n\nif (bumpType === 'minor') {\n    minor += 1;\n} else if (bumpType === 'major') {\n    major += 1;\n    minor = 0;\n} else {\n    console.error(`[${tags.system}.${tagName}] bump type ${bumpType} is unrecognized.`);\n    return;\n}\n\npackageInfoBot.tags.version = `${major}.${minor}`;\npackageInfoBot.tags.versionDate = DateTime.now();\n\nconsole.log(`[${tags.system}.${tagName}] bumped ${name} from ${version} -> ${packageInfoBot.raw.version}`);",
        "getPackageInfoBot": "@const { name } = that;\n\nconst systemTag = `${name}._packageInfo`;\n\nlet packageInfoBot = getBot((b) => {\n    return b.tags.system === systemTag && b.space === 'shared';\n})\n\nif (!packageInfoBot) {\n    packageInfoBot = create({\n        space: 'shared',\n        system: systemTag,\n    })\n}\n\nreturn packageInfoBot;",
        "onBotAdded": "@globalThis.packageInfo = thisBot;",
        "onDestroy": "@globalThis.packageInfo = undefined;",
        "system": "rc-package-dev.packageInfo"
      }
    },
    "rc-package-dev.parseArg": {
      "id": "rc-package-dev.parseArg",
      "space": "shared",
      "tags": {
        "onBotAdded": "@/**\n * Returns the value of the provided arg. Will remove the arg and value from the args array.\n */\nfunction parseArgValue(args, arg) {\n    let value = null;\n\n    if (args) {\n        const argIndex = args.findIndex(a => a === arg);\n\n        if (argIndex >= 0) {\n            let deleteCount = 1;\n            const valueIndex = argIndex + 1;\n\n            if (valueIndex < args.length) {\n                deleteCount++;\n                value = args[valueIndex];\n            }\n\n            // Remove related args & values\n            args.splice(argIndex, deleteCount);\n        }\n    }\n    \n    return value;\n}\n\n/**\n * Returns wether the arg flag is provided in the args. Will remove the arg from the args array.\n */\nfunction parseArgFlag(args, arg) {\n    if (args) {\n        const argIndex = args.findIndex(a => a === arg);\n\n        if (argIndex >= 0) {\n            // Remove arg flag.\n            args.splice(argIndex, 1);\n\n            return true;\n        } else {\n            return false;\n        }\n    } else {\n        return false;\n    }\n}\n\nfunction assertValidArgs(args, validArgs) {\n    if (args) {\n        const invalidArgs = [];\n\n        for (let arg of args) {\n            if (arg && typeof arg === 'string') {\n                if (arg.startsWith('-')) {\n                    // This is an arg we want to evaluate.\n                    if (!validArgs || !validArgs.includes(arg)) {\n                        // This arg is not included in the validArgs, thus the arg is invalid.\n                        invalidArgs.push(arg);\n                    }\n                } else {\n                    // Ignore this arg it is mostly likely a value arg.\n                }\n            }\n        }\n\n        if (invalidArgs.length > 0) {\n            const errorMessage = `Invalid arguments: ${invalidArgs.join(', ')}`;\n\n            os.toast(errorMessage, 4);\n            throw new Error(errorMessage);\n        }\n    }\n}\n\nif (!globalThis.rcdev) { globalThis.rcdev = {}; }\nrcdev.parseArgValue = parseArgValue;\nrcdev.parseArgFlag = parseArgFlag;\nrcdev.assertValidArgs = assertValidArgs;",
        "system": "rc-package-dev.parseArg"
      }
    },
    "rc-package-dev.publishRecord": {
      "id": "rc-package-dev.publishRecord",
      "space": "shared",
      "tags": {
        "debug": "true",
        "publishPackage": "@const { name, secret, branch, isPrivate, studio } = that;\n\nawait os.sleep(100);\n\nlet ab = name;\nif (branch) {\n    ab += `-${branch}`;\n}\n\nconst bots = exporter.getBotPackages(name)[name];\n\nif (!bots || bots.length === 0) {\n    throw new Error(`There are no bots to publish for package name '${name}'`);\n}\n\nconsole.log(`[${tags.system}.${tagName}] Start publishing ${ab}...`);\n\nif (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] ab: ${ab}, key: ${secret}, studio: ${studio}, private: ${isPrivate}, bots:`, bots);\n}\n\nconst isAB1v8 = getBot(b => b.tags.ab1PublishAB != null);\n\nlet publishRecord;\n\nif (isAB1v8) {\n    const [ result ] = await Promise.all( shout('ab1PublishAB', { ab, key: secret, target: bots }) );\n    publishRecord = result;\n} else {\n    configBot.tags.publicFacing = !isPrivate;\n    configBot.tags.selected_studioID = studio;\n\n    const [ result ] = await Promise.all( shout('abPublishAB', { ab, key: secret, target: bots }) );\n\n    configBot.tags.publicFacing = null;\n    configBot.tags.selected_studioID = null;\n\n    publishRecord = result;\n}\n\nreturn publishRecord;",
        "system": "rc-package-dev.publishRecord",
        "uploadFile": "@const { file, studio } = that;\n\nif (tags.debug) {\n    console.log(`[${tags.system}.${tagName}] uploadFile:`, that);\n}\n\nlet fileExtension = that.file.name.split('.').pop();\nlet fileName = that.file.name.split('.').shift();\nlet mimeType;\n\nswitch (fileExtension) {\n    case 'svg':\n        mimeType = \"image/svg+xml\";\n        break;\n    case 'glb':\n    case 'gltf':\n        mimeType = \"text/xml\";\n        break;\n    default:\n        mimeType = file.mimeType;\n        break;\n}\n\nconst isAB1v8 = getBot(b => b.tags.ab1FileUpload != null);\n\nlet url;\n\nif (isAB1v8) {\n    const [result] = await Promise.all(shout('ab1FileUpload', { file, fileName, mimeType, returnType: 'link' }));\n    url = result;\n} else {\n    configBot.tags.selected_studioID = studio;\n\n    const [result] = await Promise.all(shout('abPublishFile', { file, fileName, mimeType }));\n\n    configBot.tags.selected_studioID = null;\n    \n    if (result.url) {\n        url = result.url;\n    } else if (result.existingFileUrl) {\n        url = result.existingFileUrl;\n    }\n}\n\nreturn { url };"
      }
    }
  }
}