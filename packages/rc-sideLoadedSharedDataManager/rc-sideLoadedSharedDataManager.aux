{
  "version": 1,
  "state": {
    "rc-sideLoadedSharedDataManager._packageInfo": {
      "id": "rc-sideLoadedSharedDataManager._packageInfo",
      "space": "shared",
      "tags": {
        "system": "rc-sideLoadedSharedDataManager._packageInfo",
        "version": "0.7",
        "versionDate": "ðŸ“…2024-03-20T08:54:58.825-04:00 local"
      }
    },
    "rc-sideLoadedSharedDataManager.manager": {
      "id": "rc-sideLoadedSharedDataManager.manager",
      "space": "shared",
      "tags": {
        "debug": "true",
        "enabled": "true",
        "initialize": "@if (configBot.tags.systemPortal) {\n    if (tags.debug) {\n        console.log(`[${tags.system}] not initializing due to the systemPortal being active`);\n    }\n    return;\n}\n\nif (masks.initialized) {\n    if (tags.debug) {\n        console.log(`[${tags.system}] already intialized`);\n    }\n    return;\n}\n\nmasks.initialized = true;\n\nif (tags.debug) {\n    console.log(`[${tags.system}] initialize`);\n}\n\nif (!globalThis.SideLoadedSharedDataManager) {\n    thisBot.loadLibrary();\n}\n\nif (tags.enabled) {\n    // Load the inst using the joinInst function.\n    if (!tags.sideLoadInstName) {\n        console.error(`[${tags.system}] sideLoadInstName tag does not have a value`);\n        return;\n    }\n\n    const joined = await SideLoadedSharedDataManager.joinInst(tags.sideLoadInstName, tags.sideLoadPattern, tags.sideLoadPatternRecordId);\n}\n",
        "listening": "true",
        "loadLibrary": "@globalThis.SideLoadedSharedDataManager = {};\n\nthisBot.vars.listeners = {};\n\nfunction getErrorMessage(error) {\n    if (error) {\n        if (typeof error === 'string') {\n            return error;\n        } else if (error.message) {\n            return error.message;\n        } else if (error.error) {\n            return getErrorMessage(error.error);\n        }\n    }\n}\n\nfunction addListenTagListener (bot, name, listener) {\n    assert(name, `${tags.system} name is required.`);\n    assert(listener && typeof listener === 'function', `${tags.system} listener function is required.`);\n    \n    let entries = thisBot.vars.listeners[name];\n    if (!entries) {\n        entries = [];\n        thisBot.vars.listeners[name] = entries;\n    }\n\n    entries.push({ listener, bot });\n}\n\nfunction removeListenTagListener (bot, name, listener) {\n    let entries = thisBot.vars.listeners[name];\n    if (!entries) {\n        return;\n    }\n\n    for (let i = entries.length - 1; i >= 0; i--) {\n        let entry = entries[i];\n\n        if (entry.listener != listener) {\n            continue;\n        }\n\n        if (bot) {\n            const botId = typeof bot === 'string' ? bot : bot.id;\n            const entryBotId = typeof entry.bot === 'string' ? entry.bot : entry.bot.id;\n            \n            if (botId !== entryBotId) {\n                continue;\n            }\n        }\n\n        entries.splice(i, 1);\n    }\n}\n\n/**\n * Join the specified inst and load the specified ab if it isnt already loaded.\n * Requires that the ab implement @onIsABLoadedRequest and @onIsABLoadedResponse in order for this system to work.\n * \n * @param {string} instToJoin Name of the inst to join.\n * @param {string} [abToLoad] Optional: Name of the ab to load.\n * @param {string} [abRecord] Optional: Name of the record that the ab belongs to.\n * @returns {boolean} Wether the inst (and optional ab) were successfully loaded.\n */\nasync function joinInst(instToJoin, abToLoad = null, abRecord = null) {\n    const currentInsts = Array.isArray(configBot.tags.inst) ? configBot.tags.inst : [configBot.tags.inst];\n    const isJoined = currentInsts.some(inst => inst === instToJoin);\n\n    // Remove ab/pattern from URL query params if it is there. \n    // Otherwise the new ab in the new inst will use it to load an undesirable ab/pattern.\n    configBot.tags.ab = null;\n    configBot.tags.autoLoad = null;\n    configBot.tags.pattern = null;\n    \n    if (!isJoined) {        \n        // Load inst and wait for ab to be initialized.\n        await new Promise((resolve) => {\n            let instJoined = false;\n            let abReady = false;\n\n            function tryResolve() {\n                if (instJoined && abReady) {\n                    if (tags.debug) {\n                        console.log(`[${tags.system}] Inst ${instToJoin} is loaded and ab is ready.`);\n                    }\n                    resolve();\n                }\n            }\n\n            function onInstJoined (listenerThat) {\n                if (listenerThat.inst === instToJoin) {\n                    if (tags.debug) {\n                        console.log(`[${tags.system}] onInstJoined ${instToJoin}`);\n                    }\n                    removeListenTagListener(null, 'onInstJoined', onInstJoined);\n                    instJoined = true;\n                    tryResolve();\n                }\n            }\n\n            function onABInitialized () {\n                if (tags.debug) {\n                    console.log(`[${tags.system}] onABInitialized`);\n                }\n                removeListenTagListener(null, 'onABInitialized', onABInitialized);\n                abReady = true;\n                tryResolve();\n            }\n\n            addListenTagListener(null, 'onInstJoined', onInstJoined);\n            addListenTagListener(null, 'onABInitialized', onABInitialized);\n\n            if (tags.debug) {\n                if (abToLoad) {\n                    if (abRecord) {\n                        console.log(`[${tags.system}] join inst ${instToJoin} and load ab ${abToLoad} from record ${abRecord}`);\n                    } else {\n                        console.log(`[${tags.system}] join inst ${instToJoin} and load ab ${abToLoad}`);\n                    }\n                } else {\n                    console.log(`[${tags.system}] join inst ${instToJoin}`);\n                }\n            }\n\n            os.loadInst(instToJoin);\n        });\n    } else {\n        if (tags.debug) {\n            console.log(`[${tags.system}] Already joined inst ${instToJoin}`);\n        }\n    }\n    \n    if (abToLoad) {\n        // Super shout a request to see if the ab/pattern is already loaded.\n        let isABLoaded;\n\n        try { \n            isABLoaded = await superShoutAndListen('onIsABLoadedRequest', { ab: abToLoad }, 'onIsABLoadedResponse', (listenerThat, resolve) => {\n                if (tags.debug) {\n                    console.log(`[${tags.system}] onIsABLoadedResponse for ${listenerThat.ab} received.`);\n                }\n                if (listenerThat.ab === abToLoad) {\n                    resolve(true);\n                }\n            }, 3000)\n        } catch (e) {\n            if (tags.debug) {\n                console.error(`[${tags.system}] isABLoaded for ${abToLoad} failed. Error: ${getErrorMessage(e)}`);\n            }\n            isABLoaded = false;\n        }\n\n        if (!isABLoaded) {\n            const isAB1v8 = !!getBot((b) => {\n                return b.tags.auxCodeSearch != null &&\n                        b.tags.ab1ID === 'searchLTM';\n            });\n\n\n            // Super shout the ab/pattern loading function.\n            let isABAdded;\n\n            try {\n                if (isAB1v8) {\n                    if (tags.debug) {\n                        console.log(`[${tags.system}] superShouting auxCodeSearch with ab ${abToLoad}`);\n                    }\n\n                    // Disable listening on our ab search bot for a moment so that it doesnt respond to the following super shout.\n                    ab1LongTermMemorySearch.masks.listening = false;\n\n                    isABAdded = await superShoutAndListen(\n                        'auxCodeSearch', \n                        { \n                            auxCode: abToLoad,\n                            autoHatch: true,\n                        },\n                        'onAbAdded',\n                        (listenerThat, resolve) => {\n                            if (tags.debug) {\n                                console.log(`[${tags.system}] onAbAdded for ${listenerThat.ab} received.`);\n                            }\n                            if (listenerThat.ab === abToLoad) {\n                                resolve(true);\n                            }\n                        },\n                        3000\n                    );\n                } else {\n                    if (tags.debug) {\n                        console.log(`[${tags.system}] superShouting onLookupABEggs with ab ${abToLoad} and recordKey ${abRecord}`);\n                    }\n\n                    // Disable listening on our ab search bot for a moment so that it doesnt respond to the following super shout.\n                    abSearch.masks.listening = false;\n\n                    isABAdded = await superShoutAndListen(\n                        'onLookupABEggs', \n                        { \n                            abID: abToLoad,\n                            recordKey: abRecord,\n                            autoHatch: true,\n                        },\n                        'onAbAdded',\n                        (listenerThat, resolve) => {\n                            if (tags.debug) {\n                                console.log(`[${tags.system}] onAbAdded for ${listenerThat.ab} received.`);\n                            }\n                            if (listenerThat.ab === abToLoad) {\n                                resolve(true);\n                            }\n                        },\n                        3000\n                    );\n                }\n            } catch (e) {\n                if (tags.debug) {\n                    console.error(`[${tags.system}] isABAdded for ${abToLoad} failed. Error: ${getErrorMessage(e)}`);\n                }\n                isABAdded = false;\n            } finally {\n                // Reset the listening tag on the ab search bot.\n                if (isAB1v8) {\n                    ab1LongTermMemorySearch.masks.listening = null;\n                } else {\n                    abSearch.masks.listening = null;\n                }\n            }\n\n            if (!isABAdded) {\n                console.error(`[${tags.system}] Failed to load ab ${abToLoad} in ${instToJoin}`);\n                return false;\n            } else {\n                if (tags.debug) {\n                    console.log(`[${tags.system}] ab ${abToLoad} successfully loaded`);\n                }\n                return true;\n            }\n        } else {\n            if (tags.debug) {\n                console.log(`[${tags.system}] ab ${abToLoad} is already loaded`);\n            }\n            return true;\n        }\n    } else {\n        return true;\n    }\n}\n\n\n/**\n * @callback ShoutResponseHandlerResolve\n * @param {any} [result]\n */\n\n/**\n * @callback ShoutResponseHandler\n * @param {any} listenerThat\n * @param {ShoutResponseHandlerResolve} resolve\n */\n\n/**\n * Utility function for performing a super shout. Specifically superShoutAndListen makes it easier\n * to wait for a specified response from the super shout. If the response shout is recieved then it will be passed to\n * the provided response handler. If the response handler resolves than it will be the final result of the superShoutAndListen call.\n * \n * @async\n * @param {string} shoutTag - The tag used for the superShout\n * @param {any} [shoutArg] - The arg to pass through the shout.\n * @param {string} shoutResponseTag - The tag to listen for the response shout. Default is null.\n * @param {ShoutResponseHandler} shoutResponseHandler - The response handler function. Must invoke resolve in order for the superShoutAndListen to finalize and return a result. Default is null.\n * @param {number} [shoutResponseTimeoutMS] The timeout in milliseconds when superShoutAndListen will fail as no response as occured. Default is null.\n * @returns {Promise<any>} A promise with the result of the response handler.\n */\nasync function superShoutAndListen (shoutTag, shoutArg, shoutResponseTag, shoutResponseHandler, shoutResponseTimeoutMS = null) {\n    assert(shoutResponseTag, `[${tags.system}] Must provide a shoutResponseTag.`);\n    assert(typeof shoutResponseHandler === 'function', `[${tags.system}] Must provide a shoutResponseHandler function.`);\n\n    let responsePromise = new Promise((resolve, reject) => {\n        let timeoutId;\n\n        if (shoutResponseTimeoutMS > 0) {\n            timeoutId = setTimeout(() => {\n                if (tags.debug) {\n                    console.log(`[${tags.system}] shout response timed out.`);\n                }\n                cleanup();\n                reject('response_timeout');\n            }, shoutResponseTimeoutMS);\n        }\n\n        function _listener (listenerThat) {\n            if (tags.debug) {\n                console.log(`[${tags.system}] ${shoutResponseTag} _listener`, listenerThat);\n            }\n            shoutResponseHandler(listenerThat, (result) => {\n                // The response handler has resolved.\n                cleanup();\n                resolve(result);\n            })\n        }\n\n        // Cleanup timeout and listen tag listeners.\n        function cleanup () {\n            if (tags.debug) {\n                console.log(`[${tags.system}] cleaned up timeout and listener.`);\n            }\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n            }\n            removeListenTagListener(null, shoutResponseTag, _listener);\n        }\n\n        if (tags.debug) {\n            console.log(`[${tags.system}] listening for shout response: ${shoutResponseTag}`);\n        }\n        addListenTagListener(null, shoutResponseTag, _listener);\n    });\n\n    if (tags.debug) {\n        console.log(`[${tags.system}] shout ${shoutTag} with arg:`, shoutArg);\n    }\n    superShout(shoutTag, shoutArg);\n\n    return responsePromise;\n}\n\nthisBot.vars.sideLoadedSharedDataHooks = [];\n\n/**\n * Register the given bot's tag to automatically synchronizing with the given sharedDataTag.\n * This will handle changes to the bot's tag syncing with the side loaded share data as well as vice versa.\n * \n * @param botId {string} Bot Id to register the hook for\n * @param botTag {string} The tag on the bot to keep in sync.\n * @param sharedDataTag {string} The name of the tag in the side loaded shared data to synchronize the bot's tag with.\n */\nfunction registerSideLoadedSharedDataHook(botId, botTag, sharedDataTag) {\n    assert(botId, `${tags.system} botId is required.`);\n    assert(botTag, `${tags.system} botTag is required.`);\n    assert(sharedDataTag, `${tags.system} sharedDataTag is required.`);\n\n    thisBot.vars.sideLoadedSharedDataHooks.push({ botId, botTag, sharedDataTag });\n\n    if (tags.debug) {\n        console.log(`[registerSideLoadedSharedDataHook] botId: ${botId}, botTag: ${botTag}, sharedDataTag: ${sharedDataTag}`);\n    }\n}\n\n/**\n * Unregister the given bot's tag from automatically synchronizing with the given sharedDataTag.\n * \n * @param botId {string} Bot Id to register the hook for\n * @param botTag {string} The tag on the bot to keep in sync.\n * @param sharedDataTag {string} The name of the tag in the side loaded shared data that was being synchronized with.\n */\nfunction unregisterSideLoadedSharedDataHook(botId, botTag, sharedDataTag) {\n    if (!thisBot.vars.sideLoadedSharedDataHooks) {\n        return;\n        }\n\n    for (let i = thisBot.vars.sideLoadedSharedDataHook.length - 1; i >= 0; i--) {\n        let entry = thisBot.vars.sideLoadedSharedDataHook[i];\n\n        if (botId === entry.botId &&\n            botTag === entry.botTag &&\n            sharedDataTag === entry.sharedDataTag\n        ) {\n            entries.splice(i, 1);\n\n            if (tags.debug) {\n                console.log(`[unregisterSideLoadedSharedDataHook] botId: ${botId}, botTag: ${botTag}, sharedDataTag: ${sharedDataTag}`);\n            }\n        }\n    }\n}\n\nglobalThis.SideLoadedSharedDataManager.bot = thisBot;\nglobalThis.SideLoadedSharedDataManager.addListenTagListener = addListenTagListener;\nglobalThis.SideLoadedSharedDataManager.removeListenTagListener = removeListenTagListener;\nglobalThis.SideLoadedSharedDataManager.joinInst = joinInst;\nglobalThis.SideLoadedSharedDataManager.superShoutAndListen = superShoutAndListen;\nglobalThis.SideLoadedSharedDataManager.registerSideLoadedSharedDataHook = registerSideLoadedSharedDataHook;\nglobalThis.SideLoadedSharedDataManager.unregisterSideLoadedSharedDataHook = unregisterSideLoadedSharedDataHook;\n\nif (tags.debug) {\n    console.log('Loaded globalThis.SideLoadedSharedDataManager', SideLoadedSharedDataManager);\n}\n\nshout('onSideLoadedSharedDataManagerLoaded');",
        "onAnyBotsChanged": "@if (!tags.enabled) {\n    return;\n}\n\nif (!thisBot.vars.sideLoadedSharedDataHooks) {\n    return; // This bot has not initialized yet.\n}\n\nfor (let change of that) {\n    const changedBotId = change.bot.id;\n    const changedTags = change.tags;\n    \n    // Iterate through all changed tags on the bot and see if we have any side loaded shared data hooks that match the bot and tag.\n    // If we find a match we need to synchronize the current value of the bot's tag with the side loaded shared data.\n    for (let changedTag of changedTags) {\n        for (let hook of thisBot.vars.sideLoadedSharedDataHooks) {\n            if (hook.botId === changedBotId &&\n                hook.botTag === changedTag\n            ) {\n                // This hook matches the changed bot id and changed tag.\n                // Lets make sure the side loaded shared data has the current value of this bot's tag.\n                superShout('onSideLoadedSharedDataSet', { \n                    tag: hook.sharedDataTag,\n                    value: change.bot.tags[changedTag]\n                });\n            }\n        }\n    }\n}",
        "onAnyListen": "@if (!thisBot.vars.listeners) {\n    return; // This bot has not initialized yet.\n}\n\nconst { \n    name,\n    that: thatParam,\n    targets\n} = that;\n\nconst entries = thisBot.vars.listeners[name];\n\nif (entries && entries.length) {\n    for (let i = 0; i < entries.length; i++) {\n        const entry = entries[i];\n        \n        let invoke = true;\n\n        if (entry.bot) {\n            // Only invoke listener if the bot is one of the targets.\n            let entryBotId = typeof entry.bot === 'string' ? entry.bot : entry.bot.id;\n            invoke = targets && targets.some(t => t.id === entryBotId);\n        }\n\n        if (invoke) {\n            entry.listener(thatParam);\n        }\n    }\n}",
        "onBotAdded": "@if (!globalThis.SideLoadedSharedDataManager) {\n    thisBot.loadLibrary();\n}",
        "onSideLoadedSharedDataLoaded": "@if (!tags.enabled) {\n    return;\n}\n\nif (tags.debug) {\n    console.log(`[${tags.system}] onSideLoadedSharedDataLoaded`, that);\n}\n\nif (!thisBot.vars.sideLoadedSharedDataHooks) {\n    return; // This bot has not initialized yet.\n}\n\nfor (let hook of thisBot.vars.sideLoadedSharedDataHooks) {\n    for (let tag in that) {\n        const value = that[tag];\n\n        if (hook.sharedDataTag === tag) {\n            const botId = hook.botId;\n            const botTag = hook.botTag;\n            const bot = getBot('id', botId);\n            \n            if (bot) {\n                if (bot.tags[botTag] !== value) {\n                    if (tags.debug) {\n                        console.log(`[${tags.system}] initializing botId ${botId} tag ${botTag} to value`, value);\n                    }\n\n                    bot.tags[botTag] = value;\n                } else {\n                    if (tags.debug) {\n                        console.log(`[${tags.system}] botId ${botId} tag ${botTag} already is equal to initial value`);\n                    }\n                }\n            }\n\n            break;\n        }\n    }\n}",
        "onSideLoadedSharedDataUpdated": "@if (!tags.enabled) {\n    return;\n}\n\nconst { tag, value } = that ?? {};\n\nif (tags.debug) {\n    console.log(`[${tags.system}] onSideLoadedSharedDataUpdated`, that);\n}\n\nif (!thisBot.vars.sideLoadedSharedDataHooks) {\n    return; // This bot has not initialized yet.\n}\n\nfor (let hook of thisBot.vars.sideLoadedSharedDataHooks) {\n    if (hook.sharedDataTag === tag) {\n        const botId = hook.botId;\n        const botTag = hook.botTag;\n        const bot = getBot('id', botId);\n        \n        if (bot) {\n            if (bot.tags[botTag] !== value) {\n                if (tags.debug) {\n                    console.log(`[${tags.system}] updating botId ${botId} tag ${botTag} to value`, value);\n                }\n\n                bot.tags[botTag] = value;\n            } else {\n                if (tags.debug) {\n                    console.log(`[${tags.system}] botId ${botId} tag ${botTag} already is equal to updated value`);\n                }\n            }\n\n        }\n    }\n}",
        "sideLoadPattern": "rc-sideLoadedSharedData",
        "sideLoadPatternRecordId": "d5522ef2-a17e-4bed-a557-116903b1b1ed",
        "sideLoadedSharedDataManager": "true",
        "system": "rc-sideLoadedSharedDataManager.manager"
      }
    }
  }
}