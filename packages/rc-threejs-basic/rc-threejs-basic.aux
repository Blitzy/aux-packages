{
  "version": 1,
  "state": {
    "rc-threejs-basic.utils.listenerProxy": {
      "id": "rc-threejs-basic.utils.listenerProxy",
      "space": "shared",
      "tags": {
        "listening": "true",
        "onAnyListen": "@if (!thisBot.vars.listeners) {\n    return; // This bot has not initialized yet.\n}\n\nconst { \n    name,\n    that: thatParam,\n    targets\n} = that;\n\nconst entries = thisBot.vars.listeners[name];\n\nif (entries && entries.length) {\n    for (let i = 0; i < entries.length; i++) {\n        const entry = entries[i];\n        \n        let invoke = true;\n\n        if (entry.bot) {\n            // Only invoke listener if the bot is one of the targets.\n            let entryBotId = typeof entry.bot === 'string' ? entry.bot : entry.bot.id;\n            invoke = targets && targets.some(t => t.id === entryBotId);\n        }\n\n        if (invoke) {\n            entry.listener(thatParam);\n        }\n    }\n}",
        "onBotAdded": "@function addListenTagListener (bot, name, listener) {\n    assert(name, `${tags.system} name is required.`);\n    assert(listener && typeof listener === 'function', `${tags.system} listener function is required.`);\n    \n    let entries = thisBot.vars.listeners[name];\n    if (!entries) {\n        entries = [];\n        thisBot.vars.listeners[name] = entries;\n    }\n\n    entries.push({ listener, bot });\n}\n\nfunction removeListenTagListener (bot, name, listener) {\n    let entries = thisBot.vars.listeners[name];\n    if (!entries) {\n        return;\n    }\n\n    for (let i = entries.length - 1; i >= 0; i--) {\n        let entry = entries[i];\n\n        if (entry.listener != listener) {\n            continue;\n        }\n\n        if (bot) {\n            const botId = typeof bot === 'string' ? bot : bot.id;\n            const entryBotId = typeof entry.bot === 'string' ? entry.bot : entry.bot.id;\n            \n            if (botId !== entryBotId) {\n                continue;\n            }\n        }\n\n        entries.splice(i, 1);\n    }\n}\n\nglobalThis.addListenTagListener = addListenTagListener;\nglobalThis.removeListenTagListener = removeListenTagListener;\n\nthisBot.vars.listeners = {};",
        "onDestroy": "@globalThis.addListenTagListener = undefined;\nglobalThis.removeListenTagListener = undefined;",
        "system": "rc-threejs-basic.utils.listenerProxy"
      }
    },
    "rc-threejs-basic.app": {
      "id": "rc-threejs-basic.app",
      "space": "shared",
      "tags": {
        "App": "@const { useState, useCallback, useEffect, useRef } = os.appHooks;\n\nconst useThree = thisBot.useThree();\n\nconst App = () => {\n    const { three } = useThree();\n    const [ initialized, setInitialized ] = useState(false);\n    const [ renderer, setRenderer ] = useState();\n    const [ scene, setScene ] = useState();\n    const [ camera, setCamera ] = useState();\n    const [ width, setWidth ] = useState();\n    const [ height, setHeight ] = useState();\n    const [ paused, setPaused ] = useState(false);\n    const [ frameDataURL, setFrameDataURL ] = useState();\n    const offscreenCanvasRef = useRef(new self.OffscreenCanvas(512, 512));\n\n    // Initialize three.js webgl renderer with an empty scene and camera.\n    useEffect(() => {\n        if (!three) {\n            // Wait for three to be loaded.\n            return;\n        }\n\n        if (initialized) {\n            // Only run this once.\n            return;\n        }\n\n        const width = gridPortalBot.tags.pixelWidth;\n        const height = gridPortalBot.tags.pixelHeight;\n        const aspect = width / height;\n\n        setWidth(width);\n        setHeight(height);\n\n        // Setup three.js WebGL renderer\n        const newRenderer = new three.WebGLRenderer({\n            canvas: offscreenCanvasRef.current,\n            antialias: true,\n        });\n        // Set width and height of renderer but do not updateStyle as it \n        // will fail due to there not being a true HTMLCanvasElement behind this.\n        newRenderer.setSize(width, height, false);\n        setRenderer(newRenderer);\n\n        // Setup three.js scene.\n        const newScene = new three.Scene();\n        newScene.background = new three.Color('rgb(2, 10, 4)');\n        setScene(newScene);\n\n        // Create and add a green box.\n        const boxGeo = new three.BoxGeometry(1, 1, 1);\n        const boxMat = new three.MeshStandardMaterial({\n            color: new three.Color('rgb(0, 255, 0)')\n        })\n        const boxMesh = new three.Mesh(boxGeo, boxMat);\n        boxMesh.name = 'my-green-box';\n        newScene.add(boxMesh);\n\n        // Create and add a perspective camera.\n        const newCamera = new three.PerspectiveCamera(75, aspect, 0.1, 2000);\n        newScene.add(newCamera);\n        setCamera(newCamera);\n        // Move camera back so that the box is in view of the camera.\n        newCamera.position.z = 5;\n\n        // Create and add a directional light.\n        const dirLight = new three.DirectionalLight(0xfffffff, 1.5);\n        newScene.add(dirLight);\n\n        // Create and add a hemisphere light.\n        const hemiLight = new three.HemisphereLight(0xffffbb, 0x080820, 0.5);\n        newScene.add(hemiLight);\n\n        if (tags.debug) {\n            console.log(`[${tags.system}] initialized`);\n        }\n\n        setInitialized(true);\n\n        return () => {\n            // Free up resources related to WebGL when this app becomes unmounted.\n            newRenderer.dispose();\n        }\n    }, [three, initialized]);\n\n    const onWindowResize = useCallback(() => {\n        if (tags.debug) {\n            console.log(`[${tags.system}] window resize`);\n        }\n        \n        const width = gridPortalBot.tags.pixelWidth;\n        const height = gridPortalBot.tags.pixelHeight;\n        const aspect = width / height;\n\n        setWidth(width);\n        setHeight(height);\n\n        if (renderer) {\n            renderer.setSize(width, height, false);\n        }\n\n        if (camera) {\n            camera.aspect = aspect;\n            camera.updateProjectionMatrix();\n        }\n    }, [renderer, camera]);\n\n    // Setup window resize event handler.\n    useEffect(() => {\n        function onGridPortalBotChanged (listenerThat) {\n            const windowSizeChanged = listenerThat.tags.some((tag) => {\n                return tag === 'pixelWidth' ||\n                       tag === 'pixelHeight'\n            })\n\n            if (windowSizeChanged) {\n                onWindowResize();\n            }\n        }\n\n        addListenTagListener(gridPortalBot, 'onBotChanged', onGridPortalBotChanged);\n\n        return () => {\n            removeListenTagListener(gridPortalBot, 'onBotChanged', onGridPortalBotChanged);\n        }\n    }, [onWindowResize])\n\n    // The update function. It handles animation logic and rendering.\n    const update = useCallback(() => {\n        if (!initialized) {\n            // Need to be initialized.\n            return;\n        }\n\n        if (!paused) {\n            const boxMesh = scene.getObjectByName('my-green-box');\n            boxMesh.rotation.x += 0.02;\n            boxMesh.rotation.y += 0.02;\n        }\n\n        renderer.render(scene, camera);\n\n        const offscreenCanvas = renderer.domElement;\n        offscreenCanvas.convertToBlob().then((blob) => {\n            const reader = new self.FileReader();\n            reader.onload = () => {\n                const base64DataURL = reader.result;\n                setFrameDataURL(base64DataURL);\n            }\n\n            reader.readAsDataURL(blob);\n        })\n    }, [initialized, renderer, scene, camera, paused]);\n\n    // Setup update loop.\n    useEffect(() => {\n        if (renderer) {\n            renderer.setAnimationLoop(update);\n\n            return () => {\n                renderer.setAnimationLoop(null);\n            }\n        }\n    }, [renderer, update])\n\n    const onCloseClick = useCallback(() => {\n        thisBot.unmount();\n    }, [])\n\n    const onPauseClick = useCallback(() => {\n        setPaused(val => !val);\n    }, [])\n\n    return (\n        <>\n            <style>{tags['style.css']}</style>\n            { (initialized && frameDataURL) &&\n                <div className='three-app'>\n                    <img className='frame' src={frameDataURL} width={width} height={height} draggable='false'/>\n                    <button className='close' onClick={onCloseClick}>Close</button>\n                    <button className='pause' onClick={onPauseClick}>{paused ? 'Resume' : 'Pause'}</button>\n                </div>\n            }\n        </>\n    )\n}\n\nreturn App;\n",
        "cursor": "pointer",
        "debug": "true",
        "forceUpdate": "@const App = thisBot.vars.appInstance;\n\nif (App) {\n    os.compileApp(tags.system, <App/>)\n}\n",
        "home": "true",
        "label": "toggle three.js app",
        "mount": "@if (!thisBot.vars.appInstance) {\n    thisBot.vars.appInstance = thisBot.App();\n    await os.registerApp(tags.system, thisBot);\n\n    thisBot.forceUpdate();\n}\n",
        "onClick": "@if (thisBot.vars.appInstance) {\n    thisBot.unmount();\n} else {\n    thisBot.mount();\n}",
        "onDestroy": "@thisBot.unmount();",
        "scaleX": "5",
        "scaleY": "2",
        "scaleZ": "0.3",
        "style.css": ".three-app {\n    background-color: white;\n    padding: 12px;\n}\n\n.three-app .frame {\n    position: fixed;\n    top: 0;\n    left: 0;\n}\n\n.three-app .close {\n    position: fixed;\n    top: 0;\n    right: 0;\n    padding: 6px 16px;\n    margin: 10px;\n}\n\n.three-app .pause {\n    position: fixed;\n    top: 0;\n    left: 0;\n    padding: 6px 16px;\n    margin: 10px;\n}\n",
        "system": "rc-threejs-basic.app",
        "unmount": "@if (thisBot.vars.appInstance) {\n    delete thisBot.vars.appInstance;\n\n    // Compiling the app with an empty root value is a workaround that allows the\n    // previous components to perform their unmounting code properly.\n    await os.compileApp(tags.system, <></>);\n\n    await os.unregisterApp(tags.system);\n}\n",
        "useThree": "@// This is a custom Preact/React hook that loades three.js from CDN and returns the THREE namespace.\nconst { useState, useCallback, useEffect, useRef } = os.appHooks;\n        \nconst useThree = () => {\n    const [ three, setThree ] = useState();\n\n    // Load the three.js module from cdn.\n    useEffect(() => {\n        import('https://cdn.jsdelivr.net/npm/three@0.162.0/+esm').then((module) => {\n            setThree(module);\n        })\n    }, []);\n\n    return {\n        three\n    }\n}\n\nreturn useThree;"
      }
    },
    "rc-threejs-basic._packageInfo": {
      "id": "rc-threejs-basic._packageInfo",
      "space": "shared",
      "tags": {
        "system": "rc-threejs-basic._packageInfo",
        "version": "1.0",
        "versionDate": "📅2024-03-13T13:01:59.701-04:00 local"
      }
    }
  }
}