{
  "version": 1,
  "state": {
    "rc-threejs-object-picking._packageInfo": {
      "id": "rc-threejs-object-picking._packageInfo",
      "space": "shared",
      "tags": {
        "system": "rc-threejs-object-picking._packageInfo",
        "version": "1.6",
        "versionDate": "ðŸ“…2024-06-17T16:25:38.635-04:00 local"
      }
    },
    "rc-threejs-object-picking.app": {
      "id": "rc-threejs-object-picking.app",
      "space": "shared",
      "tags": {
        "App": "@const { useState, useCallback, useEffect, useRef } = os.appHooks;\n\n// (re)load the three sim.\nconst threeSimBot = getBot('threeSim', true);\nconst ThreeSim = await whisper(threeSimBot, 'load')[0];\n\nconst App = () => {\n    const canvasRef = useRef();\n    const [ offscreenCanvas, setOffscreenCanvas ] = useState();\n    const [ simulation, setSimulation ] = useState();\n\n    // Initialize the canvas element.\n    useEffect(() => {\n        if (canvasRef.current) {\n            self.requestAnimationFrame(() => {\n                self.requestAnimationFrame(() => {\n                    self.requestAnimationFrame(() => {\n                        canvasRef.current.transferControlToOffscreen().then((transferredOffscreenCanvas) => {\n                            if (tags.debug) {\n                                console.log(`[${tags.system}] transferred canvas control to offscreen canvas.`);\n                            }\n                            setOffscreenCanvas(transferredOffscreenCanvas);\n                        })\n                    })\n                })\n            })\n        }\n    }, [])\n\n    // Initialize the three simulation.\n    useEffect(() => {\n        if (offscreenCanvas && !simulation) {\n            if (tags.debug) {\n                console.log(`[${tags.system}] init three simulation`);\n            }\n            const sim = new ThreeSim(canvasRef.current, offscreenCanvas);\n            setSimulation(sim);\n        }\n\n        return () => {\n            // Dispose simulation if app is unmounted.\n            if (simulation) {\n                if (tags.debug) {\n                    console.log(`[${tags.system}] unmount app`);\n                }\n                simulation.dispose();\n            }\n        }\n    }, [offscreenCanvas, simulation])\n\n    const onCloseClick = useCallback(() => {\n        thisBot.unmount();\n    }, [])\n\n    return (\n        <>\n            <style>{tags['style.css']}</style>\n            <div className='three-app'>\n                <canvas ref={canvasRef}/>\n                <button className='close' onClick={onCloseClick}>Close</button>\n                <div className='description'>~350 random spinning cubes that can be clicked on to select and make glow.</div>\n            </div>\n        </>\n    )\n}\n\nreturn App;\n",
        "cursor": "pointer",
        "debug": "true",
        "forceUpdate": "@const App = thisBot.vars.appInstance;\n\nif (App) {\n    os.compileApp(tags.system, <App/>)\n}\n",
        "home": "true",
        "label": "toggle three.js app",
        "mount": "@if (!thisBot.vars.appInstance) {\n    thisBot.vars.appInstance = await thisBot.App();\n    await os.registerApp(tags.system, thisBot);\n\n    thisBot.forceUpdate();\n}\n",
        "onClick": "@if (thisBot.vars.appInstance) {\n    thisBot.unmount();\n} else {\n    thisBot.mount();\n}",
        "onDestroy": "@thisBot.unmount();",
        "scaleX": "5",
        "scaleY": "2",
        "scaleZ": "0.3",
        "style.css": ".three-app {\n}\n\n.three-app canvas {\n    position: fixed;\n    top: 0;\n    left: 0;\n}\n\n.three-app .close {\n    position: fixed;\n    top: 0;\n    right: 0;\n    padding: 6px 16px;\n    margin: 10px;\n}\n\n.three-app .description {\n    width: 100%;\n    margin-bottom: 32px;\n    position: fixed;\n    bottom: 0;\n    color: white;\n    text-align: center;\n}\n",
        "system": "rc-threejs-object-picking.app",
        "unmount": "@if (thisBot.vars.appInstance) {\n    delete thisBot.vars.appInstance;\n\n    // Compiling the app with an empty root value is a workaround that allows the\n    // previous components to perform their unmounting code properly.\n    await os.compileApp(tags.system, <></>);\n\n    await os.unregisterApp(tags.system);\n}\n"
      }
    },
    "rc-threejs-object-picking.threeSim": {
      "id": "rc-threejs-object-picking.threeSim",
      "space": "shared",
      "tags": {
        "debug": "true",
        "load": "@const three = await import('https://cdn.jsdelivr.net/npm/three@0.162.0/+esm');\n\nif (tags.debug) {\n    console.log(`[${tags.system}] three module:`, three);\n}\n\nconst {\n    WebGLRenderer,\n    sRGBEncoding,\n    Scene,\n    PerspectiveCamera,\n    DirectionalLight,\n    PointLight,\n    HemisphereLight,\n    Color,\n    Clock,\n    BoxGeometry,\n    MeshStandardMaterial,\n    Mesh,\n    Raycaster,\n    MathUtils,\n} = three;\n\nclass Event {\n    constructor() {\n        this.listeners = [];\n    }\n\n    addListener(listener) {\n        this.listeners.push(listener);\n    }\n\n    removeListener(listener) {\n        const index = this.listeners.findIndex(l => l === listener);\n        if (index >= 0) {\n            this.listeners.splice(index, 1);\n        }\n    }\n\n    removeAllListeners() {\n        this.listeners = [];\n    }\n\n    invoke(...args) {\n        for (let listener of this.listeners) {\n            listener(...args);\n        }\n    }\n}\n\nclass ObjectPicker {\n    get pickedObject() {\n        return this._pickedObject;\n    }\n\n    set pickedObject(value) {\n        if (this._pickedObject !== value) {\n            const previous = this._pickedObject;\n            this._pickedObject = value;\n            this.onPickedObjectChanged.invoke({ previous, current: value });\n        }\n    }\n    constructor(canvasElement) {\n        this.canvas = canvasElement;\n        this.raycaster = new Raycaster();\n        this.onPickedObjectChanged = new Event();\n    }\n\n    async pick(inputEvent, camera, objects) {\n        if (!objects || objects.length === 0) {\n            this.pickedObject = null;\n            return;\n        }\n\n        // Get input position relative to canvas.\n        const canvasRect = await this.canvas.getBoundingClientRect();\n        const canvasInput = {\n            x: (inputEvent.clientX - canvasRect.left) * this.canvas.width / canvasRect.width,\n            y: (inputEvent.clientY - canvasRect.top) * this.canvas.height / canvasRect.height\n        }\n\n        // Convert to relative canvas position to Normalized Device Coordinates (NDC).\n        const ndc = { \n            x: (canvasInput.x / this.canvas.width) * 2 - 1,\n            y: (canvasInput.y / this.canvas.height) * -2 + 1 \n        }\n\n        this.raycaster.setFromCamera(ndc, camera);\n        const intersectedObjects = this.raycaster.intersectObjects(objects);\n        if (intersectedObjects.length > 0) {\n            this.pickedObject = intersectedObjects[0].object;\n        } else {\n            this.pickedObject = null;\n        }\n    }\n    \n    clear() {\n        this.pickedObject = null;\n    }\n}\n\nclass ThreeSim {\n\n    constructor(canvasElement, offscreenCanvas) {\n        this.canvasElement = canvasElement;\n        this.offscreenCanvas = offscreenCanvas;\n\n        console.log(`[ThreeSim] canvasElement`, canvasElement);\n        console.log(`[ThreeSim] offscreenCanvas`, offscreenCanvas);\n\n        // Setup renderer.\n        this.renderer = new WebGLRenderer({\n            canvas: offscreenCanvas,\n            antialias: true,\n            // alpha: true,\n            powerPreference: 'high-performance',\n        });\n\n        this.renderer.outputEncoding = sRGBEncoding;\n\n        console.log('[ThreeSim] webgl renderer', this.renderer);\n\n        // Setup scene.\n        this.scene = new Scene();\n        this.scene.background = new Color('rgb(10, 10, 10)');\n\n        console.log(`[ThreeSim] scene`, this.scene);\n\n        // Setup camera.\n        this.camera = new PerspectiveCamera(60);\n        this.camera.position.x = 0;\n        this.camera.position.y = 0;\n        this.camera.position.z = 5;\n        this.scene.add(this.camera);\n        this.cameraRadius = 20;\n        this.cameraTheta = 0;\n        this.cameraRotateSpeed = 10;\n\n        console.log(`[ThreeSim] camera`, this.camera);\n\n        // Add light to scene.\n        // const sunLight = new DirectionalLight('#fff', 0.5);\n        // sunLight.position.set(-100, 200, -100);\n        // this.scene.add(sunLight);\n\n        const skyLight = new HemisphereLight('#ccd3hh', '#737063', 0.015);\n        this.scene.add(skyLight);\n\n        this.pointLight = new PointLight(0xffffff, 2, 25, 1.5);\n        this.pointLightTheta = 0;\n        this.pointLightMoveRadius = 15;\n        this.pointLightMoveSpeed = 10;\n        this.scene.add(this.pointLight);\n\n        this.highlightPointLight = new PointLight(0xff0000, 5, 15, 1.25);\n        this.scene.add(this.highlightPointLight);\n        this.highlightPointLight.visible = false;\n\n        // Clocks\n        this.simClock = new Clock();\n        this.renderClock = new Clock();\n\n        // Render variables\n        this.renderFpsSamples = [];\n        this.renderFpsSamplesSize = 10;\n        this.renderSyncTick = 0;\n        this.renderSyncInterval = 1;\n        this.renderFpsAverage = 0;\n        this.onRenderFpsAverageUpdate = new Event();\n\n        this.boxCount = 0;\n        this.onBoxCountUpdate = new Event();\n\n        // Start update loop\n        this.update = this.update.bind(this);\n        this.renderer.setAnimationLoop(this.update);\n\n        // Setup ObjectPicker.\n        this.objectPicker = new ObjectPicker(this.canvasElement);\n        this.onPickedObjectChanged = this.onPickedObjectChanged.bind(this);\n        this.objectPicker.onPickedObjectChanged.addListener(this.onPickedObjectChanged);\n\n        // Input handlers\n        this.onMouseDown = this.onMouseDown.bind(this);\n        this.canvasElement.addEventListener('mousedown', this.onMouseDown);\n        this.onMouseMove = this.onMouseMove.bind(this);\n        this.canvasElement.addEventListener('mousemove', this.onMouseMove);\n\n        // Create the first random box and make it \"picked\".\n        const firstRandomBox = this.addRandomBox();\n        this.objectPicker.pickedObject = firstRandomBox;\n\n        for (let i = 1; i < 350; i++) {\n            this.addRandomBox();\n        }\n\n        // Resize handler\n        this.onGridPortalBotChanged = this.onGridPortalBotChanged.bind(this);\n        addListenTagListener(gridPortalBot, 'onBotChanged', this.onGridPortalBotChanged);\n\n        // Run resize once to make it fit the window properly.\n        this.resize(gridPortalBot.tags.pixelWidth, gridPortalBot.tags.pixelHeight);\n    }\n\n    updateSimulation() {\n        const deltaTime = this.simClock.getDelta();\n\n        let boxCount = 0;\n\n        // Animate boxes\n        this.scene.traverseVisible((obj) => {\n            if (obj.userData.animateRotation) {\n                boxCount++;\n                obj.rotation.x += obj.userData.rotationSpeed * deltaTime;\n                obj.rotation.y += obj.userData.rotationSpeed * deltaTime;\n            }\n        });\n\n        if (boxCount !== this.boxCount) {\n            this.boxCount = boxCount;\n            this.onBoxCountUpdate.invoke(boxCount);\n        }\n\n        // Animate camera\n        this.cameraTheta += this.cameraRotateSpeed * deltaTime;\n        this.camera.position.x = this.cameraRadius * Math.sin( MathUtils.degToRad(this.cameraTheta) );\n        this.camera.position.y = this.cameraRadius * Math.sin( MathUtils.degToRad(this.cameraTheta) );\n        this.camera.position.z = this.cameraRadius * Math.cos( MathUtils.degToRad(this.cameraTheta) );\n        this.camera.lookAt(this.scene.position);\n        this.camera.updateMatrixWorld();\n\n        // Animate point light\n        this.pointLightTheta += this.pointLightMoveSpeed * deltaTime;\n        this.pointLight.position.x = this.pointLightMoveRadius * Math.sin( MathUtils.degToRad(this.pointLightTheta) );\n        this.pointLight.position.y = this.pointLightMoveRadius * Math.sin( MathUtils.degToRad(this.pointLightTheta) );\n        this.pointLight.position.z = this.pointLightMoveRadius * Math.cos( MathUtils.degToRad(this.pointLightTheta) );\n        this.pointLight.updateMatrixWorld();\n    }\n\n    updateRenderer() {\n        this.renderSyncTick++;\n\n        if (this.renderSyncTick >= this.renderSyncInterval) {\n            const deltaTime = this.renderClock.getDelta();\n\n            // Track frames per second.\n            const fps = 1.0 / deltaTime;\n            this.renderFpsSamples.push(fps);\n\n            // If we've collected more samples than the sample size, remove the oldest one\n            if (this.renderFpsSamples.length > this.renderFpsSamplesSize) {\n                this.renderFpsSamples.shift();\n            }\n\n            // Calculate the average FPS over the last few frames\n            let sum = 0;\n            for (let i = 0; i < this.renderFpsSamples.length; i++) {\n                sum += this.renderFpsSamples[i];\n            }\n            let fpsAverage = Math.round(sum / this.renderFpsSamples.length);\n            if (this.renderFpsAverage !== fpsAverage) {\n                this.renderFpsAverage = fpsAverage;\n                this.onRenderFpsAverageUpdate.invoke(fpsAverage);\n            }\n\n            this.renderSyncTick = 0;\n            this.renderer.render(this.scene, this.camera);\n        }\n    }\n\n    update() {\n        this.updateSimulation();\n        this.updateRenderer();\n    }\n\n    addRandomBox() {\n        const POS_X_RANGE = { min: -10, max: 10 };\n        const POS_Y_RANGE = { min: -10, max: 10 };\n        const POS_Z_RANGE = { min: -10, max: 10 };\n\n        const SIZE_X_RANGE = { min: 0.2, max: 2 };\n        const SIZE_Y_RANGE = { min: 0.2, max: 2 };\n        const SIZE_Z_RANGE = { min: 0.2, max: 2 };\n\n        const ROT_X_RANGE = { min: 0, max: Math.PI * 2 };\n        const ROT_Y_RANGE = { min: 0, max: Math.PI * 2 };\n        const ROT_Z_RANGE = { min: 0, max: Math.PI * 2 };\n\n        const ROT_SPEED = 2;\n\n        function randomFromRange(range) {\n            return math.random(range.min, range.max);\n        }\n\n        // Add box to scene.\n        const boxGeo = new BoxGeometry(randomFromRange(SIZE_X_RANGE), randomFromRange(SIZE_Y_RANGE), randomFromRange(SIZE_Z_RANGE));\n        const boxMat = new MeshStandardMaterial({\n            color: new Color(math.random(0, 1), math.random(0, 1), math.random(0, 1))\n        });\n        const box = new Mesh(boxGeo, boxMat);\n        box.userData.animateRotation = true;\n        box.userData.rotationSpeed = ROT_SPEED;\n\n        box.position.x = randomFromRange(POS_X_RANGE);\n        box.position.y = randomFromRange(POS_Y_RANGE);\n        box.position.z = randomFromRange(POS_Z_RANGE);\n\n        box.rotation.x = randomFromRange(ROT_X_RANGE);\n        box.rotation.y = randomFromRange(ROT_Y_RANGE);\n        box.rotation.z = randomFromRange(ROT_Z_RANGE);\n\n        this.scene.add(box);\n\n        return box;\n    }\n\n    onGridPortalBotChanged(listenerThat) {\n        // console.log('onGridPortalBotChanged', listenerThat);\n        const windowSizeChanged = listenerThat.tags.some((tag) => {\n            return tag === 'pixelWidth' ||\n                   tag === 'pixelHeight'\n        })\n\n        if (windowSizeChanged) {\n            this.resize(gridPortalBot.tags.pixelWidth, gridPortalBot.tags.pixelHeight);\n        }\n    }\n\n    resize(width, height, ratio = configBot.tags.defaultPixelRatio) {\n        this.renderer.setSize(width, height, false);\n        this.renderer.setPixelRatio(ratio);\n        this.camera.aspect = width / height;\n        this.camera.updateProjectionMatrix();\n    }\n\n    onMouseMove(event) {\n        // this.objectPicker.pick(event, this.camera, this.scene.children);\n    }\n\n    async onMouseDown(event) {\n        await this.objectPicker.pick(event, this.camera, this.scene.children);\n    }\n\n    onPickedObjectChanged({ previous, current }) {\n        if (previous) {\n            previous.material.emissive = new Color(0, 0, 0);\n            this.highlightPointLight.visible = false;\n        }\n\n        if (current) {\n            current.material.emissive = current.material.color;\n            this.highlightPointLight.visible = true;\n            this.highlightPointLight.color = current.material.color;\n            this.highlightPointLight.position.copy(current.position);\n        }\n    }\n\n    dispose() {\n        console.log('[ThreeSim] dispose')\n        this.renderer.setAnimationLoop(null);\n        this.renderer.dispose();\n        this.objectPicker.clear();\n\n        this.onBoxCountUpdate.removeAllListeners();\n\n        removeListenTagListener(gridPortalBot, 'onBotChanged', this.onGridPortalBotChanged);\n    }\n}\n\nreturn ThreeSim;",
        "system": "rc-threejs-object-picking.threeSim",
        "threeSim": "true"
      }
    },
    "rc-threejs-object-picking.utils.listenerProxy": {
      "id": "rc-threejs-object-picking.utils.listenerProxy",
      "space": "shared",
      "tags": {
        "listening": "true",
        "onAnyListen": "@if (!thisBot.vars.listeners) {\n    return; // This bot has not initialized yet.\n}\n\nconst { \n    name,\n    that: thatParam,\n    targets\n} = that;\n\nconst entries = thisBot.vars.listeners[name];\n\nif (entries && entries.length) {\n    for (let i = 0; i < entries.length; i++) {\n        const entry = entries[i];\n        \n        let invoke = true;\n\n        if (entry.bot) {\n            // Only invoke listener if the bot is one of the targets.\n            let entryBotId = typeof entry.bot === 'string' ? entry.bot : entry.bot.id;\n            invoke = targets && targets.some(t => t.id === entryBotId);\n        }\n\n        if (invoke) {\n            entry.listener(thatParam);\n        }\n    }\n}",
        "onBotAdded": "@function addListenTagListener (bot, name, listener) {\n    assert(name, `${tags.system} name is required.`);\n    assert(listener && typeof listener === 'function', `${tags.system} listener function is required.`);\n    \n    let entries = thisBot.vars.listeners[name];\n    if (!entries) {\n        entries = [];\n        thisBot.vars.listeners[name] = entries;\n    }\n\n    entries.push({ listener, bot });\n}\n\nfunction removeListenTagListener (bot, name, listener) {\n    let entries = thisBot.vars.listeners[name];\n    if (!entries) {\n        return;\n    }\n\n    for (let i = entries.length - 1; i >= 0; i--) {\n        let entry = entries[i];\n\n        if (entry.listener != listener) {\n            continue;\n        }\n\n        if (bot) {\n            const botId = typeof bot === 'string' ? bot : bot.id;\n            const entryBotId = typeof entry.bot === 'string' ? entry.bot : entry.bot.id;\n            \n            if (botId !== entryBotId) {\n                continue;\n            }\n        }\n\n        entries.splice(i, 1);\n    }\n}\n\nglobalThis.addListenTagListener = addListenTagListener;\nglobalThis.removeListenTagListener = removeListenTagListener;\n\nthisBot.vars.listeners = {};",
        "onDestroy": "@globalThis.addListenTagListener = undefined;\nglobalThis.removeListenTagListener = undefined;",
        "system": "rc-threejs-object-picking.utils.listenerProxy"
      }
    }
  }
}