{
  "version": 1,
  "state": {
    "rc-xr.core.leftWrist": {
      "id": "rc-xr.core.leftWrist",
      "space": "shared",
      "tags": {
        "onInitialize": "@leftWristPortalBot.tags.wristPortalWidth = -1;\nleftWristPortalBot.tags.wristPortalHeight = -1;\n\n// Compass Calibration Button\ncreate(modFactory.button({\n    space: 'tempLocal',\n    dimension: configBot.tags.leftWristPortalName,\n    dimensionX: 5.5,\n    dimensionY: 3,\n    label: 'Compass Calibration',\n    onClick: `@\n        spatialCalibration.compassCalibration();\n    `\n}));\n\n// Totem Calibration Button\ncreate(modFactory.button({\n    space: 'tempLocal',\n    dimension: configBot.tags.leftWristPortalName,\n    dimensionX: 5.5,\n    dimensionY: 4,\n    onAdded: `@\n        tags.label = 'Start Totem Calibration';\n\n        tags.onTotemSetupStarted = \\`@\n            tags.label = 'Stop Totem Calibration';\n        \\`;\n\n        tags.onTotemSetupStopped = \\`@\n            tags.label = 'Start Totem Calibration';\n        \\`;\n    `,\n    onClick: `@\n        if (totemInput.tags.enabled) {\n            totemInput.stop();\n        } else {\n            totemInput.start();\n        }\n    `\n}));",
        "system": "rc-xr.core.leftWrist"
      }
    },
    "rc-xr.core.transformHelpers": {
      "id": "rc-xr.core.transformHelpers",
      "space": "shared",
      "tags": {
        "initialize": "@globalThis.transform = {};\n\ntransform.getBotPosition = (bot, dimension) => {\n    return {\n        x: bot.tags[`${dimension}X`],\n        y: bot.tags[`${dimension}Y`],\n        z: bot.tags[`${dimension}Z`],\n    }\n}\n\ntransform.setBotPosition = (bot, dimension, position) => {\n    bot.tags[`${dimension}X`] = position.x;\n    bot.tags[`${dimension}Y`] = position.y;\n    bot.tags[`${dimension}Z`] = position.z;\n}\n\ntransform.getBotRotation = (bot, dimension) => {\n    const rotation = bot.tags[`${dimension}Rotation`];\n    if (rotation) {\n        return rotation;\n    } else {\n        return {\n            x: bot.tags[`${dimension}RotationX`],\n            y: bot.tags[`${dimension}RotationY`],\n            z: bot.tags[`${dimension}RotationZ`],\n        }\n    }\n}\n\ntransform.setBotRotation = (bot, dimension, rotation) => {\n    if (rotation.quaternion) {\n        bot.tags[`${dimension}Rotation`] = rotation;\n        delete bot.tags[`${dimension}RotationX`];\n        delete bot.tags[`${dimension}RotationY`];\n        delete bot.tags[`${dimension}RotationZ`];\n    } else {\n        bot.tags[`${dimension}RotationX`] = rotation.x;\n        bot.tags[`${dimension}RotationY`] = rotation.y;\n        bot.tags[`${dimension}RotationZ`] = rotation.z;\n    }\n}\n\ntransform.getBotScale = (bot) => {\n    return {\n        x: bot.tags[`scaleX`],\n        y: bot.tags[`scaleY`],\n        z: bot.tags[`scaleZ`],\n    }\n}\n\ntransform.setBotScale = (bot, scale) => {\n    bot.tags[`scaleX`] = scale.x;\n    bot.tags[`scaleY`] = scale.y;\n    bot.tags[`scaleZ`] = scale.z;\n}\n\ntransform.lookAtPoint = (eyeBot, eyeBotDimension, point) => {\n    const targetPos = {...point};\n    const eyePos = transform.getBotPosition(eyeBot, eyeBotDimension);\n    \n    const direction = math.subtractVectors(targetPos, eyePos);\n\n    const lookRotation = new Rotation({\n        direction,\n        upwards: new Vector3(0, 0, 1),\n        errorHandling: 'nudge',\n    })\n\n    transform.setBotRotation(eyeBot, eyeBotDimension, lookRotation);\n}\n\ntransform.lookAtBot = ( eyeBot, eyeBotDimension, targetBot, targetDimension ) => {\n    const targetPos = transform.getBotPosition( targetBot, targetDimension );\n    transform.lookAtPoint(eyeBot, eyeBotDimension, targetPos);\n}",
        "onDestroy": "@globalThis.transform = undefined;",
        "onEggHatch": "@thisBot.initialize();",
        "onInstJoined": "@thisBot.initialize();",
        "system": "rc-xr.core.transformHelpers"
      }
    },
    "rc-xr.core.mainSceneDragHandler": {
      "id": "rc-xr.core.mainSceneDragHandler",
      "space": "shared",
      "tags": {
        "debug": "true",
        "onAnyBotDrag": "@const dim = that.from.dimension;\nconst dragBot = that.bot;\n\nconst isFromHandledDimension = dim === 'home' || \n                               dim === mainSceneBot.tags.formAddress || \n                               dim === configBot.tags.leftWristPortalName;\nif (!isFromHandledDimension) {\n    return;\n}\n\nconst isToBeIgnored = dragBot.tags.ignoreMainSceneHandler;\nif (isToBeIgnored) {\n    return;\n}\n\nif (tags.debug) {\n    console.log(`[mainSceneDragHandler] add drop grids`);\n}\n\nos.addDropGrid(\n    {\n        portalBot: mainSceneBot,\n        showGrid: false,\n        priority: 100,\n        bounds: { x: 10000, y: 10000 }\n    },\n    {\n        portalBot: configBot,\n        portalTag: 'leftWristPortal',\n        priority: 200,\n        showGrid: true,\n        position: { x: 3, y: 2, z: 0 },\n        bounds: { x: 10, y: 10 }\n    }\n)\n",
        "system": "rc-xr.core.mainSceneDragHandler"
      }
    },
    "rc-xr.app.app": {
      "id": "rc-xr.app.app",
      "space": "shared",
      "tags": {
        "App": "@const css = compileCSS([ thisBot ])\nconst { useState, useCallback } = os.appHooks;\n\nconst EnterXRButton = ({ mode, onClick }) => {\n    if (mode !== 'vr' && mode !== 'ar') {\n        console.warn(`[EnterXRButton] Unknown mode ${mode}, defaulting to vr`);\n        mode = 'vr';\n    }\n\n    return (\n        <button className='enter-xr-button' onClick={onClick}>Enter {mode.toUpperCase()}</button>\n    )\n}\n\nconst App = () => {\n    const onEnterVRClick = () => {\n        os.enableVR();\n    }\n\n    const onEnterARClick = () => {\n        os.enableAR();\n    }\n\n    let supportsAR = os.device().supportsAR;\n    let supportsVR = os.device().supportsVR;\n\n    return (\n        <>  \n            <style>{css}</style>\n            <div className='enter-xr-buttons'>\n                { supportsAR &&\n                    <EnterXRButton mode='ar' onClick={onEnterARClick}/>\n                }\n                { supportsVR && \n                    <EnterXRButton mode='vr' onClick={onEnterVRClick}/>\n                }\n            </div>\n            \n        </>\n    )\n}\n\nreturn App;",
        "App.css": ".enter-xr-buttons {\n    position: fixed;\n    display: flex;\n    flex-direction: row;\n    width: 100%;\n    justify-content: center;\n    column-gap: 40px;\n    bottom: 15vh;\n}\n\n.enter-xr-buttons button {\n    background-color: transparent;\n    color: white;\n    font-size: 1.25em;\n    padding: 14px 28px;\n    border-radius: 6px;\n    border-style: solid;\n    border-width: 2px;\n    border-color: white;\n    cursor: pointer;\n    user-select: none;\n}\n\n@media (hover) {\n    .enter-xr-buttons button:hover {\n        background-color: #666;\n    }\n}\n\n.enter-xr-buttons button:active {\n    background-color: #888;\n}",
        "appId": "app",
        "mount": "@if (!thisBot.vars.appInstance) {\n    thisBot.vars.appInstance = thisBot.App();\n    await os.registerApp(tags.appId, thisBot);\n\n    thisBot.refresh();\n}",
        "onInitialize": "@thisBot.mount();",
        "refresh": "@const App = thisBot.vars.appInstance;\n\nif (App) {\n    os.compileApp(tags.appId, <App/>);\n}",
        "system": "rc-xr.app.app",
        "unmount": "@if (thisBot.vars.appInstance) {\n    thisBot.vars = {};\n    clearTagMasksStartingWith(thisBot, 'app_');\n    await os.unregisterApp(tags.appId);\n}"
      }
    },
    "rc-xr._packageInfo": {
      "id": "rc-xr._packageInfo",
      "space": "shared",
      "tags": {
        "system": "rc-xr._packageInfo",
        "version": "1.5",
        "versionDate": "📅2024-01-30T15:17:51.443-05:00 local"
      }
    },
    "rc-xr.core.initialize": {
      "id": "rc-xr.core.initialize",
      "space": "shared",
      "tags": {
        "initialize": "@if (masks.initialized) {\n    return;\n}\n\nmasks.initialized = true;\n\ngridPortalBot.tags.portalCameraType = 'perspective';\nleftWristPortalBot.tags.portalGridScale = 0.025;\nrightWristPortalBot.tags.portalGridScale = 0.025;\n\n// Initialize config bot with custom tags and actions.\nconfigBot.tags.inVR = false;\nconfigBot.tags.leftWristPortalName = `${configBot.id}_userMenu`;\n\nconfigBot.tags.onEnterVR = `@\n    tags.inVR = true;\n    tags.leftWristPortal = tags.leftWristPortalName;\n`;\nconfigBot.tags.onExitVR = `@\n    tags.inVR = false;\n    tags.leftWristPortal = null;\n`;\nconfigBot.tags.inAR = false;\nconfigBot.tags.onEnterAR = `@\n    tags.inAR = true;\n    tags.leftWristPortal = tags.leftWristPortalName;\n`;\nconfigBot.tags.onExitAR = `@\n    tags.inAR = false;\n    tags.leftWristPortal = null;\n`;\n\nif (navigator.userAgent.match(/Android|iPhone|iPad|Windows Phone|Mobile/i)) {\n    configBot.tags.isMobile = true;\n} else {\n    configBot.tags.isMobile = false;\n}\n\n// Create the main scene dimension bot.\nglobalThis.mainSceneBot = create({\n    space: 'tempLocal',\n    form: 'dimension',\n    formAddress: tags.mainSceneDimension,\n    [tags.rootDimension]: true,\n    [`${tags.rootDimension}X`]: 0,\n    [`${tags.rootDimension}Y`]: 0,\n    [`${tags.rootDimension}Z`]: 0,\n    [`${tags.rootDimension}RotationX`]: 0,\n    [`${tags.rootDimension}RotationY`]: 0,\n    [`${tags.rootDimension}RotationZ`]: 0,\n});\n\nif (tags.showCompass === true) {\n    create({\n        space: 'tempLocal',\n        form: 'sprite',\n        formAddress: 'https://builder-ltm-files.s3.amazonaws.com/01744d47743abb827275b7bb865f26e4386039798d9753d521399515dc370fab.png',\n        draggable: false,\n        pointable: false,\n        [tags.mainSceneDimension]: true,\n        [`${tags.mainSceneDimension}Z`]: -1.5,\n        scale: 3,\n    });\n}\n\nshout('onSetup');\nshout('onInitialize');",
        "leftWristCalibrationButtons": "true",
        "mainSceneDimension": "mainScene",
        "onEggHatch": "@thisBot.initialize();",
        "onInstJoined": "@thisBot.initialize();",
        "rootDimension": "home",
        "showCompass": "true",
        "system": "rc-xr.core.initialize"
      }
    },
    "rc-xr.core.spatialCalibration": {
      "id": "rc-xr.core.spatialCalibration",
      "space": "shared",
      "tags": {
        "compassCalibration": "@if (!globalThis.mainSceneBot) {\n    console.error('Compass calibration needs mainSceneBot to be loaded.');\n    return;\n}\n\nconst dim = os.getCurrentDimension();\nconst camPos = os.getCameraPosition('grid');\n\nmainSceneBot.tags[`${dim}X`] = camPos.x;\nmainSceneBot.tags[`${dim}Y`] = camPos.y;\n\nconst camRot = os.getCameraRotation('grid');\nmainSceneBot.tags[`${dim}RotationZ`] = camRot.z;",
        "onDestroy": "@globalThis.spatialCalibration = undefined;",
        "onInitialize": "@globalThis.spatialCalibration = thisBot;",
        "system": "rc-xr.core.spatialCalibration",
        "totemCalibration": "@const {\n    positionTotemA,\n    positionTotemB,\n} = that;\n\nconst dim = os.getCurrentDimension();\nconst posMid = vector3.lerp( positionTotemA, positionTotemB, 0.5 );\n\nmainSceneBot.tags[`${dim}X`] = posMid.x;\nmainSceneBot.tags[`${dim}Y`] = posMid.y;\n\nconst dir = math.subtractVectors( positionTotemB, positionTotemA );\nconst rotZ = Math.atan2( dir.y, dir.x ) - ( Math.PI / 2 );\nmainSceneBot.tags[`${dim}RotationZ`] = rotZ;"
      }
    },
    "rc-xr.core.totemInput": {
      "id": "rc-xr.core.totemInput",
      "space": "shared",
      "tags": {
        "getUnsetTotem": "@return [links.totemA, links.totemB].find(t => !t.tags.isSet);",
        "onBotAdded": "@globalThis.totemInput = thisBot;",
        "onDestroy": "@thisBot.stop();\nglobalThis.totemInput = undefined;",
        "onUpdate": "@if (!tags.enabled) {\n    return;\n}\n\nconst isMobile = configBot.tags.isMobile;\nconst inXR = configBot.tags.inVR || configBot.tags.inAR;\n\nlet pointerType;\nif (os.getInputList().includes('rightPointer')) {\n    pointerType = 'right';\n} else if (os.getInputList().includes('leftPointer')) {\n    pointerType = 'left';\n} else if (isMobile && inXR) {\n    pointerType = 'none';\n} else {\n    pointerType = 'mouse';\n}\n\nconst pos = os.getPointerPosition(pointerType);\nconst dir = os.getPointerDirection(pointerType);\nconst hit = math.intersectPlane(pos, dir);\n\nconst setHomePos = (bot, pos) => {\n    bot.tags.homeX = pos.x;\n    bot.tags.homeY = pos.y;\n    bot.tags.homeZ = pos.z;\n}\n\nif (hit) {\n    let controllerType;\n    let button;\n\n    switch (pointerType) {\n        case 'right':\n            controllerType = 'rightPointer';\n            button = 'primary';\n            break;\n        case 'left':\n            controllerType = 'leftPointer';\n            button = 'primary';\n            break;\n        case 'none':\n            controllerType = 'nonePointer';\n            button = 'primary';\n            break;\n        case 'mouse':\n            controllerType = 'mousePointer';\n            button = 'left';\n            break;\n    }\n    \n    let state = os.getInputState(controllerType, button);\n\n    if (!masks.pointerDown) {\n        if (state === 'down' || state === 'held') {\n            masks.pointerDown = true;\n\n            // On pointer down.\n            let totem = thisBot.getUnsetTotem();\n\n            if (totem) {\n                totem.tags.home = true;\n                setHomePos(totem, hit);\n            }\n        }\n    } else {\n        if (state === 'held') {\n            // On pointer held.\n            let totem = thisBot.getUnsetTotem();\n            if (totem) {\n                setHomePos(totem, hit);\n            }\n        } else if (!state) {\n            masks.pointerDown = false;\n\n            // On pointer up/click.\n            let totem = thisBot.getUnsetTotem();\n            if (totem) {\n                console.log(`[totemInput] set totem pos: ${JSON.stringify(hit)}`);\n                setHomePos(totem, hit);\n                totem.tags.isSet = true;\n                totem.tags.color = '#888';\n\n                shout('onTotemSet', { totem });\n            }\n\n            totem = thisBot.getUnsetTotem();\n            if (!totem) {\n                // All totems are set.\n                console.log(`[totemInput] all totems set`);\n                shout('onTotemSetupComplete', { totemA: links.totemA, totemB: links.totemB });\n\n                spatialCalibration.totemCalibration({\n                    positionTotemA: transform.getBotPosition(links.totemA, 'home'),\n                    positionTotemB: transform.getBotPosition(links.totemB, 'home')\n                });\n\n                thisBot.stop();\n            }\n        }\n    }\n}",
        "start": "@if (tags.enabled) {\n    thisBot.stop();\n}\n\nmasks.enabled = true;\ngridPortalBot.tags.portalPannable = false;\ngridPortalBot.tags.portalRotatable = false;\n\nconst dim = 'home';\n\n// Setup totem bots.\nlet mod = {\n    space: 'tempLocal',\n    isSet: false,\n    [dim]: false,\n    [`${dim}X`]: 0,\n    [`${dim}Y`]: 0,\n    [`${dim}Z`]: 0,\n    color: '#f00',\n    scaleY: 0.5,\n    scaleX: 0.5,\n    scaleZ: 2,\n    draggable: false,\n}\n\nmasks.totemA = create(mod).link;\nmasks.totemB = create(mod).link;\n\nmasks.intervalId = setInterval(thisBot.onUpdate, 100);\nmasks.pointerDown = null;\n\nos.toast('Totem calibration started. Tap/Click on ground to place totems.', 4);\n\nshout('onTotemSetupStarted');\n\nreturn [links.totemA, links.totemB];",
        "stop": "@if (!tags.enabled) {\n    return;\n}\n\ngridPortalBot.tags.portalPannable = true;\ngridPortalBot.tags.portalRotatable = true;\n\nclearInterval(masks.intervalId);\nmasks.pointerDown = null;\n\ndestroy(links.totemA);\nmasks.totemA = null;\n\ndestroy(links.totemB);\nmasks.totemB = null;\n\nmasks.totemToSet = null;\nmasks.enabled = null;\n\nshout('onTotemSetupStopped');",
        "system": "rc-xr.core.totemInput"
      }
    },
    "rc-xr.app.compileCSS": {
      "id": "rc-xr.app.compileCSS",
      "space": "shared",
      "tags": {
        "onDestroy": "@globalThis.compileCSS = undefined;",
        "onSetup": "@globalThis.compileCSS = (bots) => {\n    bots = Array.isArray(bots) ? bots : [bots];\n\n    let css = [];\n\n    for (let bot of bots) {\n        for (let key in bot.tags) {\n            if (key.toLowerCase().endsWith('css')) {\n                if (tags.debug) {\n                    console.log(`[compileCSS] found CSS key: ${key}`);\n                }\n                css.push(bot.tags[key]);\n            }\n        }\n    }\n\n    const compiled = css.join('\\n\\n');\n    if (tags.debug) {\n        console.log(`[compileCSS] compiled CSS:\\n\\n`, compiled);\n    }\n\n    return compiled;\n};",
        "system": "rc-xr.app.compileCSS"
      }
    },
    "rc-xr.core.math": {
      "id": "rc-xr.core.math",
      "space": "shared",
      "tags": {
        "onDestroy": "@globalThis.rc.mathUtils = undefined;\nglobalThis.rc.vector3 = undefined;\nglobalThis.rc.quaternion = undefined;\nglobalThis.rc.matrix4 = undefined;",
        "onInitialize": "@// ==========\n// math utils\n// ==========\nglobalThis.mathUtils = {};\n\nmathUtils.clamp = (value, min, max) => {\n\treturn Math.max(min, Math.min(max, value));\n}\n\nmathUtils.fmod = (a,b) => { \n\treturn Number((a - (Math.floor(a / b) * b)).toPrecision(8)); \n}\n\nmathUtils.wrapTo2Pi = (a) => { \n\ta = mathUtils.fmod(a, Math.PI * 2);\n\treturn a;\n}\n\nmathUtils.flipYZ = (v, sign) => {\n    const y = v.y;\n    const z = v.z;\n    v.z = y;\n    v.y = sign ? -z : z;\n}\n\n// ==========\n// vector3\n// ==========\nglobalThis.vector3 = {};\n\nvector3.zero = () => {\n\treturn {x: 0, y: 0, z: 0}\n}\n\nvector3.up = () => {\n\treturn {x: 0, y: 1, z: 0}\n}\n\nvector3.one = () => {\n\treturn {x: 1, y: 1, z: 1}\n}\n\nvector3.applyQuaternion = (v, q) => {\n\t\tconst x = v.x, y = v.y, z = v.z;\n\t\tconst qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n\n\t\t// calculate quat * vector\n\t\tconst ix = qw * x + qy * z - qz * y;\n\t\tconst iy = qw * y + qz * x - qx * z;\n\t\tconst iz = qw * z + qx * y - qy * x;\n\t\tconst iw = - qx * x - qy * y - qz * z;\n\n\t\t// calculate result * inverse quat\n\t\tv.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\n\t\tv.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\n\t\tv.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\n\n\t\treturn v;\n}\n\nvector3.lengthSq = (v) => {\n    return v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nvector3.dot = (v1, v2) => {\n    return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;\n}\n\nvector3.angle = (v1, v2) => {\n\t\tconst denominator = Math.sqrt( vector3.lengthSq(v1) * vector3.lengthSq(v2) );\n\t\tif ( denominator === 0 ) return Math.PI / 2;\n\n\t\tconst theta = vector3.dot(v1, v2) / denominator;\n\t\t// clamp, to handle numerical problems\n\t\treturn Math.acos(mathUtils.clamp(theta, - 1, 1));\n}\n\nvector3.lerp = (v1, v2, t) => {\n    return {\n        x: v1.x + (v2.x - v1.x) * t,\n\t\ty: v1.y + (v2.y - v1.y) * t,\n\t\tz: v1.z + (v2.z - v1.z) * t\n    }\n}\n\nvector3.length = (v) => {\n\treturn Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n}\n\nvector3.lengthSq = (v) => {\n\treturn v.x * v.x + v.y * v.y + v.z * v.z;\n}\n\nvector3.applyMatrix4 = (v, m) => {\n\tconst x = v.x, y = v.y, z = v.z;\n\tconst w = 1 / (m[3] * x + m[7] * y + m[11] * z + m[15]);\n\n\tv.x = (m[0] * x + m[4] * y + m[8] * z + m[12]) * w;\n\tv.y = (m[1] * x + m[5] * y + m[9] * z + m[13]) * w;\n\tv.z = (m[2] * x + m[6] * y + m[10] * z + m[14]) * w;\n\n\treturn v;\n}\n\nvector3.multiplyScalar = (v, s) => {\n\tv.x *= s;\n\tv.y *= s;\n\tv.z *= s;\n\n\treturn v;\n}\n\nvector3.crossVectors = (a, b) => {\n\tconst v = vector3.zero();\n\tconst ax = a.x, ay = a.y, az = a.z;\n\tconst bx = b.x, by = b.y, bz = b.z;\n\n\tv.x = ay * bz - az * by;\n\tv.y = az * bx - ax * bz;\n\tv.z = ax * by - ay * bx;\n\treturn v;\n}\n\nvector3.applyEuler = (v, euler, order = 'XYZ') => {\n\treturn vector3.applyQuaternion(v, quaternion.fromEuler(euler, order));\n}\n\nvector3.applyAxisAngle = (v, axis, angle) => {\n\treturn vector3.applyQuaternion( v, quaternion.setFromAxisAngle( axis, angle ) );\n}\n\nvector3.setFromRotationMatrix = (m, order = 'XYZ') => {\n\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\t// console.log(`[vector3.setFromRotationMatrix] 1. matrix`, JSON.stringify(m));\n\tconst m11 = m[0], m12 = m[4], m13 = m[8];\n\tconst m21 = m[1], m22 = m[5], m23 = m[9];\n\tconst m31 = m[2], m32 = m[6], m33 = m[10];\n\tconst v = vector3.zero();\n\n\tswitch (order) {\n\t\tcase 'XYZ':\n\t\t\tv.y = Math.asin(mathUtils.clamp(m13, - 1, 1));\n\n\t\t\tif (Math.abs(m13) < 0.9999999) {\n\t\t\t\tv.x = Math.atan2(- m23, m33);\n\t\t\t\tv.z = Math.atan2(- m12, m11);\n\t\t\t} else {\n\t\t\t\tv.x = Math.atan2(m32, m22);\n\t\t\t\tv.z = 0;\n\t\t\t}\n\t\t\t// console.log(`[vector3.setFromRotationMatrix] 2. XYZ swizzle`, JSON.stringify(v));\n\t\t\tbreak;\n\t\tcase 'YXZ':\n\t\t\tv.x = Math.asin(- mathUtils.clamp(m23, - 1, 1));\n\n\t\t\tif (Math.abs(m23) < 0.9999999) {\n\t\t\t\tv.y = Math.atan2(m13, m33);\n\t\t\t\tv.z = Math.atan2(m21, m22);\n\t\t\t} else {\n\t\t\t\tv.y = Math.atan2(- m31, m11);\n\t\t\t\tv.z = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'ZXY':\n\t\t\tv.x = Math.asin(mathUtils.clamp(m32, - 1, 1));\n\n\t\t\tif (Math.abs(m32) < 0.9999999) {\n\t\t\t\tv.y = Math.atan2(- m31, m33);\n\t\t\t\tv.z = Math.atan2(- m12, m22);\n\t\t\t} else {\n\t\t\t\tv.y = 0;\n\t\t\t\tv.z = Math.atan2(m21, m11);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'ZYX':\n\t\t\tv.y = Math.asin(- mathUtils.clamp(m31, - 1, 1));\n\n\t\t\tif (Math.abs(m31) < 0.9999999) {\n\t\t\t\tv.x = Math.atan2(m32, m33);\n\t\t\t\tv.z = Math.atan2(m21, m11);\n\t\t\t} else {\n\t\t\t\tv.x = 0;\n\t\t\t\tv.z = Math.atan2(- m12, m22);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'YZX':\n\t\t\tv.z = Math.asin(mathUtils.clamp(m21, - 1, 1));\n\n\t\t\tif (Math.abs(m21) < 0.9999999) {\n\t\t\t\tv.x = Math.atan2(- m23, m22);\n\t\t\t\tv.y = Math.atan2(- m31, m11);\n\t\t\t} else {\n\t\t\t\tv.x = 0;\n\t\t\t\tv.y = Math.atan2(m13, m33);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'XZY':\n\t\t\tv.z = Math.asin(- mathUtils.clamp(m12, - 1, 1));\n\n\t\t\tif (Math.abs(m12) < 0.9999999) {\n\t\t\t\tv.x = Math.atan2(m32, m22);\n\t\t\t\tv.y = Math.atan2(m13, m11);\n\t\t\t} else {\n\t\t\t\tv.x = Math.atan2(- m23, m33);\n\t\t\t\tv.y = 0;\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconsole.warn('[vector3.setFromRotationMatrix] encountered an unknown order: ' + order);\n\t}\n\n\treturn v;\n}\n\nvector3.setFromQuaternion = (q, order = 'XYZ') => {\n\tconst m = matrix4.compose(vector3.zero(), q, vector3.one());\n\treturn vector3.setFromRotationMatrix(m, order);\n}\n\nvector3.localToWorld = (vector, matrixWorld) => {\n\treturn vector3.applyMatrix4(vector, matrixWorld);\n}\n\nvector3.worldToLocal = (vector, matrixWorld) => {\n\tconst inverseMatrix = matrix4.invert([...matrixWorld]);\n\treturn vector3.applyMatrix4(vector, inverseMatrix);\n}\n\n// ==========\n// quaternion\n// ==========\nglobalThis.quaternion = {};\n\nquaternion.identity = () => {\n\treturn {x: 0, y: 0, z: 0, w: 1};\n}\n\nquaternion.setFromRotationMatrix = (q, m) => {\n\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n\tconst m11 = m[ 0 ], m12 = m[ 4 ], m13 = m[ 8 ];\n\tconst m21 = m[ 1 ], m22 = m[ 5 ], m23 = m[ 9 ];\n\tconst m31 = m[ 2 ], m32 = m[ 6 ], m33 = m[ 10 ];\n\n\tconst trace = m11 + m22 + m33;\n\n\tif ( trace > 0 ) {\n\t\tconst s = 0.5 / Math.sqrt( trace + 1.0 );\n\n\t\tq.w = 0.25 / s;\n\t\tq.x = ( m32 - m23 ) * s;\n\t\tq.y = ( m13 - m31 ) * s;\n\t\tq.z = ( m21 - m12 ) * s;\n\t} else if ( m11 > m22 && m11 > m33 ) {\n\t\tconst s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\n\n\t\tq.w = ( m32 - m23 ) / s;\n\t\tq.x = 0.25 * s;\n\t\tq.y = ( m12 + m21 ) / s;\n\t\tq.z = ( m13 + m31 ) / s;\n\t} else if ( m22 > m33 ) {\n\t\tconst s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\n\n\t\tq.w = ( m13 - m31 ) / s;\n\t\tq.x = ( m12 + m21 ) / s;\n\t\tq.y = 0.25 * s;\n\t\tq.z = ( m23 + m32 ) / s;\n\t} else {\n\t\tconst s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\n\n\t\tq.w = ( m21 - m12 ) / s;\n\t\tq.x = ( m13 + m31 ) / s;\n\t\tq.y = ( m23 + m32 ) / s;\n\t\tq.z = 0.25 * s;\n\t}\n\n\treturn q;\n}\t\n\nquaternion.setFromAxisAngle = (axis, angle) => {\n\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\n\t// assumes axis is normalized\n\tconst q = quaternion.identity();\n\tconst halfAngle = angle / 2, s = Math.sin( halfAngle );\n\n\tq.x = axis.x * s;\n\tq.y = axis.y * s;\n\tq.z = axis.z * s;\n\tq.w = Math.cos(halfAngle);\n\n\treturn q;\n}\n\nquaternion.fromEuler = (euler, order = 'XYZ') => {\n\tconst q = quaternion.identity();\n\tconst x = euler.x, y = euler.y, z = euler.z;\n\n\t// http://www.mathworks.com/matlabcentral/fileexchange/\n\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/content/SpinCalc.m\n\tconst c1 = Math.cos( x / 2 );\n\tconst c2 = Math.cos( y / 2 );\n\tconst c3 = Math.cos( z / 2 );\n\n\tconst s1 = Math.sin( x / 2 );\n\tconst s2 = Math.sin( y / 2 );\n\tconst s3 = Math.sin( z / 2 );\n\n\tswitch ( order ) {\n\t\tcase 'XYZ':\n\t\t\tq.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tq.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tq.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tq.w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\tbreak;\n\t\tcase 'YXZ':\n\t\t\tq.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tq.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tq.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tq.w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\tbreak;\n\t\tcase 'ZXY':\n\t\t\tq.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tq.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tq.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tq.w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\tbreak;\n\t\tcase 'ZYX':\n\t\t\tq.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tq.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tq.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tq.w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\tbreak;\n\t\tcase 'YZX':\n\t\t\tq.x = s1 * c2 * c3 + c1 * s2 * s3;\n\t\t\tq.y = c1 * s2 * c3 + s1 * c2 * s3;\n\t\t\tq.z = c1 * c2 * s3 - s1 * s2 * c3;\n\t\t\tq.w = c1 * c2 * c3 - s1 * s2 * s3;\n\t\t\tbreak;\n\t\tcase 'XZY':\n\t\t\tq.x = s1 * c2 * c3 - c1 * s2 * s3;\n\t\t\tq.y = c1 * s2 * c3 - s1 * c2 * s3;\n\t\t\tq.z = c1 * c2 * s3 + s1 * s2 * c3;\n\t\t\tq.w = c1 * c2 * c3 + s1 * s2 * s3;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tconsole.warn( '[quaternion.fromEuler] encountered an unknown order: ' + order);\n\t}\n\n\treturn q;\n}\n\nquaternion.multiplyQuaternions = (a, b) => {\n\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\n\tconsole.log(`[quaternion.multiplyQuaternions] a:`, JSON.stringify(a));\n\tconsole.log(`[quaternion.multiplyQuaternions] b:`, JSON.stringify(b));\n\tconst q = quaternion.identity();\n\tconst qax = a.x, qay = a.y, qaz = a.z, qaw = a.w;\n\tconst qbx = b.x, qby = b.y, qbz = b.z, qbw = b.w;\n\n\tq.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n\tq.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n\tq.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n\tq.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n\n\treturn q;\n}\n\nquaternion.length = (q) => {\n\treturn Math.sqrt( q.x * q.x + q.y * q.y + q.z * q.z + q.w * q.w );\n}\n\nquaternion.normalize = (q) => {\n\tlet l = quaternion.length(q);\n\n\tif (l === 0) {\n\t\tq.x = 0;\n\t\tq.y = 0;\n\t\tq.z = 0;\n\t\tq.w = 1;\n\t} else {\n\t\tl = 1 / l;\n\n\t\tq.x = q.x * l;\n\t\tq.y = q.y * l;\n\t\tq.z = q.z * l;\n\t\tq.w = q.w * l;\n\t}\n\n\treturn q;\n}\n\nquaternion.invert = (q) => {\n\t// quaternion is assumed to have unit length\n\treturn quaternion.conjugate(q);\n}\n\nquaternion.conjugate = (q) => {\n\tq.x *= - 1;\n\tq.y *= - 1;\n\tq.z *= - 1;\n\n\treturn q;\n}\n\n// ==========\n// matrix4\n// ==========\nglobalThis.matrix4 = {};\n\nmatrix4.identity = () => {\n\treturn [\n\t\t1, 0, 0, 0,\n\t\t0, 1, 0, 0,\n\t\t0, 0, 1, 0,\n\t\t0, 0, 0, 1\n\t];\n}\n\nmatrix4.multiplyMatrices = (m, a, b) => {\n\tconst a11 = a[0], a12 = a[4], a13 = a[8], a14 = a[12];\n\tconst a21 = a[1], a22 = a[5], a23 = a[9], a24 = a[13];\n\tconst a31 = a[2], a32 = a[6], a33 = a[10], a34 = a[14];\n\tconst a41 = a[3], a42 = a[7], a43 = a[11], a44 = a[15];\n\n\tconst b11 = b[0], b12 = b[4], b13 = b[8], b14 = b[12];\n\tconst b21 = b[1], b22 = b[5], b23 = b[9], b24 = b[13];\n\tconst b31 = b[2], b32 = b[6], b33 = b[10], b34 = b[14];\n\tconst b41 = b[3], b42 = b[7], b43 = b[11], b44 = b[15];\n\n\tm[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n\tm[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n\tm[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n\tm[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n\n\tm[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n\tm[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n\tm[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n\tm[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n\n\tm[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n\tm[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n\tm[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n\tm[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n\n\tm[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n\tm[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n\tm[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n\tm[15] = a41 * b14 + a42 * \tb24 + a43 * b34 + a44 * b44;\n\n\treturn m;\n}\n\nmatrix4.invert = (m) => {\n\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\n\tconst n11 = m[0], n21 = m[1], n31 = m[2], n41 = m[3];\n\tconst n12 = m[4], n22 = m[5], n32 = m[6], n42 = m[7];\n\tconst n13 = m[8], n23 = m[9], n33 = m[10], n43 = m[11];\n\tconst n14 = m[12], n24 = m[13], n34 = m[14], n44 = m[15];\n\n\tconst t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44;\n\tconst t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44;\n\tconst t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44;\n\tconst t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n\n\tconst det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n\n\tif (det === 0) return [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\n\tconst detInv = 1 / det;\n\n\tm[0] = t11 * detInv;\n\tm[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n\tm[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n\tm[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n\n\tm[4] = t12 * detInv;\n\tm[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n\tm[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n\tm[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n\n\tm[8] = t13 * detInv;\n\tm[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n\tm[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n\tm[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n\n\tm[12] = t14 * detInv;\n\tm[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n\tm[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n\tm[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n\n\treturn m;\n}\n\nmatrix4.compose = (position, quaternion, scale) => {\n\tconst m = matrix4.identity();\n\n\tconst x = quaternion.x, y = quaternion.y, z = quaternion.z, w = quaternion.w;\n\tconst x2 = x + x,\ty2 = y + y, z2 = z + z;\n\tconst xx = x * x2, xy = x * y2, xz = x * z2;\n\tconst yy = y * y2, yz = y * z2, zz = z * z2;\n\tconst wx = w * x2, wy = w * y2, wz = w * z2;\n\n\tconst sx = scale.x, sy = scale.y, sz = scale.z;\n\n\tm[0] = ( 1 - ( yy + zz ) ) * sx;\n\tm[1] = ( xy + wz ) * sx;\n\tm[2] = ( xz - wy ) * sx;\n\tm[3] = 0;\n\n\tm[4] = ( xy - wz ) * sy;\n\tm[5] = ( 1 - ( xx + zz ) ) * sy;\n\tm[6] = ( yz + wx ) * sy;\n\tm[7] = 0;\n\n\tm[8] = ( xz + wy ) * sz;\n\tm[9] = ( yz - wx ) * sz;\n\tm[10] = ( 1 - ( xx + yy ) ) * sz;\n\tm[11] = 0;\n\n\tm[12] = position.x;\n\tm[13] = position.y;\n\tm[14] = position.z;\n\tm[15] = 1;\n\n\treturn m;\n}\n\nmatrix4.decompose = (m) => {\n\tconst p = vector3.zero();\n\tconst q = quaternion.identity();\n\tconst s = vector3.zero();\n\n\tlet sx = vector3.length({x: m[0], y: m[1], z: m[2]});\n\tconst sy = vector3.length({x: m[4], y: m[5], z: m[6]});\n\tconst sz = vector3.length({x: m[8], y: m[9], z: m[10]});\n\n\t// if determine is negative, we need to invert one scale\n\tconst det = matrix4.determinant(m);\n\tif ( det < 0 ) sx = - sx;\n\n\tp.x = m[12];\n\tp.y = m[13];\n\tp.z = m[14];\n\n\t// scale the rotation part\n\tlet m1 = [...m];\n\n\tconst invSX = 1 / sx;\n\tconst invSY = 1 / sy;\n\tconst invSZ = 1 / sz;\n\n\tm1[0] *= invSX;\n\tm1[1] *= invSX;\n\tm1[2] *= invSX;\n\n\tm1[4] *= invSY;\n\tm1[5] *= invSY;\n\tm1[6] *= invSY;\n\n\tm1[8] *= invSZ;\n\tm1[9] *= invSZ;\n\tm1[10] *= invSZ;\n\n\tquaternion.setFromRotationMatrix(q, m1);\n\n\ts.x = sx;\n\ts.y = sy;\n\ts.z = sz;\n\n\treturn {\n\t\tposition: p,\n\t\tquaternion: q,\n\t\tscale: s,\n\t}\n}\n\nmatrix4.determinant = (m) => {\n\tconst n11 = m[ 0 ], n12 = m[ 4 ], n13 = m[ 8 ], n14 = m[ 12 ];\n\tconst n21 = m[ 1 ], n22 = m[ 5 ], n23 = m[ 9 ], n24 = m[ 13 ];\n\tconst n31 = m[ 2 ], n32 = m[ 6 ], n33 = m[ 10 ], n34 = m[ 14 ];\n\tconst n41 = m[ 3 ], n42 = m[ 7 ], n43 = m[ 11 ], n44 = m[ 15 ];\n\n\t//TODO: make this more efficient\n\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\n\treturn (\n\t\tn41 * (\n\t\t\t+ n14 * n23 * n32\n\t\t\t\t- n13 * n24 * n32\n\t\t\t\t- n14 * n22 * n33\n\t\t\t\t+ n12 * n24 * n33\n\t\t\t\t+ n13 * n22 * n34\n\t\t\t\t- n12 * n23 * n34\n\t\t) +\n\t\tn42 * (\n\t\t\t+ n11 * n23 * n34\n\t\t\t\t- n11 * n24 * n33\n\t\t\t\t+ n14 * n21 * n33\n\t\t\t\t- n13 * n21 * n34\n\t\t\t\t+ n13 * n24 * n31\n\t\t\t\t- n14 * n23 * n31\n\t\t) +\n\t\tn43 * (\n\t\t\t+ n11 * n24 * n32\n\t\t\t\t- n11 * n22 * n34\n\t\t\t\t- n14 * n21 * n32\n\t\t\t\t+ n12 * n21 * n34\n\t\t\t\t+ n14 * n22 * n31\n\t\t\t\t- n12 * n24 * n31\n\t\t) +\n\t\tn44 * (\n\t\t\t- n13 * n22 * n31\n\t\t\t\t- n11 * n23 * n32\n\t\t\t\t+ n11 * n22 * n33\n\t\t\t\t+ n13 * n21 * n32\n\t\t\t\t- n12 * n21 * n33\n\t\t\t\t+ n12 * n23 * n31\n\t\t)\n\t);\n}\n\nmatrix4.lookAt = (m, eye, target, up) => {\n\tlet x, y, z;\n\n\tz = math.subtractVectors(target, eye);\n\n\tif ( vector3.lengthSq(z) === 0 ) {\n\t\t// eye and target are in the same position\n\t\tz.z = 1;\n\t}\n\n\tz = math.normalizeVector(z);\n\tx = vector3.crossVectors(up, z);\n\n\tif ( vector3.lengthSq(x) === 0 ) {\n\t\t// up and z are parallel\n\t\tif (Math.abs(up.z) === 1) {\n\t\t\tz.x += 0.0001;\n\t\t} else {\n\t\t\tz.z += 0.0001;\n\t\t}\n\n\t\tz = math.normalizeVector(z);\n\t\tx = vector3.crossVectors(up, z);\n\t}\n\n\tx = math.normalizeVector(x);\n\ty = vector3.crossVectors(z, x);\n\n\tm[0] = x.x; m[4] = y.x; m[8] = z.x;\n\tm[1] = x.y; m[5] = y.y; m[9] = z.y;\n\tm[2] = x.z; m[6] = y.z; m[10] = z.z;\n\n\treturn m;\n}\n\nmatrix4.localMatrixFromBot = (bot, dimension) => {\n\tconst p = {\n\t\tx: bot.tags[dimension + \"X\"] ?? 0,\n\t\ty: bot.tags[dimension + \"Y\"] ?? 0,\n\t\tz: bot.tags[dimension + \"Z\"] ?? 0,\n\t};\n\tconst r = {\n\t\tx: bot.tags[dimension + \"RotationX\"] ?? 0,\n\t\ty: bot.tags[dimension + \"RotationY\"] ?? 0,\n\t\tz: bot.tags[dimension + \"RotationZ\"] ?? 0,\n\t};\n\tconst q = quaternion.fromEuler(r);\n\tconst s = {\n\t\tx: bot.tags[\"scaleX\"] ?? 1,\n\t\ty: bot.tags[\"scaleY\"] ?? 1,\n\t\tz: bot.tags[\"scaleY\"] ?? 1,\n\t};\n\tconst scalar = bot.tags[\"scale\"] ?? 1;\n\tvector3.multiplyScalar(s, scalar);\n\n\treturn matrix4.compose(p, q, s);\n}\n\nmatrix4.worldMatrixFromBot = (bot, dimension) => {\n\tlet matrixWorld = matrix4.identity();\n\tconst matrixLocal = matrix4.localMatrixFromBot(bot, dimension);\n\n\tconst parentId = bot.tags.transformer;\n\tlet parent = parentId ? getBot('id', parentId) : null;\n\n\tif (!parent) {\n\t\tmatrixWorld = matrixLocal;\n\t} else {\n\t\tconst parentMatrixWorld = matrix4.worldFromBot(parent, dimension);\n\t\tmatrixWorld = matrix4.multiplyMatrices(matrixWorld, parentMatrixWorld, matrixLocal);\n\t}\n\n\treturn matrixWorld;\n}",
        "system": "rc-xr.core.math"
      }
    },
    "rc-xr.core.remoteFrustum": {
      "id": "rc-xr.core.remoteFrustum",
      "space": "shared",
      "tags": {
        "__frustumUpdate": "@if ( !globalThis.matrix4 || !globalThis.transform ) {\n    // Need to wait for the math and transform libraries to be loaded.\n    return;\n}\n\nconst camPos = {\n    x: gridPortalBot.tags.cameraPositionX,\n    y: gridPortalBot.tags.cameraPositionY,\n    z: gridPortalBot.tags.cameraPositionZ,\n};\n\nconst camRot = new Rotation({\n    euler: {\n        x: gridPortalBot.tags.cameraRotationX,\n        y: gridPortalBot.tags.cameraRotationY,\n        z: gridPortalBot.tags.cameraRotationZ,\n    }\n});\n\nconst frustumDim = tags.currentDimension;\n\nif ( globalThis.mainSceneBot && frustumDim === tags.mainSceneDimension ) {\n    // Translate camera's gridPortal position to be in mainScene local space.\n    const msMatrix = matrix4.worldMatrixFromBot( mainSceneBot, 'home' );\n    const camLocalPos = vector3.worldToLocal( {...camPos}, msMatrix );\n    transform.setBotPosition( thisBot, frustumDim, camLocalPos );\n\n    // Find point in front of camera that we can:\n    // 1. Translate to mainScene local space.\n    // 2. Calculate a look rotation with.\n    const camForward = math.getForwardDirection( camRot );\n    let lookPoint = math.addVectors( {...camPos}, math.scaleVector( camForward, 4) );\n    lookPoint = vector3.worldToLocal( {...lookPoint}, msMatrix );\n\n    transform.lookAtPoint(thisBot, frustumDim, lookPoint);\n} else {\n    // Use camera's gridPortal position as-is.\n    transform.setBotPosition( thisBot, frustumDim, camPos );\n    transform.setBotRotation( thisBot, frustumDim, camRot );\n}\n",
        "__onCreate": "@masks.interval = setInterval(() => whisper(thisBot, 'frustumUpdate'), tags.updateRateMS);",
        "__onDestroy": "@clearInterval(tags.interval);",
        "__onPortalChanged": "@if (that.portal === 'gridPortal') {\n    if (that.dimension === 'home') {\n        // Remap home dimension to mainSceneDimension.\n        // The home dimensions is only used to the mainSceneDimension to move\n        // around in so we dont want to move our frustum there, we want to keep put it in mainSceneDimension.\n        that.dimension = tags.mainSceneDimension;\n    }\n\n    tags[tags.currentDimension] = null;\n    tags.currentDimension = that.dimension;\n    tags[that.dimension] = true;\n}",
        "__updateRateMS": "250",
        "disableFrustum": "@// [Ryan] Need to include same sleep time as enableFrustum to ensure it runs in\n// the same order if both are called.\nawait os.sleep(500);\n\n// Destroy previous frustum if it exists.\nif (masks.frustumBotId) {\n    console.log(`[remoteFrustum] disable frustum`);\n    destroy(getBot('id', masks.frustumBotId));\n    masks.frustumBotId = null;\n}",
        "enableFrustum": "@let previousFrustumBot = masks.frustumBotId ? getBot('id', masks.frustumBotId) : null;\nif (previousFrustumBot) {\n    // Frustum bot is already active.\n    return;\n}\n\nconsole.log(`[remoteFrustum] enable frustum`);\n\n// [Ryan] For some reason waiting half a second here fixes a bug\n// that causes AUX to put the first user's frustum in the \"shared\" space.\nawait os.sleep(500);\n\nconst dim = tags.mainSceneDimension;\nconst frustumMod = {};\n\nfrustumMod.space = \"tempShared\";\nfrustumMod.fmfrustum = true;\nfrustumMod.frustumID = configBot.id;\nfrustumMod.form = \"frustum\";\nfrustumMod.pointable = false;\nfrustumMod.mainSceneDimension = tags.mainSceneDimension;\nfrustumMod.currentDimension = dim;\n\nfrustumMod[dim] = true;\nfrustumMod[dim+\"Rotation\"] = `🔁0,0,0,1`;\nfrustumMod[dim+\"X\"] = gridPortalBot.tags.cameraPositionX;\nfrustumMod[dim+\"Y\"] = gridPortalBot.tags.cameraPositionY;\nfrustumMod[dim+\"Z\"] = gridPortalBot.tags.cameraPositionZ;\nfrustumMod.updateRateMS = tags.__updateRateMS;\nfrustumMod.onCreate = tags.__onCreate;\nfrustumMod.onDestroy = tags.__onDestroy;\nfrustumMod.frustumUpdate = tags.__frustumUpdate;\nfrustumMod.onPortalChanged = tags.__onPortalChanged;\n\nconst frustumBot = create(frustumMod);\n\n// Store id of frustum bot locally, so that we may destroy it later if needed.\nmasks.frustumBotId = frustumBot.id;\n\n// Make invisible to local user.\nfrustumBot.masks.form = 'none';\nfrustumBot.masks.color = 'clear';",
        "mainSceneDimension": "mainScene",
        "onEggHatch": "@thisBot.enableFrustum();",
        "onInstStreaming": "@thisBot.enableFrustum();",
        "system": "rc-xr.core.remoteFrustum"
      }
    },
    "rc-xr.core.modFactory": {
      "id": "rc-xr.core.modFactory",
      "space": "shared",
      "tags": {
        "button": "@const { \n    space= 'tempLocal',\n    label = 'Button',\n    onClick = `@os.toast('button clicked')`,\n    dimension,\n    dimensionX = 0,\n    dimensionY = 0,\n    dimensionZ = 0,\n    onAdded,\n} = that;\n\nassert(dimension, '[button] dimension parameter is required');\n\nconst buttonMod = {\n    space,\n    label,\n    onButtonClick: onClick,\n    scaleX: 1.9,\n    scaleY: 0.9,\n    scaleZ: 0.3,\n    draggable: false,\n    [dimension]: true,\n    [dimension + 'X']: dimensionX,\n    [dimension + 'Y']: dimensionY,\n    [dimension + 'Z']: dimensionZ,\n    onAdded,\n    onBotAdded: `@\n        whisper(thisBot, 'onAdded');\n    `,\n    onClick: `@\n        whisper(thisBot, 'onButtonClick');\n        masks.color = null;\n        masks.scaleZ = null;\n    `,\n    onPointerDown: `@\n        masks.color = 'royalblue';\n        masks.scaleZ = 0.1;\n    `,\n    onPointerUp: `@\n        masks.scaleZ = null;\n    `,\n    onPointerEnter: `@\n        masks.color = 'skyblue';\n    `,\n    onPointerExit: `@\n        masks.color = null;\n        masks.scaleZ = null;\n    `,\n}\n\nreturn [ buttonMod ];",
        "onDestroy": "@globalThis.modFactory = undefined;",
        "onSetup": "@globalThis.modFactory = thisBot;",
        "system": "rc-xr.core.modFactory"
      }
    }
  }
}