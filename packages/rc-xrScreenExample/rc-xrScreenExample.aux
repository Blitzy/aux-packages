{
  "version": 1,
  "state": {
    "rc-xrScreenExample.scene.createConfirmationDialog": {
      "id": "rc-xrScreenExample.scene.createConfirmationDialog",
      "space": "shared",
      "tags": {
        "cursor": "pointer",
        "home": true,
        "homeX": -1,
        "homeY": 1,
        "homeZ": 0,
        "label": "confirmation\ndialog",
        "onClick": "@const bots = screenManager.createScreen({\n    name: 'confirmDialog',\n    args: {\n        yesLabel: 'Yes',\n        noLabel: 'No',\n        message: 'This is a test of the confirmation dialog. A callback will be executed with the user\\'s choice.',\n        // message: 'Autem officia ducimus omnis. Doloremque vitae aut fugit tenetur est voluptatem. Adipisci qui blanditiis est cupiditate blanditiis ab. Nulla quia odit et qui nam earum occaecati. Quo voluptates aliquam ducimus itaque sit atque quo perferendis.\\n\\nQuos doloribus aspernatur et rerum. Tempora sed sequi possimus rerum tempore aut qui.',\n        callback: `@\n            console.log('[screenTest] confirmation dialog callback:', that);\n        `\n    }\n});",
        "scaleX": "1.9",
        "scaleZ": "0.3",
        "system": "rc-xrScreenExample.scene.createConfirmationDialog"
      }
    },
    "rc-xrScreenExample.init": {
      "id": "rc-xrScreenExample.init",
      "space": "shared",
      "tags": {
        "initialize": "@if (masks.initialized) {\n    return;\n}\n\nmasks.initialized = true;\n\ngridPortalBot.tags.portalCameraType = 'perspective';\n\nshout('onAuxPackageLoaded');\nshout('onInitialize');",
        "onEggHatch": "@thisBot.initialize();",
        "onInstJoined": "@thisBot.initialize();",
        "system": "rc-xrScreenExample.init"
      }
    },
    "rc-xrScreenExample.transformLinker": {
      "id": "rc-xrScreenExample.transformLinker",
      "space": "shared",
      "tags": {
        "addTransformee": "@const { bot } = that;\n\nif (!thisBot.vars.transformees) {\n    thisBot.vars.transformees = {};\n}\n\nconst transformees = thisBot.vars.transformees;\n\nif (!transformees[bot.id]) {\n    transformees[bot.id] = bot;\n    if (tags.debug) {\n        console.log(`[transformLinker] Added bot ${bot.id} to transformees.`);\n    }\n}",
        "addTransformer": "@const { bot, linkId } = that;\n\nif (!thisBot.vars.transformers) {\n    thisBot.vars.transformers = {};\n}\n\nconst transformers = thisBot.vars.transformers;\n\nif (!transformers[linkId]) {\n    transformers[linkId] = bot;\n    if (tags.debug) {\n        console.log(`[transformLinker] Added bot ${bot.id} to transformers as ${linkId}.`);\n    }\n} else if (transformers[linkId].id === bot.id) {\n    // Don't do anything, this bot has already been added with the provided linkId.\n} else {\n    console.error('linkId:', linkId);\n    console.error('bot:', bot);\n    console.error('transformers[linkId]:', transformers[linkId]);\n    console.error(`[transformLinker] Bot ${bot.id} has ${tags.linkIdTag} tag set to ${linkId}, but ${linkId} was already defined as bot ${transformers[linkId].id}. Make sure that all ${tags.linkIdTag} tags are unique.`);\n}",
        "debug": "false",
        "debugState": "false",
        "findStoredLinkId": "@const { botId } = that;\nconst transformers = thisBot.vars.transformers;\n\nif (transformers) {\n    for (let linkId in transformers) {\n        if (transformers[linkId].id === botId) {\n            return linkId;\n        }\n    }\n}",
        "forceRefresh": "@delete thisBot.vars.transformers;\ndelete thisBot.vars.transformees;\n\nconst bots = getBots();\nthisBot.onAnyBotsAdded({ bots });",
        "hasValue": "@return that !== undefined && that !== null && that !== '';",
        "linkIdTag": "transformId",
        "linkToTag": "transformBy",
        "onAnyBotsAdded": "@const { bots } = that;\nlet update = false;\n\nfor (let bot of bots) {\n    if (bot === thisBot) {\n        continue;\n    }\n\n    const linkId = bot.tags[tags.linkIdTag];\n    if (thisBot.hasValue(linkId)) {\n        thisBot.addTransformer({ bot, linkId })\n        update = true;\n    }\n\n    const linkTo = bot.tags[tags.linkToTag];\n    if (thisBot.hasValue(linkTo)) {\n        thisBot.addTransformee({ bot });\n        update = true;\n    }\n}\n\nif (update) {\n    thisBot.updateTransformees();\n}",
        "onAnyBotsChanged": "@const changes = that;\nlet update = false;\n\nfor (let changed of changes) {\n    if (changed) {\n        if (changed.tags.includes(tags.linkIdTag)) {\n            thisBot.removeTransformer({ id: changed.bot.id });\n\n            const linkId = changed.bot.tags[tags.linkIdTag];\n            if (thisBot.hasValue(linkId)) {\n                thisBot.addTransformer({ bot: changed.bot, linkId });\n            }\n\n            update = true;\n        }\n\n        if (changed.tags.includes(tags.linkToTag)) {\n            const linkTo = changed.bot.tags[tags.linkToTag];\n            if (thisBot.hasValue(linkTo)) {\n                thisBot.addTransformee({ bot: changed.bot });\n            } else {\n                thisBot.removeTransformee({ botId: changed.bot.id });\n                changed.bot.tags.transformer = null;\n            }\n\n            update = true;\n        }\n    }\n}\n\nif (update) {\n    thisBot.updateTransformees();\n}",
        "onAnyBotsRemoved": "@let update = false;\n\nconst { botIDs } = that;\n\nfor (let id of botIDs) {\n    if (thisBot.removeTransformer({ id })) {\n        update = true;\n    }\n    if (thisBot.removeTransformee({ botId: id})) {\n        update = true;\n    }\n}\n\nif (update) {\n    thisBot.updateTransformees();\n}",
        "onAuxPackageLoaded": "@thisBot.forceRefresh();",
        "removeTransformee": "@const { botId } = that;\n\nconst transformees = thisBot.vars.transformees;\nlet deleted = false;\n\nif (!transformees) {\n    return false;\n}\n\nif (transformees[botId]) {\n    delete transformees[botId];\n    deleted = true;\n    if (tags.debug) {\n        console.log(`[transformLinker] Removed bot ${botId} from transformees.`);\n    }\n}\n\nreturn deleted;",
        "removeTransformer": "@const { id } = that;\n\nconst transformers = thisBot.vars.transformers;\nlet deleted = false;\n\nif (!transformers || !thisBot.hasValue(id)) {\n    return false;\n}\n\n// Treat id as linkId first.\nif (transformers[id]) {\n    delete transformers[id];\n    if (tags.debug) {\n        console.log(`[transformLinker] Removed transformer ${id}`);\n    }\n\n    deleted = true;\n}\n\n// Treat id as botId.\nlet storedLinkId = thisBot.findStoredLinkId({ botId: id });\nif (storedLinkId) {\n    delete transformers[storedLinkId];\n    if (tags.debug) {\n        console.log(`[transformLinker] Removed transformer ${storedLinkId}`);\n    }\n\n    deleted = true;\n}\n\nreturn deleted;",
        "system": "rc-xrScreenExample.transformLinker",
        "updateTransformees": "@const transformers = thisBot.vars.transformers;\nconst transformees = thisBot.vars.transformees;\n\nif (tags.debugState) {\n    const state = {\n        transformers,\n        transformees,\n    }\n\n    console.log(`[transformLinker] state`, state);\n}\n\n// Go through all transformees and link up to their transformers.\nfor (let botId in transformees) {\n    const bot = transformees[botId];\n    const linkTo = bot.tags[tags.linkToTag];\n    const transformer = transformers[linkTo];\n    \n    if (transformer && transformer !== bot) {\n        bot.tags.transformer = transformer.id;\n    } else {\n        bot.tags.transformer = null;\n    }\n}"
      }
    },
    "rc-xrScreenExample.scene.createEmptyPinnableWindow": {
      "id": "rc-xrScreenExample.scene.createEmptyPinnableWindow",
      "space": "shared",
      "tags": {
        "cursor": "pointer",
        "home": true,
        "homeX": 1,
        "homeY": 1,
        "homeZ": 0,
        "label": "empty pinnable window",
        "onClick": "@const bots = screenManager.createScreen({\n    name: 'emptyPinnableWindow'\n});",
        "scaleX": "1.9",
        "scaleZ": "0.3",
        "system": "rc-xrScreenExample.scene.createEmptyPinnableWindow"
      }
    },
    "rc-xrScreenExample.cameraShouter": {
      "id": "rc-xrScreenExample.cameraShouter",
      "space": "shared",
      "tags": {
        "onAnyBotsChanged": "@const gridPortalBotIndex = that.findIndex((el) => {\n    if (el && globalThis.gridPortalBot && el.bot === gridPortalBot) {\n        return true;\n    }\n});\n\nif (gridPortalBotIndex >= 0) {\n    const changedTags = that[gridPortalBotIndex].tags;\n    const cameraChanged = changedTags.some((t) => {\n        return t === 'cameraPositionX' ||\n            t === 'cameraPositionY' ||\n            t === 'cameraPositionZ' ||\n            t === 'cameraPositionOffsetX' ||\n            t === 'cameraPositionOffsetY' ||\n            t === 'cameraPositionOffsetz' ||\n            t === 'cameraRotationX' ||\n            t === 'cameraRotationY' ||\n            t === 'cameraRotationZ' ||\n            t === 'cameraRotationOffsetX' ||\n            t === 'cameraRotationOffsetY' ||\n            t === 'cameraRotationOffsetZ' ||\n            t === 'cameraRotationOffsetW' ||\n            t === 'cameraFocusX' ||\n            t === 'cameraFocusY' ||\n            t === 'cameraFocusZ' ||\n            t === 'cameraZoom' ||\n            t === 'cameraZoomOffset';\n    })\n\n    if (cameraChanged) {\n        shout('onCameraChanged', { changedTags })\n    }\n}",
        "system": "rc-xrScreenExample.cameraShouter"
      }
    },
    "rc-xrScreenExample.parseThat": {
      "id": "rc-xrScreenExample.parseThat",
      "space": "shared",
      "tags": {
        "onAuxPackageLoaded": "@function isObject(obj) {\n    return obj && typeof obj === 'object';\n}\n\nfunction mergeDeep(...objects) {\n    return objects.reduce((prev, obj) => {\n        Object.keys(obj).forEach(key => {\n            const pVal = prev[key];\n            const oVal = obj[key];\n\n            if (Array.isArray(pVal) && Array.isArray(oVal)) {\n                prev[key] = pVal.concat(...oVal);\n            } else if (isObject(pVal) && isObject(oVal)) {\n                prev[key] = mergeDeep(pVal, oVal);\n            } else {\n                prev[key] = oVal;\n            }\n        });\n\n        return prev;\n  }, {});\n}\n\n/**\n * Parse an action function's \"that\" variable.  \n * Provide a defaults object to merge into parsed result.  \n * Supports deep merging, so nested objects will be properly handled.\n */\nfunction parseThat(that, defaults) {\n    if (that === undefined || that === null) {\n        return defaults;\n    }\n    if (defaults === undefined || defaults === null) {\n        return that;\n    }\n\n    if (isObject(that)) {\n        return mergeDeep(defaults, that);\n    } else {\n        throw new Error(`[parseThat] that must be an object.`);\n    }\n}\n\nglobalThis.mergeDeep = mergeDeep;\nglobalThis.parseThat = parseThat;",
        "system": "rc-xrScreenExample.parseThat"
      }
    },
    "rc-xrScreenExample.baseScreen": {
      "id": "rc-xrScreenExample.baseScreen",
      "space": "shared",
      "tags": {
        "draggable": "false",
        "listening": "false",
        "onCameraChanged": "@if (masks.screenReady) {\n    thisBot.updatePos();\n}",
        "onScreenReady": "@masks.screenReady = true;\n\nif (!thisBot.vars.curTargetPos) {\n    thisBot.vars.curTargetPos = { x: 0, y: 0, z: 0 };\n}\n\nthisBot.updatePos({ force: true });",
        "orientationMode": "billboard",
        "scale": "0.25",
        "screenCameraDistance": "3",
        "screenFollowDuration": "0.5",
        "screenMoveThreshold": "1.5",
        "system": "rc-xrScreenExample.baseScreen",
        "updatePos": "@const { force = false } = that ?? {};\n\nconst userDim = configBot.tags.gridPortal;\n\nif (!userDim) {\n    return;\n}\n\nlet cameraRot = new Rotation({\n    euler: {\n        x: gridPortalBot.tags.cameraRotationX,\n        y: gridPortalBot.tags.cameraRotationY,\n        z: gridPortalBot.tags.cameraRotationZ,\n    }\n});\n\nconst cameraForwardDir = math.getForwardDirection(cameraRot);\n\nconst cameraPos = {\n    x: gridPortalBot.tags.cameraPositionX,\n    y: gridPortalBot.tags.cameraPositionY,\n    z: gridPortalBot.tags.cameraPositionZ,\n}\n\nlet targetPos = {...cameraPos};\n\nlet screenCameraDistance = tags.screenCameraDistance;\nif (configBot.tags.inVR || configBot.tags.inAR) {\n    screenCameraDistance *= 1.667;\n}\n\ntargetPos = math.addVectors(\n    targetPos,\n    math.scaleVector(cameraForwardDir, screenCameraDistance)\n);\n\nmath.normalizeVector()\n\nif (force) {\n    clearAnimations(thisBot);\n\n    tags[`${userDim}X`] = targetPos.x;\n    tags[`${userDim}Y`] = targetPos.y;\n    tags[`${userDim}Z`] = targetPos.z;\n\n    thisBot.vars.curTargetPos = targetPos;\n} else {\n    const dir = math.subtractVectors(targetPos, thisBot.vars.curTargetPos);\n    const dist = math.vectorLength(dir);\n\n    let screenMoveThreshold = tags.screenMoveThreshold;\n    if (configBot.tags.inVR || configBot.tags.inAR) {\n        screenMoveThreshold *= 1.667;\n    }\n\n    if (dist >= screenMoveThreshold) {\n        clearAnimations(thisBot);\n        animateTag(thisBot, {\n            fromValue: {\n                [`${userDim}X`]: tags[`${userDim}X`],\n                [`${userDim}Y`]: tags[`${userDim}Y`],\n                [`${userDim}Z`]: tags[`${userDim}Z`],\n            },\n            toValue: {\n                [`${userDim}X`]: targetPos.x,\n                [`${userDim}Y`]: targetPos.y,\n                [`${userDim}Z`]: targetPos.z,\n            },\n            duration: tags.screenFollowDuration,\n            easing: {\n                type: 'sinusoidal',\n                mode: 'out'\n            }\n        }).catch(() => {\n            // We don't care if this animation is canceled. Its part of the normal operation of this script.\n        })\n\n        thisBot.vars.curTargetPos = targetPos;\n    }\n}"
      }
    },
    "rc-xrScreenExample.modFactory": {
      "id": "rc-xrScreenExample.modFactory",
      "space": "shared",
      "tags": {
        "button": "@return parseThat(that, {\n    onBotAdded: `@\n        tags.buttonHeight = tags.scaleZ;\n        tags.color = tags.buttonColor;\n    `,\n    onPointerDown: `@\n        tags.scaleZ = tags.buttonHeight * tags.downHeightScalar;\n\n        if (tags.downColor) {\n            tags.color = tags.downColor;\n        }\n    `,\n    onPointerEnter: `@\n        tags.color = tags.hoverColor;\n        masks.hovering = true;\n    `,\n    onPointerExit: `@\n        tags.color = tags.buttonColor;\n        tags.scaleZ = tags.buttonHeight;\n        masks.hovering = false;\n    `,\n    onPointerUp: `@\n        tags.scaleZ = tags.buttonHeight;\n        \n        if (masks.hovering) {\n            tags.color = tags.hoverColor;\n        } else {\n            tags.color = tags.buttonColor;\n        }\n    `,\n    onFocusEnter: `@\n        thisBot.onPointerEnter();\n    `,\n    onFocusExit: `@\n        thisBot.onPointerExit();\n    `,\n    onClick: `@os.toast(tags.label + ' button clicked');`,\n    scaleX: 1.9,\n    scaleY: 0.9,\n    scaleZ: 0.3,\n    buttonColor: '#fff',\n    hoverColor: '#d33',\n    downColor: null,\n    downHeightScalar: 0.333,\n    label: 'Button',\n    labelPadding: 0.3,\n    draggable: false,\n});",
        "iconButton": "@const {\n    space = 'tempLocal',\n    dimension,\n    pos = {x: 0, y: 0, z: 0},\n    buttonSize = { x: 0.9, y: 0.9, z: 0.3 },\n    buttonColor = '#fff',\n    hoverColor = '#d33',\n    label,\n    icon,\n    iconAspect = 1,\n    iconScale = 0.75,\n    iconRenderOrder,\n    iconAngle = 0,\n    onAdded,\n    onClick = `@os.toast('icon button clicked');`,\n    transformId,\n    transformBy,\n} = that;\n\nassert(dimension, `[iconButton] dimension is required`);\n\nconst rootCustomId = transformId ?? uuid();\nconst iconCustomId = uuid();\nconst ICON_OFFSET = -1.45;\n\nconst rootMod = {\n    space,\n    transformId: rootCustomId,\n    transformBy,\n    color: 'transparent',\n    draggable: false,\n    pointable: false,\n    [`${dimension}`]: true,\n    [`${dimension}X`]: pos.x,\n    [`${dimension}Y`]: pos.y,\n    [`${dimension}Z`]: pos.z,\n}\n\nconst buttonMod = {\n    space,\n    transformBy: rootCustomId,\n    getIcon: `@\n        if (!links.icon) {\n            links.icon = getBot('myId', '${iconCustomId}');\n        }\n\n        return links.icon;\n    `,\n    onAdded,\n    onBotAdded: `@\n        tags.color = tags.buttonColor;\n        \n        if (thisBot.onAdded) {\n            thisBot.onAdded();\n        }\n    `,\n    onPointerDown: `@\n        tags.scaleZ = ${buttonSize.z * 0.333};\n        thisBot.getIcon().tags['${dimension}Z'] = ${buttonSize.z + (ICON_OFFSET + (-buttonSize.z * 0.333))};\n    `,\n    onPointerEnter: `@\n        tags.color = tags.hoverColor;\n    `,\n    onPointerExit: `@\n        tags.color = tags.buttonColor;\n        tags.scaleZ = ${buttonSize.z};\n        thisBot.getIcon().tags['${dimension}Z'] = ${buttonSize.z + ICON_OFFSET};\n    `,\n    onPointerUp: `@\n        tags.scaleZ = ${buttonSize.z};\n        thisBot.getIcon().tags['${dimension}Z'] = ${buttonSize.z + ICON_OFFSET};\n    `,\n    onClick,\n    scaleX: buttonSize.x,\n    scaleY: buttonSize.y,\n    scaleZ: buttonSize.z,\n    buttonColor,\n    hoverColor,\n    draggable: false,\n    [`${dimension}`]: true,\n    [`${dimension}X`]: 0,\n    [`${dimension}Y`]: 0,\n    [`${dimension}Z`]: -1,\n}\n\nconst iconMod = {\n    space,\n    myId: iconCustomId,\n    transformBy: rootCustomId,\n    pointable: false,\n    draggable: false,\n    form: 'sprite',\n    icon,\n    formRenderOrder: iconRenderOrder,\n    scaleX: (buttonSize.x * iconScale) * iconAspect,\n    scaleY: (buttonSize.y * iconScale),\n    [`${dimension}`]: true,\n    [`${dimension}X`]: 0,\n    [`${dimension}Y`]: 0,\n    [`${dimension}Z`]: buttonSize.z + ICON_OFFSET,\n    [`${dimension}RotationZ`]: iconAngle,\n    iconButtonIconMod: true,\n    formAddress: icon\n}\n\nreturn [rootMod, buttonMod, iconMod];",
        "iconLabelButton": "@const {\n    space = 'tempLocal',\n    dimension,\n    pos = {x: 0, y: 0, z: 0},\n    buttonSize = { x: 3.5, y: 1, z: 0.3 },\n    buttonColor = '#fff',\n    hoverColor = '#d33',\n    label = 'Button',\n    labelFontSize,\n    labelPadding,\n    labelColor = 'black',\n    labelAlignment = 'left',\n    labelWordWrapMode,\n    labelLeftPadding = 0,\n    labelRightPadding = 0.2,\n    labelTopPadding = 0.1,\n    labelBottomPadding = 0.1,\n    icon,\n    iconColor,\n    iconAspect = 1,\n    iconScale = 0.65,\n    iconRenderOrder,\n    iconAngle = 0,\n    iconLeftPadding = 0.1,\n    iconRightPadding = 0.1,\n    onAdded,\n    onClick = `@os.toast('icon label button clicked');`,\n    transformId,\n    transformBy,\n} = that;\n\nassert(dimension, `[iconButton] dimension is required`);\nassert(dimension, `[iconButton] dimension is required`);\n\nconst rootTransformId = transformId ?? uuid();\nconst iconTransformId = uuid();\nconst labelTransformId = uuid();\nconst ICON_OFFSET = 0.05;\n\nconst rootMod = {\n    space,\n    transformId: rootTransformId,\n    transformBy,\n    anchorPoint: 'center',\n    color: 'transparent',\n    draggable: false,\n    pointable: false,\n    [`${dimension}`]: true,\n    [`${dimension}X`]: pos.x,\n    [`${dimension}Y`]: pos.y,\n    [`${dimension}Z`]: pos.z,\n}\n\nconst buttonMod = {\n    space,\n    transformBy: rootTransformId,\n    anchorPoint: 'bottom',\n    getIcon: `@\n        if (!links.iconBot) {\n            links.iconBot = getBot('myId', '${iconTransformId}');\n        }\n\n        return links.iconBot;\n    `,\n    getLabel: `@\n        if (!links.labelBot) {\n            links.labelBot = getBot('myId', '${labelTransformId}');\n        }\n\n        return links.labelBot;\n    `,\n    onAdded,\n    onBotAdded: `@\n        tags.color = tags.buttonColor;\n        \n        if (thisBot.onAdded) {\n            thisBot.onAdded();\n        }\n    `,\n    onPointerDown: `@\n        tags.scaleZ = ${buttonSize.z * 0.333};\n        thisBot.getIcon().tags['${dimension}Z'] = ${(buttonSize.z * 0.333) + ICON_OFFSET};\n        thisBot.getLabel().tags['${dimension}Z'] = ${(buttonSize.z * 0.333) + ICON_OFFSET};\n    `,\n    onPointerEnter: `@\n        tags.color = tags.hoverColor;\n    `,\n    onPointerExit: `@\n        tags.color = tags.buttonColor;\n        tags.scaleZ = ${buttonSize.z};\n        thisBot.getIcon().tags['${dimension}Z'] = ${buttonSize.z + ICON_OFFSET};\n        thisBot.getLabel().tags['${dimension}Z'] = ${buttonSize.z + ICON_OFFSET};\n    `,\n    onPointerUp: `@\n        tags.scaleZ = ${buttonSize.z};\n        thisBot.getIcon().tags['${dimension}Z'] = ${buttonSize.z + ICON_OFFSET};\n        thisBot.getLabel().tags['${dimension}Z'] = ${buttonSize.z + ICON_OFFSET};\n    `,\n    onClick,\n    scaleX: buttonSize.x,\n    scaleY: buttonSize.y,\n    scaleZ: buttonSize.z,\n    buttonColor,\n    hoverColor,\n    draggable: false,\n    [`${dimension}`]: true,\n    [`${dimension}X`]: 0,\n    [`${dimension}Y`]: 0,\n    [`${dimension}Z`]: 0,\n}\n\nlet iconHeight = buttonSize.y * iconScale;\nlet iconWidth = iconHeight * iconAspect;\n\nconst iconMod = {\n    space,\n    myId: iconTransformId,\n    transformBy: rootTransformId,\n    anchorPoint: 'center',\n    pointable: false,\n    draggable: false,\n    form: 'sprite',\n    iconColor,\n    formAddress: icon,\n    formRenderOrder: iconRenderOrder,\n    scaleX: iconWidth,\n    scaleY: iconHeight,\n    [`${dimension}`]: true,\n    [`${dimension}X`]: (-buttonSize.x / 2) + (buttonSize.y / 2) + iconLeftPadding,\n    [`${dimension}Y`]: 0,\n    [`${dimension}Z`]: buttonSize.z + ICON_OFFSET,\n    [`${dimension}RotationZ`]: iconAngle,\n    iconButtonIconMod: true,\n}\nlet iconAreaWidth = buttonSize.y + iconLeftPadding + iconRightPadding;\n\nlet labelWidth = buttonSize.x - iconAreaWidth - labelRightPadding - labelLeftPadding;\nlet labelHeight = buttonSize.y - labelTopPadding - labelBottomPadding;\n\nconst labelMod = modFactory.textArea({\n    space: 'tempLocal',\n    myId: labelTransformId,\n    transformBy: rootTransformId,\n    anchorPoint: 'left',\n    label,\n    labelFontSize,\n    labelAlignment,\n    labelWordWrapMode,\n    labelPadding,\n    labelColor,\n    // color: 'cyan',\n    scaleX: labelWidth,\n    scaleY: labelHeight,\n    scaleZ: 0.05,\n    [`${dimension}`]: true,\n    [`${dimension}X`]: (-buttonSize.x / 2) + iconAreaWidth + labelLeftPadding,\n    [`${dimension}Y`]: 0,\n    [`${dimension}Z`]: buttonSize.z + ICON_OFFSET,\n})\n\nreturn [rootMod, buttonMod, iconMod, labelMod];",
        "onAuxPackageLoaded": "@globalThis.modFactory = thisBot;",
        "onDestroy": "@globalThis.modFactory = undefined;",
        "pinnableWindow": "@const {\n    space = 'tempLocal',\n    dimension,\n    transformId = uuid(),\n    transformBy,\n    onClose,\n    startPinned,\n    startPinPosition,\n    startPinRotation,\n    topBarColor = colorPalette.tags.mediumBlue,\n    windowTitle,\n    windowSizeX = 8,\n    windowSizeY = 5,\n    windowTitleColor = 'white',\n    windowBackgroundColor = colorPalette.tags.darkBlue,\n    windowOffset = { x: 0, y: 0, z: 0},\n} = that;\n\nassert(dimension, '[pinnableWindow] dimension is required');\n\nconst TOP_BAR_HEIGHT = 1;\nconst TOP_BAR_BUTTON_SIZE = 0.8;\nconst TOP_BAR_TITLE_HEIGHT = 1;\nconst TOP_BAR_TITLE_LEFT = 0.25;\nconst TOP_BAR_CLOSE_BUTTON_RIGHT = 0.25;\nconst TOP_BAR_CLOSE_BUTTON_TOP = 0.125;\nconst TOP_BAR_PIN_BUTTON_RIGHT = 1.25;\nconst TOP_BAR_PIN_BUTTON_TOP = 0.125;\n\nconst windowHalfSizeX = windowSizeX / 2;\nconst windowHalfSizeY = windowSizeY / 2;\n\nconst windowRootMod = {\n    space,\n    transformId,\n    transformBy,\n    anchorPoint: 'center',\n    draggable: false,\n    pointable: false,\n    color: 'transparent',\n    startDimension: dimension,\n    startPinned: startPinned || !!startPinPosition || !!startPinRotation,\n    startPinPosition,\n    startPinRotation,\n    iconPinEnabled: 'https://builder-ltm-files.s3.amazonaws.com/7aa053acc01e6ef3907da65dd14b66ef9b48ce581c1b7f6736f84787021bceeb.png',\n    iconPin: 'https://builder-ltm-files.s3.amazonaws.com/108aa32769c9d69dc13e1e02942989b3f696f9ba0338cb0a04e2b10357e3ebb9.png',\n    windowOffset,\n    [dimension]: true,\n    [dimension + 'X']: windowOffset.x,\n    [dimension + 'Y']: windowOffset.y,\n    [dimension + 'Z']: windowOffset.z,\n    onScreenReady: `@\n        links.baseScreen = getBot('system', 'rc-xrScreenExample.baseScreen');\n        links.screenRootBot = that.bots[0];\n        links.screenBots = that.bots.slice(1, that.bots.length);\n        links.pinButtonBots = that.bots.filter(b => b.tags.pinButton);\n        links.closeButtonBots = that.bots.filter(b => b.tags.closeButton);\n\n        const pinButtonBot = links.pinButtonBots.find(b => b.tags.pinButton === 'button');\n        pinButtonBot.tags.logicBot = thisBot.link;\n        pinButtonBot.tags.onClick = \\`@\n            let pinned = links.logicBot.tags.pinned;\n            links.logicBot.setPinned({ pin: !pinned });\n        \\`;\n        tags.pinned = false;\n\n        if (tags.startPinned) {\n            thisBot.setPinned({ \n                pin: true, \n                dimension: tags.startDimension,\n                pinPosition: tags.startPinPosition,\n                pinRotation: tags.startPinRotation,\n            })\n        }\n    `,\n    setPinned: `@\n        const { \n            pin,\n            dimension = configBot.tags.gridPortal,\n            pinPosition = {\n                x: links.screenRootBot.tags[dimension + 'X'],\n                y: links.screenRootBot.tags[dimension + 'Y'],\n                z: links.screenRootBot.tags[dimension + 'Z'],\n            },\n            pinRotation = {\n                x: 0,\n                y: 0, \n                z: 0,\n            },\n            orientTowardsCamera = true,\n        } = that;\n\n        const panelRootBot = thisBot;\n        const panelPosOffset = { x: 0, y: -1, z: -1 };\n        const panelRotOffset = { x: Math.PI / 2, y: 0, z: 0 };\n        const panelPinnedTag = 'pinned';\n        const panelPinBotTag = 'pinBot';\n\n        tags[panelPinnedTag] = pin;\n\n        // Make sure we store the default unpinned coordinates for the panel root bot.\n        if (!panelRootBot.tags.unpinnedCached) {\n            panelRootBot.tags.unpinnedCached = true;\n\n            panelRootBot.tags.unpinnedTransformBy = panelRootBot.tags.transformBy;\n            panelRootBot.tags.unpinnedX = panelRootBot.tags[configBot.tags.gridPortal + 'X'];\n            panelRootBot.tags.unpinnedY = panelRootBot.tags[configBot.tags.gridPortal + 'Y'];\n            panelRootBot.tags.unpinnedZ = panelRootBot.tags[configBot.tags.gridPortal + 'Z'];\n            panelRootBot.tags.unpinnedRotationX = panelRootBot.tags[configBot.tags.gridPortal + 'RotationX'];\n            panelRootBot.tags.unpinnedRotationY = panelRootBot.tags[configBot.tags.gridPortal + 'RotationY'];\n            panelRootBot.tags.unpinnedRotationZ = panelRootBot.tags[configBot.tags.gridPortal + 'RotationZ'];\n        }\n\n        if (pin) {\n            if (links[panelPinBotTag]) {\n                if (links[panelPinBotTag].tags.dimension !== dimension) {\n                    // Pin bot is in another dimension, destroy it so we can make a new one.\n                    destroy(links[panelPinBotTag]);\n                }\n            }\n\n            if (!links[panelPinBotTag]) {\n                // Create a pin bot for window to be parented to.\n                links[panelPinBotTag] = create({\n                    space: 'tempLocal',\n                    color: 'transparent',\n                    scale: links.screenRootBot.tags.scale,\n                    anchorPoint: links.screenRootBot.tags.anchorPoint,\n                    transformId: uuid(),\n                    draggable: false,\n                    pointable: false,\n                });\n            }\n\n            const prevPinDimension = panelRootBot.tags.pinDimension;\n            const prevBotVisibility = {}\n\n            if (prevPinDimension) {\n                // Remove bots from pin dimension.\n                links[panelPinBotTag].tags[prevPinDimension] = false;\n                links.screenBots.forEach((b) => {\n                    prevBotVisibility[b.id] = b.tags[prevPinDimension];\n                    b.tags[prevPinDimension] = false;\n                });\n            } else {\n                // Remove bots from gridPortal\n                links[panelPinBotTag].tags[configBot.tags.gridPortal] = false;\n                links.screenBots.forEach((b) => {\n                    prevBotVisibility[b.id] = b.tags[configBot.tags.gridPortal];\n                    b.tags[configBot.tags.gridPortal] = false;\n                });\n            }\n\n            links[panelPinBotTag].tags.dimension = dimension;\n            links[panelPinBotTag].tags[dimension] = true;\n            links[panelPinBotTag].tags[dimension + 'X'] = pinPosition.x;\n            links[panelPinBotTag].tags[dimension + 'Y'] = pinPosition.y;\n            links[panelPinBotTag].tags[dimension + 'Z'] = pinPosition.z;\n            links[panelPinBotTag].tags[dimension + 'RotationX'] = pinRotation.x;\n            links[panelPinBotTag].tags[dimension + 'RotationY'] = pinRotation.y;\n            links[panelPinBotTag].tags[dimension + 'RotationZ'] = pinRotation.z;\n\n            panelRootBot.tags.pinDimension = dimension;\n            panelRootBot.tags.transformBy = links[panelPinBotTag].tags.transformId;\n            panelRootBot.tags[dimension + 'X'] = panelPosOffset.x + tags.windowOffset.x;\n            panelRootBot.tags[dimension + 'Y'] = panelPosOffset.y + -tags.windowOffset.z;\n            panelRootBot.tags[dimension + 'Z'] = panelPosOffset.z + tags.windowOffset.y;\n            panelRootBot.tags[dimension + 'RotationX'] = panelRotOffset.x;\n            panelRootBot.tags[dimension + 'RotationY'] = panelRotOffset.y;\n            panelRootBot.tags[dimension + 'RotationZ'] = panelRotOffset.z;\n\n            links.screenBots.forEach((b) => {\n                b.tags[dimension] = prevBotVisibility[b.id];\n            });\n\n            if (dimension !== configBot.tags.gridPortal) {\n                // Bake coordinates of gridPortal to the dimension being pinned in.\n                links.screenBots.forEach((b) => {\n                    if (b !== panelRootBot) {\n                        b.tags[dimension + 'X'] = b.tags[configBot.tags.gridPortal + 'X'];\n                        b.tags[dimension + 'Y'] = b.tags[configBot.tags.gridPortal + 'Y'];\n                        b.tags[dimension + 'Z'] = b.tags[configBot.tags.gridPortal + 'Z'];\n                        b.tags[dimension + 'RotationX'] = b.tags[configBot.tags.gridPortal + 'RotationX'];\n                        b.tags[dimension + 'RotationY'] = b.tags[configBot.tags.gridPortal + 'RotationY'];\n                        b.tags[dimension + 'RotationZ'] = b.tags[configBot.tags.gridPortal + 'RotationZ'];\n                    }\n                });\n            }\n\n            if (orientTowardsCamera) {\n                const cameraPos = {\n                    x: gridPortalBot.tags.cameraPositionX,\n                    y: gridPortalBot.tags.cameraPositionY,\n                    z: gridPortalBot.tags.cameraPositionZ,\n                }\n\n                const cameraRotation = {\n                    x: gridPortalBot.tags.cameraRotationX,\n                    y: gridPortalBot.tags.cameraRotationY,\n                    z: gridPortalBot.tags.cameraRotationZ,\n                }\n                \n                const cameraForward = math.getForwardDirection(cameraRotation);\n                links[panelPinBotTag].tags[dimension + 'RotationX'] = cameraForward;\n\n                const lookRotation = new Rotation({\n                    direction: cameraForward,\n                    upwards: new Vector3(0, 0, 1),\n                    errorHandling: 'nudge',\n                });\n\n                links[panelPinBotTag].tags[dimension + 'Rotation'] = lookRotation;\n            } else {\n                links[panelPinBotTag].tags[dimension + 'Rotation'] = null;\n            }\n\n        } else {\n            if (panelRootBot.tags.unpinnedCached) {\n                panelRootBot.tags.transformBy = panelRootBot.tags.unpinnedTransformBy;\n                panelRootBot.tags[configBot.tags.gridPortal + 'X'] = panelRootBot.tags.unpinnedX;\n                panelRootBot.tags[configBot.tags.gridPortal + 'Y'] = panelRootBot.tags.unpinnedY;\n                panelRootBot.tags[configBot.tags.gridPortal + 'Z'] = panelRootBot.tags.unpinnedZ;\n                panelRootBot.tags[configBot.tags.gridPortal + 'RotationX'] = panelRootBot.tags.unpinnedRotationX;\n                panelRootBot.tags[configBot.tags.gridPortal + 'RotationY'] = panelRootBot.tags.unpinnedRotationY;\n                panelRootBot.tags[configBot.tags.gridPortal + 'RotationZ'] = panelRootBot.tags.unpinnedRotationZ;\n\n                if (panelRootBot.tags.pinDimension !== configBot.tags.gridPortal) {\n                    links.screenBots.forEach((b) => { \n                        const visible = b.tags[panelRootBot.tags.pinDimension];\n                        b.tags[panelRootBot.tags.pinDimension] = false;\n                        b.tags[configBot.tags.gridPortal] = visible;\n                    });\n\n                    panelRootBot.tags.pinDimension = null;\n                }\n\n                os.sleep(100).then(() => {\n                    destroy(links[panelPinBotTag]);\n                })\n            } else {\n                console.warn('Cannot unpin a panel that has never been pinned!');\n            }\n        }\n\n        // Update pin button icon.\n        const pinIconBot = links.pinButtonBots.find(b => b.tags.pinButton === 'icon');\n        if (pinIconBot) {\n            pinIconBot.tags.formAddress = pin ? tags.iconPinEnabled : tags.iconPin;\n        }\n    `,\n}\n\nconst windowBackgroundMod = {\n    space,\n    transformBy: windowRootMod.transformId,\n    form: 'sprite',\n    anchorPoint: 'center',\n    color: windowBackgroundColor,\n    scaleX: windowSizeX,\n    scaleY: windowSizeY,\n    draggable: false,\n    [dimension]: true,\n}\n\nconst topBarRootMod = {\n    space,\n    transformId: uuid(),\n    transformBy: windowRootMod.transformId,\n    color: 'transparent',\n    anchorPoint: 'center',\n    draggable: false,\n    pointable: false,\n    [dimension]: true,\n    [dimension + 'X']: 0,\n    [dimension + 'Y']: windowHalfSizeY + (TOP_BAR_HEIGHT / 2),\n    [dimension + 'Z']: 0,\n}\n\nconst topBarBackgroundMod = {\n    space,\n    transformBy: topBarRootMod.transformId,\n    form: 'sprite',\n    color: topBarColor,\n    anchorPoint: 'center',\n    scaleX: windowSizeX,\n    scaleY: TOP_BAR_HEIGHT,\n    draggable: false,\n    [dimension]: true,\n    [dimension + 'X']: 0,\n    [dimension + 'Y']: 0,\n    [dimension + 'Z']: 0,\n}\n\nconst topBarTitleMod = modFactory.textArea({\n    space,\n    transformBy: topBarRootMod.transformId,\n    anchorPoint: 'left',\n    scaleY: TOP_BAR_TITLE_HEIGHT,\n    [dimension]: true,\n    [dimension + 'X']: -windowHalfSizeX + TOP_BAR_TITLE_LEFT,\n    [dimension + 'Y']: 0,\n    [dimension + 'Z']: 0.01,\n    label: windowTitle,\n    labelColor: windowTitleColor,\n    labelFontSize: 1.25,\n    labelWordWrapMode: 'none',\n    labelAlignment: 'left',\n});\n\nconst closeButtonMods = modFactory.iconButton({\n    space,\n    transformBy: topBarRootMod.transformId,\n    dimension,\n    pos: { \n        x: windowHalfSizeX - (TOP_BAR_BUTTON_SIZE / 2) - TOP_BAR_CLOSE_BUTTON_RIGHT,\n        y: 0,\n        z: 0.05\n    },\n    buttonSize: { x: TOP_BAR_BUTTON_SIZE, y: TOP_BAR_BUTTON_SIZE, z: 0.1 },\n    icon: 'https://builder-ltm-files.s3.amazonaws.com/6fc813c6686e9f7f77eedb85a0581965620933fa0615e7e54ab15249fab62cd9.png',\n    iconAspect: 1,\n    iconRenderOrder: 50,\n    buttonColor: 'transparent',\n    onClick: onClose,\n});\ncloseButtonMods[0].closeButton = 'root';\ncloseButtonMods[1].closeButton = 'button';\ncloseButtonMods[2].closeButton = 'icon';\n\nconst pinButtonMods = modFactory.iconButton({\n    space,\n    transformBy: topBarRootMod.transformId,\n    dimension,\n    pos: { \n        x: windowHalfSizeX - (TOP_BAR_BUTTON_SIZE / 2) - TOP_BAR_PIN_BUTTON_RIGHT,\n        y: 0,\n        z: 0.05\n    },\n    buttonSize: { x: TOP_BAR_BUTTON_SIZE, y: TOP_BAR_BUTTON_SIZE, z: 0.1 },\n    icon: 'https://builder-ltm-files.s3.amazonaws.com/108aa32769c9d69dc13e1e02942989b3f696f9ba0338cb0a04e2b10357e3ebb9.png',\n    iconAspect: 1,\n    iconRenderOrder: 50,\n    buttonColor: 'transparent',\n});\npinButtonMods[0].pinButton = 'root';\npinButtonMods[1].pinButton = 'button';\npinButtonMods[2].pinButton = 'icon';\n\nreturn [\n    windowRootMod, \n    windowBackgroundMod, \n    topBarRootMod,\n    topBarBackgroundMod,\n    topBarTitleMod,\n    ...closeButtonMods,\n    ...pinButtonMods,\n];",
        "system": "rc-xrScreenExample.modFactory",
        "textArea": "@const tags = that ?? {};\n\nconst defaults = {\n    scaleX: 5,\n    scaleY: 2,\n    scaleZ: 0.1,\n    label: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque vitae velit sollicitudin, vestibulum dolor ut, ultrices eros. Aenean a purus vel enim cursus fermentum sed in nunc.',\n    labelPadding: 0.1,\n    labelWordWrapMode: 'breakWords',\n    draggable: false,\n    pointable: false,\n    color: 'transparent',\n}\n\nreturn {\n    ...defaults,\n    ...tags,\n}",
        "window": "@const {\n    windowSizeX = 5,\n    windowSizeY = 3,\n    windowVisible = true,\n    dimension,\n    space = 'tempLocal',\n} = that;\nconst tags = that ?? {};\n\nassert(dimension, '[window] dimension is required');\n\nconst rootMod = {\n    space,\n    transformId: uuid(),\n    anchorPoint: 'center',\n    draggable: false,\n    pointable: false,\n    color: 'transparent',\n    [dimension]: true,\n}\n\nconst pivotMod = {\n    space,\n    transformBy: rootMod.transformId,\n    transformId: uuid(),\n    anchorPoint: 'center',\n    draggable: false,\n    pointable: false,\n    color: 'transparent',\n    [dimension]: true,\n    [dimension + 'RotationX']: Math.PI / 2,\n}\n\nconst windowBackgroundMod = {\n    space,\n    transformId: uuid(),\n    transformBy: pivotMod.transformId,\n    anchorPoint: 'center',\n    form: 'sprite',\n    color: windowVisible ? colorPalette.tags.darkBlue : 'transparent',\n    scaleX: windowSizeX,\n    scaleY: windowSizeY,\n    draggable: false,\n    // pointable: windowVisible,\n    pointable: false,\n    windowBackground: true,\n    [dimension]: true,\n}\n\nreturn [rootMod, pivotMod, windowBackgroundMod];"
      }
    },
    "rc-xrScreenExample.colorPalette": {
      "id": "rc-xrScreenExample.colorPalette",
      "space": "shared",
      "tags": {
        "brightGreen": "#68BC00",
        "brightGreenHighlight": "#A4DD00",
        "closedGreyBlue": "#63808d",
        "criticalRed": "#f44336",
        "darkBlue": "#366291",
        "darkGrey": "#707070",
        "darkRed": "#950a00",
        "fmdRed": "#c60d30",
        "lightBlue": "#c0d2e7",
        "lightGrey": "#d3d3d3",
        "mediumBlue": "#628fc4",
        "mediumBlueHighlight": "#8dafdb",
        "mediumGrey": "#a0a0a0",
        "onAuxPackageLoaded": "@globalThis.colorPalette = thisBot;",
        "onDestroy": "@globalThis.colorPalette = undefined;",
        "orange": "#ff9d02",
        "progressPurple": "#673ab7",
        "system": "rc-xrScreenExample.colorPalette",
        "verifiedGold": "#ff9800",
        "warningYellow": "#ffd500"
      }
    },
    "rc-xrScreenExample.screenManager": {
      "id": "rc-xrScreenExample.screenManager",
      "space": "shared",
      "tags": {
        "clearScreens": "@// Find and destroy all screens that were create by this bot.\nconst bots = getBots('screenGroupId');\n\nif (bots && bots.length) {\n    console.log(`[screenManager] destroying ${bots.length} bots`);\n    destroy(bots);\n}",
        "createScreen": "@const { \n    name,\n    args,\n    screenGroupId = uuid(),\n    onScreenReady,\n} = that;\n\nconst baseScreen = links.baseScreen;\n\nif (!screenFactory) {\n    throw new Error(`[screenManager] Could not find screenFactory`);\n}\nif (!baseScreen) {\n    throw new Error(`[screenManager] Could not find baseScreen`);\n}\n\nconst factoryFuncName = name;\nconst factoryFunc = screenFactory.getConstructorFunction(factoryFuncName);\n\nif (!factoryFunc) {\n    throw new Error(`[screenManager] No screen factory function named ${factoryFuncName} found on bot ${screenFactory.id.substring(0, 5)}`);\n}\n\nconst factoryFuncResult = factoryFunc({args});\n\nif (typeof factoryFuncResult !== 'object') {\n    throw new Error(`[screenManager] Factory function '${factoryFuncName}' did not return mods.`);\n}\n\nconst mods = Array.isArray(factoryFuncResult) ? factoryFuncResult : [factoryFuncResult];\nconst dim = configBot.tags.gridPortal;\nlet rootModIndex = -1;\n\nif (tags.debug) {\n    console.log(`[screenManager] Factory function '${factoryFuncName}' returned mods:`, mods);\n}\n\nfor (let i = 0; i < mods.length; i++) {\n    let m = mods[i];\n\n    // Each element should be a mod.\n    if (typeof m !== 'object') {\n        console.error(`offending element:`, m);\n        throw new Error(`[screenManager] Factory function '${factoryFuncName}' must return only mods.`);\n    }\n\n    // Each mod should be in tempLocal space.\n    if (m.space !== 'tempLocal') {\n        console.error(`offending mod:`, m);\n        throw new Error(`[screenManager] Factory function '${factoryFuncName}' must return only mods that are assigned to tempLocal space.`);\n    }\n\n    // If not already, set each bot to be in the user's current dimensions.\n    if (m[dim] === undefined) {\n        m[dim] = true;\n    }\n    if (!m[`${dim}X`]) {\n        m[`${dim}X`] = 0;\n    }\n    if (!m[`${dim}Y`]) {\n        m[`${dim}Y`] = 0;\n    }\n    if (!m[`${dim}Z`]) {\n        m[`${dim}Z`] = 0;\n    }\n\n    if (!m.transformBy && m[dim]) {\n        if (rootModIndex < 0) {\n            rootModIndex = i;\n        } else {\n            console.error(`offending mod:`, m);\n            throw new Error(`[screenManager] Factory function '${factoryFuncName}' returns multiple mods with no transformer (using transformBy tag).`);\n        }\n    }\n\n    // Mark each mod with a matching screenGroupId tag that can \n    // be used to find all bots related to this screen.\n    m.screenGroupId = screenGroupId;\n\n    // Give each mod a link to this screenManager.\n    m.screenManager = thisBot.link;\n\n    // Cache the positionn of the dimension for the mod so that the screen manager can set it back to\n    // its desired position after spawning frames have passed.\n    m[`_screenManagerCache_${dim}X`] = m[`${dim}X`];\n    m[`_screenManagerCache_${dim}Y`] = m[`${dim}Y`];\n    m[`_screenManagerCache_${dim}Z`] = m[`${dim}Z`];\n\n    // Move each mod to be in a position far away from the user for the spawning frames.\n    m[`${dim}X`] = 0;\n    m[`${dim}Y`] = 0;\n    m[`${dim}Z`] = 1000;\n}\n\nif (rootModIndex >= 0) {\n    // Apply root mod to the base screen mod to get the final screen root mod.\n    const baseScreenMod = getMod(baseScreen);\n\n    const ignoreTags = ['listening', 'system', 'auxCodeOrigin', 'draggable'];\n    ignoreTags.forEach(t => delete baseScreenMod[t]);\n\n    mods[rootModIndex] = {...baseScreenMod, ...mods[rootModIndex]};\n\n    if (tags.debug) {\n        console.log(`[screenManager] screen root mod:`, mods[rootModIndex]);\n    }\n} else {\n    throw new Error(`[screenManager] Factory function '${factoryFuncName}' must return only one mod that does not have a transformer set.`);\n}\n\nif (tags.debug) {\n    console.log(`[screenManager] mods to create:`, mods);\n}\n\nlet bots = create(mods);\nbots = Array.isArray(bots) ? bots : [bots];\n\nif (tags.debug) {\n    console.log(`[screenManager] created screenGroupId ${screenGroupId}. Bot count: ${bots.length}`);\n}\n\nconst ON_SCREEN_CREATED = 'onScreenCreated';\nconst ON_SCREEN_READY = 'onScreenReady';\n\nfor (let b of bots) {\n    // Execute screen created functions on bots.\n    // This allows the bots to do any last minute setup if needed, and the rest of the bots\n    // are reliably available for reference.\n    if (b[ON_SCREEN_CREATED] && typeof b[ON_SCREEN_CREATED] === 'function') {\n        b[ON_SCREEN_CREATED]({ name, args, bots });\n    }\n}\n\n// Give CasualOS some frames to to get the bots into state.\nos.sleep(100).then(() => {\n    for (let b of bots) {\n        // Put the bot back to its cached position when it was created.\n        // This is a workaround for a transform parenting timing issue with the transformLinker tool.\n        // This prevents screens from appearing in front of the user oriented and scaled incorrectly for a frame.\n        b.tags[`${dim}X`] = b.tags[`_screenManagerCache_${dim}X`];\n        b.tags[`${dim}Y`] = b.tags[`_screenManagerCache_${dim}Y`];\n        b.tags[`${dim}Z`] = b.tags[`_screenManagerCache_${dim}Z`];\n    }\n\n    for (let b of bots) {\n        // Execute screen ready functions on bots.\n        // This allows the bots to do any last minute setup if needed, after the screen manager has finished doing what\n        // it needs to do to the screens.\n        if (b[ON_SCREEN_READY] && typeof b[ON_SCREEN_READY] === 'function') {\n            b[ON_SCREEN_READY]({ name, args, bots });\n        }\n    }\n\n    if (onScreenReady) {\n        onScreenReady(name, bots);\n    }\n\n    os.sleep(100).then(() => {\n    })\n\n});\n\nreturn bots;",
        "debug": "false",
        "destroyScreen": "@const target = that;\n\nlet groupId = undefined;\n\nif (typeof target === 'string') {\n    // target is groupId\n    groupId = target;\n} else {\n    // target is bot\n    groupId = target.tags.screenGroupId;\n}\n\nif (groupId && typeof groupId === 'string') {\n    const bots = getBots('screenGroupId', groupId);\n    if (bots && bots.length) {\n        if (tags.debug) {\n            console.log(`[screenManager] destroying screenGroupId ${groupId}. Bot count: ${bots.length}`);\n        }\n\n        destroy(getBots('screenGroupId', groupId));\n        shout('onScreenDestroyed', { screenGroupId: groupId });\n\n        return true;\n    } else {\n        console.log(`[screenManager] no bots found with screenGroupId ${groupId}.`);\n        return false;\n    }\n} else {\n    console.error(`[screenManager] invalid screenGroupId ${groupId}.`);\n}\n\n\n\n",
        "onAuxPackageLoaded": "@globalThis.screenManager = thisBot;",
        "onDestroy": "@console.log(`[screenManager] onDestroy`);\nthisBot.clearScreens();\nglobalThis.screenManager = undefined;",
        "onInitialize": "@masks.screenFactory = getBot('system', 'rc-xrScreenExample.screenFactory').link;\nmasks.baseScreen = getBot('system', 'rc-xrScreenExample.baseScreen').link;",
        "system": "rc-xrScreenExample.screenManager"
      }
    },
    "rc-xrScreenExample._packageInfo": {
      "id": "rc-xrScreenExample._packageInfo",
      "space": "shared",
      "tags": {
        "system": "rc-xrScreenExample._packageInfo",
        "version": "1.2",
        "versionDate": "ðŸ“…2024-05-02T15:19:01.983-04:00 local"
      }
    },
    "rc-xrScreenExample.screenFactory": {
      "id": "rc-xrScreenExample.screenFactory",
      "space": "shared",
      "tags": {
        "addConstructor": "@const { bot } = that;\nmasks[`constructorBot_${bot.id}`] = bot.link;",
        "confirmDialog": "@const { \n    yesLabel = 'OK',\n    noLabel = 'Cancel',\n    message,\n    messageFontSize = 1,\n    callback\n} = that.args;\n\nconst rootTransformId = uuid();\nconst windowTransformId = uuid();\nconst dimTag = configBot.tags.gridPortal;\nconst dimXTag = `${dimTag}X`;\nconst dimYTag = `${dimTag}Y`;\nconst dimZTag = `${dimTag}Z`;\n\nconst mods = [];\n\n// Root\nmods.push({\n    transformId: rootTransformId,\n    space: 'tempLocal',\n    draggable: false,\n    pointable: false,\n    color: 'transparent',\n});\n// Window\nmods.push({\n    transformId: windowTransformId,\n    transformBy: rootTransformId,\n    space: 'tempLocal',\n    draggable: false,\n    pointable: false,\n    color: 'transparent',\n    [dimZTag]: -2,\n});\n// Window Background\nmods.push({\n    transformBy: rootTransformId,\n    space: 'tempLocal',\n    form: 'sprite',\n    color: colorPalette.tags.darkBlue,\n    scaleX: 8,\n    scaleY: 4,\n    scaleZ: 0.2,\n    draggable: false,\n    [dimZTag]: -1,\n});\n// Text Area\nmods.push(modFactory.textArea({\n    transformBy: rootTransformId,\n    space: 'tempLocal',\n    label: message,\n    labelColor: 'white',\n    labelFontSize: messageFontSize,\n    scaleX: 7.5,\n    scaleY: 2.4,\n    [dimXTag]: 0,\n    [dimYTag]: 0.7,\n    [dimZTag]: -0.75,\n}));\n// Yes Button\nmods.push(modFactory.button({\n        transformBy: windowTransformId,\n        space: 'tempLocal',\n        form: 'sprite',\n        buttonColor: colorPalette.tags.mediumBlue,\n        hoverColor: colorPalette.tags.mediumBlueHighlight,\n        label: yesLabel.toUpperCase(),\n        labelColor: 'white',\n        [dimXTag]: -1.5,\n        [dimYTag]: -1,\n        [dimZTag]: 0.2,\n        scaleX: 2.5,\n        scaleZ: 0.15,\n        callback,\n        onClick: `@\n            thisBot.callback(true);\n            screenManager.destroyScreen(thisBot);\n        `,\n    }\n));\n// No Button\nmods.push(modFactory.button({\n        transformBy: windowTransformId,\n        space: 'tempLocal',\n        form: 'sprite',\n        buttonColor: colorPalette.tags.mediumBlue,\n        hoverColor: colorPalette.tags.mediumBlueHighlight,\n        label: noLabel.toUpperCase(),\n        labelColor: 'white',\n        [dimXTag]: 1.5,\n        [dimYTag]: -1,\n        [dimZTag]: 0.2,\n        scaleX: 2.5,\n        scaleZ: 0.15,\n        callback,\n        onClick: `@\n            thisBot.callback(false);\n            screenManager.destroyScreen(thisBot);\n        `,\n    }\n));\n\nreturn mods;",
        "emptyPinnableWindow": "@const rootTransformId = uuid();\nconst windowTransformId = uuid();\nconst dimTag = configBot.tags.gridPortal;\nconst dimXTag = `${dimTag}X`;\nconst dimYTag = `${dimTag}Y`;\nconst dimZTag = `${dimTag}Z`;\n\nconst mods = [];\n\n// Root\nmods.push({\n    transformId: rootTransformId,\n    space: 'tempLocal',\n    draggable: false,\n    pointable: false,\n    color: 'transparent',\n});\n\nconst pinnableWindowMods = modFactory.pinnableWindow({\n    space: 'tempLocal',\n    dimension: dimTag,\n    transformBy: rootTransformId,\n    transformId: windowTransformId,\n    windowTitle: 'Empty Window',\n    onClose: `@screenManager.destroyScreen(thisBot)`\n});\nmods.push(...pinnableWindowMods);\n\nmods.push(modFactory.textArea({\n    space: 'tempLocal',\n    transformBy: windowTransformId,\n    dimension: dimTag,\n    labelColor: 'white',\n    label: 'This is an empty pinnable window.',\n    labelFontSize: 1.1,\n}))\n\n\nreturn mods;",
        "getConstructorFunction": "@const name = that;\n\nif (tags[name]) {\n    return thisBot[name];\n} else {\n    // Look through linked constructor bots until a match is found.\n    const linkKeys = Object.keys(links);\n    for (let key of linkKeys) {\n        const bot = links[key];\n        if (bot.tags[name]) {\n            return bot[name];\n        }\n    }\n}",
        "infoDialog": "@const { \n    buttonLabel = 'OK',\n    message,\n    callback\n} = that.args;\n\nconst rootTransformId = uuid();\nconst windowTransformId = uuid();\nconst dimTag = configBot.tags.gridPortal;\nconst dimXTag = `${dimTag}X`;\nconst dimYTag = `${dimTag}Y`;\nconst dimZTag = `${dimTag}Z`;\n\nconst mods = [];\n\n// Root\nmods.push({\n    transformId: rootTransformId,\n    space: 'tempLocal',\n    draggable: false,\n    pointable: false,\n    color: 'transparent',\n});\n// Window\nmods.push({\n    transformId: windowTransformId,\n    transformBy: rootTransformId,\n    space: 'tempLocal',\n    draggable: false,\n    pointable: false,\n    color: 'transparent',\n    [dimZTag]: -2,\n});\n// Window Background\nmods.push({\n    transformBy: rootTransformId,\n    space: 'tempLocal',\n    form: 'sprite',\n    color: colorPalette.tags.darkBlue,\n    scaleX: 8,\n    scaleY: 4,\n    scaleZ: 0.2,\n    draggable: false,\n    [dimZTag]: -1,\n});\n// Text Area\nmods.push(modFactory.textArea({\n        transformBy: rootTransformId,\n        space: 'tempLocal',\n        label: message,\n        labelColor: 'white',\n        labelFontSize: 1,\n        scaleX: 7.5,\n        [dimXTag]: 0,\n        [dimYTag]: 0.75,\n        [dimZTag]: -0.75,\n    }\n));\n// Ok Button\nmods.push(modFactory.button({\n        transformBy: windowTransformId,\n        space: 'tempLocal',\n        form: 'sprite',\n        buttonColor: colorPalette.tags.mediumBlue,\n        hoverColor: colorPalette.tags.mediumBlueHighlight,\n        label: buttonLabel.toUpperCase(),\n        labelColor: 'white',\n        [dimXTag]: 0,\n        [dimYTag]: -1,\n        [dimZTag]: 0.2,\n        scaleX: 2.5,\n        scaleZ: 0.15,\n        callback,\n        onClick: `@\n            if (thisBot.callback) {\n                thisBot.callback();\n            }\n            screenManager.destroyScreen(thisBot);\n        `,\n    }\n));\n\nreturn mods;",
        "onAuxPackageLoaded": "@globalThis.screenFactory = thisBot;",
        "onDestroy": "@globalThis.screenFactory = undefined;",
        "removeConstructor": "@const name = that;\nmasks[name] = null;",
        "system": "rc-xrScreenExample.screenFactory"
      }
    }
  }
}